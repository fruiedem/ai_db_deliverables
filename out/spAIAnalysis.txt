--- spBatchTransferHolidayInfo ---
아래는 요청하신 SQL 프로시저 코드의 주요 로직을 정리한 내용입니다:

### 프로시저의 주요 목적
- **뷰를 참조하여 로컬 디비의 휴일 데이터를 동기화 한다 (10년치)**

### 주요 로직 흐름
1. **트랜잭션 설정**
   - `TRANSACTION ISOLATION LEVEL READ UNCOMMITTED`로 설정하여 읽기 트랜잭션 동안 잠금을 최소화
   - `@result_cd`, `@result_msg`, `@vSeverity` 등의 변수 선언

2. **휴일 데이터 처리**
   - `dbo.calendar` 테이블을 비움 (TRUNCATE)
   - 2024년 1월 1일부터 2034년 12월 31일까지 반복하여 주말(토, 일) 데이터를 생성
   - `dbo.VW_NPD_HolidayCalendar` 뷰에서 휴일 데이터를 읽어 `target_holiday` 테이블에 임시 저장

3. **휴일 데이터 동기화**
   - `dbo.calendar` 테이블에 새롭게 생성된 주말 및 휴일 데이터를 업데이트
   - `target_holiday` 테이블과 조인하여 `date_description`과 `creator_id`를 설정

4. **트랜잭션 완료**
   - 모든 작업이 성공하면 트랜잭션을 커밋
   - 실패 시 롤백 수행

5. **결과 로깅**
   - `dbo.use_log` 테이블에 동기화 결과(성공/실패)를 기록

### 주요 기능 요약
- **주말 데이터 생성**: 2024년부터 10년간의 주말 데이터를 사전 생성
- **휴일 데이터 동기화**: 외부 뷰에서 가져온 휴일 데이터를 로컬 테이블에 반영
- **트랜잭션 안전성**: 트랜잭션을 통해 데이터 일관성 유지 및 오류 시 롤백 가능
- **결과 추적**: 동기화 결과에 대한 상세 로깅을 통해 모니터링 용이

이 프로시저는 매년 10년간의 휴일 데이터를 한 번에 동기화하도록 설계되었으며, IS팀의 요청에 따라 아웃풋 파라미터를 제거하고 트랜잭션 안정성을 강화한 특징이 있습니다.

--- spBatchTransferDeptMaster ---
아래는 요청하신 SQL 프로시저 코드의 주요 로직을 정리한 것입니다:

### 프로시저의 주요 목적:
- **부서 정보 동기화**: `dbo.dept_master` 테이블을 외부 데이터 소스 (`dbo.VW_NPD_orgDeptMaster`)의 부서 정보로 동기화합니다.

---

### 주요 로직 흐름:

1. **트랜잭션 설정**:
   - `TRANSACTION ISOLATION LEVEL READ UNCOMMITTED`로 설정하여 읽기 트랜잭션 중 병목 현상을 최소화.
   - `BEGIN TRAN`과 `COMMIT TRAN`을 사용하여 데이터 일관성을 유지.

2. **데이터 동기화**:
   - `dbo.dept_master` 테이블을 먼저 비운 다음, `dbo.VW_NPD_orgDeptMaster` 뷰의 데이터를 삽입합니다.
   - 삽입 시 `creator_id`는 'system', `created_at`은 현재 시간으로 설정됩니다.

3. **오류 처리**:
   - `BEGIN TRY`와 `BEGIN CATCH` 블록을 사용하여 오류 발생 시 롤백 수행.
   - 오류 발생 시 `result_cd`는 -1, `result_msg`는 오류 메시지로 설정됩니다.

4. **로깅**:
   - 동기화 결과 (성공/실패)를 `dbo.use_log` 테이블에 기록합니다.
   - 로그 내용: 동기화 일시, 결과 코드, 결과 메시지, 프로시저 이름, 프로시저 파라미터, 생성 일시 등을 포함합니다.

---

### 주요 특징:
- **동기화 대상**: `dbo.dept_master` 테이블의 부서 정보는 외부 뷰 (`dbo.VW_NPD_orgDeptMaster`)의 최신 데이터를 반영합니다.
- **일관성 유지**: 트랜잭션을 통해 데이터 동기화 과정에서 발생할 수 있는 오류를 방지하고, 성공/실패 결과를 로깅하여 추적을 용이하게 합니다.
- **스케줄링**: 프로시저 실행 예시 (`EXEC [dbo].[spTransferDeptMaster]`)를 통해 주기적인 동기화 작업으로 사용됩니다.

--- spBatchTransferHreMaster ---
아래는 요청하신 SQL 프로시저 코드의 주요 로직을 정리한 내용입니다:

### 프로시저명: [dbo].[spBatchTransferHreMaster]

**주요 로직:**

1. **변수 선언**
   - `@result_cd` (INT): 결과 코드
   - `@result_msg` (VARCHAR): 결과 메시지
   - `@vSeverity` (INT): 심각도
   - `@target_hrm` (테이블 변수): 동기화 대상 회원 정보 테이블

2. **트랜잭션 설정**
   - 트랜잭션 격리 수준을 `READ UNCOMMITTED`로 설정
   - `BEGIN TRAN`으로 트랜잭션 시작

3. **회원 정보 동기화 로직**
   - **퇴사자 처리**:
     - `dbo.hr_master` 테이블에서 `dbo.VW_NPD_hreMaster` 테이블과 일치하지 않는 행(퇴사자)을 `@target_hrm` 테이블에 삽입
     - 상태 코드(`STATE_CD`)를 '90'으로 설정

   - **기존 회원 처리**:
     - `dbo.VW_NPD_hreMaster` 테이블에서 존재하는 회원을 `@target_hrm` 테이블에 삽입
     - 상태 코드(`STATE_CD`)를 '10'으로 설정

   - `dbo.hr_master` 테이블 비우기(`TRUNCATE`)
   - `@target_hrm` 테이블의 데이터를 `dbo.hr_master` 테이블에 재삽입

4. **트랜잭션 완료**
   - 오류 발생 시 `ROLLBACK TRAN`
   - 정상 완료 시 `COMMIT TRAN`

5. **결과 처리**
   - 성공 시 `@result_cd = 0`, `@result_msg = '성공'`
   - 실패 시 `@result_cd = -1`, `@result_msg = ERROR_MESSAGE()`, `@vSeverity = ERROR_SEVERITY()`

6. **로그 기록**
   - 동기화 결과와 관련된 정보를 `dbo.use_log` 테이블에 기록

**주요 목적:**
- `dbo.hr_master` 테이블을 `dbo.VW_NPD_hreMaster` 테이블과 동기화하여 회원 정보를 업데이트하고, 변경 사항을 로그에 기록하는 프로시저입니다.

--- spInsertProjectMemberByTemplate ---
아래는 요청하신 SQL 프로시저 코드의 주요 로직을 정리한 것입니다.

### 프로시저명: spInsertProjectMemberByTemplate

**목적:** 담당자 일괄 인서트

**주요 로직:**

1. **입력 파라미터**
   - `@task_template`: 프로젝트 멤버 템플릿 정보를 담은 테이블 값 파라미터
   - `@result_cd`: 결과 코드 (0:성공, -1:실패)
   - `@result_msg`: 결과 메시지

2. **트랜잭션 설정**
   - 트랜잭션 격리 수준을 `READ UNCOMMITTED`로 설정
   - `BEGIN TRY` 블록에서 실제 데이터 처리

3. **데이터 삽입 로직**
   - `project_member` 테이블에 데이터 삽입
   - `task_template`에서 제공된 프로젝트 ID, 멤버 ID, 크리에이터 ID를 기반으로 삽입
   - `status_cd`는 기본값 '10' (승인)으로 설정
   - `created_at`은 현재 시간 `GETDATE()`로 설정
   - 기존 멤버가 없는 경우에만 삽입 (LEFT JOIN으로 중복 체크)

4. **오류 처리**
   - `BEGIN CATCH` 블록에서 오류 발생 시 트랜잭션 롤백
   - 오류 메시지는 `@result_msg`에 저장

5. **결과 반환**
   - 성공 시 `@result_cd = 0`, 실패 시 `@result_cd = -1` 반환
   - 결과 메시지는 `@result_msg`에 담겨 반환

### 예시 실행 코드:
```sql
DECLARE @tvp dbo.project_applicant_template,
        @result_cd INT,
        @result_msg VARCHAR(100);

INSERT INTO @tvp( project_id, member_id, creator_id)
VALUES (2, '2400000', '2400000'),
        (2, '2400001', '2400000'),
        (2, '2400002', '2400000'),
        (2, '2400003', '2400000'),
        (2, '2400004', '2400000'),
        (2, '2400005', '2400000'),
        (2, '2400006', '2400000'),
        (2, '2400007', '2400000'),
        (2, '2400008', '2400000'),
        (2, '2400009', '2400000');

EXEC [dbo].[spInsertProjectMemberByTemplate]
    @task_template = @tvp,
    @result_cd = @result_cd OUTPUT,
    @result_msg = @result_msg OUTPUT;

SELECT @result_cd as result_cd, @result_msg as result_msg;
```

### 주요 특징:
- **트랜잭션 안전성:** `BEGIN TRY`와 `BEGIN CATCH`를 사용하여 데이터 일관성 유지
- **중복 방지:** `LEFT JOIN`을 이용해 기존 멤버와 중복되는 경우 삽입 제외
- **유연한 결과 처리:** `@result_cd`와 `@result_msg`를 통해 명확한 결과 반환

이 프로시저는 대량의 담당자 데이터를 안전하게 삽입하는 데 유용하며, 이미 존재하는 멤버는 자동으로 필터링됩니다.

--- spInsertProjectTaskTemplate ---
아래는 요청하신 SQL 프로시저 코드의 주요 로직을 정리한 내용입니다:

### 프로시저의 주요 목적
- 프로젝트 템플릿을 기반으로 일괄적으로 태스크를 생성하는 프로시저입니다.

### 주요 로직 흐름
1. **입력 파라미터 및 임시 테이블 선언**
   - 입력 파라미터로 `@task_template` 테이블 변수를 사용하여 태스크 템플릿 데이터를 받습니다.
   - 결과 코드(`@result_cd`)와 메시지(`@result_msg`)를 출력용으로 선언합니다.

2. **프로젝트 정보 확인**
   - `@task_template`에서 `project_id`와 `creator_id`를 추출합니다.
   - 프로젝트가 존재하지 않으면 오류를 반환합니다.
   - 프로젝트는 하나만 처리되며, 여러 프로젝트일 경우 오류를 반환합니다.

3. **태스크 및 의존성 정보 생성**
   - **태스크 생성**: `@task_template`의 데이터를 기반으로 `dbo.task` 테이블에 태스크를 생성합니다.
   - **태스크 의존성 생성**: `@task_template`에서 정의된 의존성 관계를 기반으로 `dbo.task_dependency` 테이블을 생성합니다.

4. **태스크 완료 계획(Finish Plan) 생성**
   - 최초 태스크의 시작일과 종료일을 계산하여 `@task_finish_plan` 임시 테이블에 데이터를 생성합니다.
   - `std_working_day`를 기반으로 종료일을 계산하고, 의존성 관계를 고려하여 시작일과 종료일을 설정합니다.

5. **태스크 완료 계획 데이터 삽입**
   - `@task_finish_plan` 임시 테이블의 데이터를 `dbo.task_finish_plan` 테이블에 삽입합니다.

6. **트랜잭션 관리 및 오류 처리**
   - 전체 로직을 트랜잭션으로 관리하며, 오류 발생 시 롤백을 수행합니다.
   - 성공 또는 실패에 따라 결과 코드와 메시지를 설정합니다.

7. **로그 기록**
   - 프로시저 실행 내역을 `dbo.use_log` 테이블에 기록합니다.

### 주요 기능 요약
- 프로젝트 템플릿을 기반으로 태스크와 태스크 의존성을 생성합니다.
- 태스크의 시작일과 종료일을 `std_working_day`를 기준으로 계산하여 생성합니다.
- 생성된 태스크와 의존성, 계획 데이터를 데이터베이스에 저장합니다.
- 성공 또는 실패 결과를 반환하고, 로그를 기록합니다.

이 프로시저는 프로젝트 템플릿을 기반으로 일괄적으로 태스크를 생성하는 기능을 수행하며, 의존성 관계와 완료 계획을 자동으로 설정하는 역할을 합니다.

--- spUpdateDateByShifting ---
아래는 요청하신 SQL 프로시저 코드의 주요 로직을 정리한 내용입니다.

### 프로시저의 주요 목적
- 일정 변경이 발생했을 때 일자 보정을 수행하는 프로시저입니다.

### 주요 로직 흐름
1. **입력 파라미터 및 출력 변수 선언**
   - 입력 파라미터: `@pProject_id`, `@pTask_id`, `@pPlan_cd`
   - 출력 변수: `@result_cd`, `@result_msg`

2. **트랜잭션 및 격리 수준 설정**
   - 트랜잭션 격리 수준을 `READ UNCOMMITTED`로 설정.
   - 트랜잭션을 시작하고, 성공 시 커밋, 실패 시 롤백 처리.

3. **프로세스 태스크 ID 결정**
   - 특정 테스크에 대한 변경이 아닐 경우, 전체 보정을 위해 프로젝트 ID를 기반으로 최상위 태스크 ID를 조회.
   - 특정 테스크에 대한 변경일 경우, 해당 테스크의 부모 태스크 ID를 조회. 부모가 없으면 해당 태스크 ID를 사용.

4. **일정 보정 처리 반복문**
   - `WHILE` 루프를 사용하여 각 태스크의 시작일과 종료일을 보정.
   - 2단계 업데이트: 하위 태스크의 시작일을 부모와 동일하게 처리.
   - 1단계 업데이트: 현재 태스크의 시작일과 종료일을 설정.
   - 다음 처리할 태스크 ID와 종료일을 설정.
   - 반복적으로 다음 태스크를 처리.

5. **에러 처리**
   - `TRY-CATCH` 블록을 사용하여 오류 발생 시 롤백 처리.
   - 오류 메시지를 출력 변수에 반환.

6. **로그 기록**
   - 프로시저 실행 내역을 `dbo.use_log` 테이블에 기록.

### 주요 기능 요약
- 프로젝트 ID와 플랜 코드를 기반으로 일정을 보정.
- 태스크 간 의존성을 고려하여 시작일과 종료일을 조정.
- 트랜잭션을 활용한 데이터 일관성 유지.
- 에러 처리 및 로깅 기능.

이 프로시저는 특정 프로젝트와 플랜에 대해 일정을 보정하는 작업을 수행하며, 의존성 규칙에 따라 태스크 간의 일정을 조정합니다.

--- spGetMemberId ---
아래는 요청하신 SQL 프로시저 코드의 주요 로직을 정리한 것입니다.

### 프로시저명: [dbo].[spGetMemberId]

#### 주요 기능:
- 로그인 시 MOIN_ID를 입력받아 member_id를 반환
- 추가적으로 로깅 기능 수행

#### 주요 로직:

1. **입력 파라미터 및 출력 파라미터 정의**
   - 입력 파라미터: `@pMOIN_ID` (VARCHAR(50) 타입)
   - 출력 파라미터: `@result_cd` (INT 타입), `@result_msg` (VARCHAR(200) 타입)

2. **트랜잭션 및 잠금 설정**
   - 트랜잭션 격리 수준을 `READ UNCOMMITTED`로 설정
   - `NOCOUNT`를 `ON`으로 설정하여 메시지 반환을 억제

3. **회원 정보 조회**
   - `dbo.hr_master` 테이블에서 `MOIN_ID`를 조건으로 검색
   - `LEFT JOIN`을 사용하여 `dbo.dept_auth` 테이블과 조회
   - `dept_auth_cd` 및 `dept_auth_name`을 추가로 가져옴

4. **결과 처리**
   - 회원이 존재하지 않을 경우 오류 반환 (`RAISERROR` 사용)
   - 정상적인 경우 `member_id`, `dept_auth_cd`, `dept_auth_name` 반환

5. **오류 처리**
   - `BEGIN CATCH` 블록을 사용하여 오류 발생 시 처리
   - 오류 메시지를 `@result_msg`에 저장

#### 예시 실행 코드:
```sql
DECLARE @result_cd INT,
        @result_msg VARCHAR(100);

EXEC [dbo].[spGetMemberId] @pMOIN_ID = 'jaykwon5156',
                                      @result_cd = @result_cd OUTPUT,
                                      @result_msg = @result_msg OUTPUT;

SELECT @result_cd AS result_cd,
       @result_msg AS result_msg;
```

#### 주요 기능 요약:
- MOIN_ID를 기반으로 회원 정보를 조회하고, 성공 시 member_id와 관련된 정보를 반환
- 다양한 오류 상황을 처리하여 명확한 메시지를 제공
- 트랜잭션을 통해 데이터 일관성 유지

--- spBatchUseLogCleansing ---
아래는 요청하신 SQL 프로시저 코드의 주요 로직을 정리한 내용입니다:

### 프로시저명: [dbo].[spBatchUseLogCleansing]

#### 주요 목적:
- `use_log` 테이블에서 일정 기간 동안 사용되지 않은 로그 데이터를 삭제하는 배치 프로시저입니다.

---

### 주요 로직:

1. **매개변수 정의:**
   - `@pPeriod_day` (INT): 데이터 유지 기간(일)을 지정합니다. 이 값이 `NULL`일 경우 오류를 반환합니다.
   - `@result_cd` (INT): 프로시저 실행 결과 코드를 반환합니다.
   - `@result_msg` (VARCHAR): 프로시저 실행 결과 메시지를 반환합니다.

2. **변수 선언:**
   - `@vSeverity` (INT): 오류의 심각성을 저장합니다.
   - `@vMin_dt` (VARCHAR): 로그 삭제 대상 날짜를 저장합니다. `@pPeriod_day` 일 전 날짜를 계산하여 삭제합니다.
   - `@vRow_cnt` (INT): 삭제된 행의 개수를 저장합니다.
   - `@vBatch_size` (INT): 한 번에 삭제할 행의 개수를 지정합니다. 기본값은 10,000입니다.
   - `@vProcessed_Rows` (INT): 전체 삭제된 행의 개수를 저장합니다.

3. **주요 처리 로직:**
   - `@pPeriod_day`가 `NULL`인 경우 오류를 반환합니다.
   - `use_log` 테이블에서 `@vMin_dt`보다 작은 날짜의 로그를 `@vBatch_size`개씩 삭제합니다.
   - 삭제 후 `@@ROWCOUNT`를 통해 삭제된 행의 개수를 확인하고, 전체 삭제 행 수를 누적합니다.
   - 삭제가 완료되면 결과 메시지를 설정하고 `use_log` 테이블에 삭제 결과를 로깅합니다.

4. **트랜잭션 및 예외 처리:**
   - 트랜잭션 격리를 `READ UNCOMMITTED`로 설정하여 성능을 최적화합니다.
   - `TRY-CATCH` 블록을 사용하여 오류를 처리하고, 오류 발생 시 `@result_cd`와 `@result_msg`를 설정합니다.

---

### 주요 특징:
- **배치 처리**: `@vBatch_size`개씩 삭제하여 메모리 사용을 최적화하고, 부하를 분산시킵니다.
- **로깅**: 프로시저 실행 결과와 삭제된 행의 개수를 `use_log` 테이블에 기록합니다.
- **예외 처리**: `@pPeriod_day`가 `NULL`인 경우 오류를 반환하고, 삭제 과정에서 발생하는 오류를 처리합니다.

이 프로시저는 일정 기간 동안 사용되지 않은 로그 데이터를 효율적으로 삭제하며, 삭제 결과를 명확히 기록하는 기능을 제공합니다.

--- spGetHolidayInfo ---
아래는 요청하신 SQL 프로시저 코드의 주요 로직을 정리한 내용입니다:

### 프로시저명: spGetHolidayInfo

**목적:** 휴일 정보를 가져오는 프로시저.

**매개변수:**
- `@pYear` (INT): 요청하는 연도 (NULL 가능)
- `@pMonth` (INT): 요청하는 월 (NULL 가능)
- `@result_cd` (INT): 결과 코드 (출력 파라미터)
- `@result_msg` (VARCHAR(200)): 결과 메시지 (출력 파라미터)

**주요 로직:**

1. **매개변수 유효성 검사:**
   - `@pMonth`가 NULL이거나 1~12 사이가 아니면 오류 반환.
   - `@pYear`와 `@pMonth` 중 하나라도 NULL이면 오류 반환.

2. **날짜 범위 설정:**
   - `@pYear`가 NULL이면 현재 연도로 설정.
   - 해당 월의 시작일과 종료일을 계산 (예: 2025-08-01 ~ 2025-08-31).

3. **캘린더 데이터 검사:**
   - `dbo.calendar` 테이블에서 해당 월의 날짜와 휴일 정보를 조회.
   - 조회 가능한 날짜 범위를 벗어난 경우 오류 반환.

4. **결과 반환:**
   - 정상적인 경우: `@result_cd = 0`, `@result_msg = '성공'`.
   - 오류 발생 시: `@result_cd = -1`, `@result_msg`에 오류 메시지 저장.

**실행 예시:**
```sql
DECLARE @result_cd INT, @result_msg VARCHAR(100);

EXEC [dbo].[spGetHolidayInfo]
    @pYear = 2025,
    @pMonth = 8,
    @result_cd = @result_cd OUTPUT,
    @result_msg = @result_msg OUTPUT;

SELECT @result_cd as result_cd, @result_msg as result_msg;
```

**주요 기능 요약:**
- 휴일 정보를 해당 월에 대해 조회하고, 유효하지 않은 매개변수나 날짜 범위를 처리하여 결과를 반환하는 프로시저입니다.

--- spGetDeptHierarchy ---
아래는 요청하신 SQL 프로시저 코드의 주요 로직을 정리한 내용입니다.

### 프로시저명: [dbo].[spGetDeptHierarchy]

#### 주요 기능: 조직도 조회 (전체 또는 특정 부서)

---

### 주요 로직 요약:

1. **입력 파라미터**
   - `@pDept_name`: 부서 이름 (예: '푸드사업부')
   - `@pDept_cd`: 부서 코드
   - `@result_cd`: 결과 코드 (출력)
   - `@result_msg`: 결과 메시지 (출력)

2. **부서 코드 추출**
   - `@pDept_name`이 제공되면 `dept_master` 테이블에서 해당 부서 코드를 조회
   - `@pDept_cd`가 제공되면 이를 직접 사용

3. **조직도 계층 구조 탐색**
   - `OrgHierarchy` CTE(Common Table Expression)를 사용하여 계층적 구조 생성
   - 루트 조건: `PARENT_DEPT_CODE`가 없거나 `NULL`인 경우
   - 재귀적으로 하위 조직 탐색

4. **결과 반환**
   - `DEPT_CODE`, `DEPT_NAME`, `PARENT_DEPT_CODE`를 `ORDER BY DEPT_CODE`로 정렬하여 반환
   - 성공 시 `@result_cd = 0`, `@result_msg = '성공'` 설정

---

### 예시 코드 (SQL Query 예시)

#### 전체 조회 예시:
```sql
DECLARE @result_project_id INT,
        @result_cd INT,
        @result_msg VARCHAR(100);

EXEC [dbo].[spGetDeptHierarchy]
    @pDept_name = NULL,
    @pDept_cd = NULL,
    @result_cd = @result_cd OUTPUT,
    @result_msg = @result_msg OUTPUT;

SELECT @result_cd as result_cd,
       @result_msg as result_msg;
```

#### 특정 부서 조회 예시:
```sql
DECLARE @result_project_id INT,
        @result_cd INT,
        @result_msg VARCHAR(100);

EXEC [dbo].[spGetDeptHierarchy]
    @pDept_name = '푸드사업부',
    @pDept_cd = NULL,
    @result_cd = @result_cd OUTPUT,
    @result_msg = @result_msg OUTPUT;

SELECT @result_cd as result_cd,
       @result_msg as result_msg;
```

--- spGetDeptMember ---
아래는 요청하신 SQL 프로시저 코드의 주요 로직을 정리한 내용입니다.

### 프로시저 [dbo].[spGetDeptMember]의 주요 로직 요약

1. **입력 파라미터 및 출력 파라미터 설정**
   - 입력 파라미터: `@pDept_cd` (부서 코드, 8자 길이의 문자열, 기본값 NULL)
   - 출력 파라미터: `@result_cd` (결과 코드, 정수), `@result_msg` (결과 메시지, 200자 길이의 문자열)

2. **프로시저 실행 로직**
   - **@pDept_cd 값이 NULL일 경우**
     - `@result_cd`를 1로 설정
     - `@result_msg`를 "조회 정보가 누락되었습니다."로 설정
     - 프로시저 종료

   - **부서 코드 유효성 검사**
     - `dept_master` 테이블에서 `@pDept_cd`와 일치하는 부서 코드가 존재하지 않으면
     - `@result_cd`를 1로 설정
     - `@result_msg`를 "존재하지 않는 부서코드 입니다."로 설정
     - 프로시저 종료

   - **부서 코드가 유효한 경우**
     - `hr_master` 테이블과 `dept_master` 테이블을 INNER JOIN하여 해당 부서에 속한 인원 정보를 조회
     - `@pDept_cd`가 NULL이면 모든 부서의 인원 정보를 조회
     - `@pDept_cd`가 유효한 부서 코드이면 해당 부서의 인원 정보를 조회
     - `@result_cd`를 0로 설정
     - `@result_msg`를 "성공"으로 설정
     - 프로시저 종료

3. **트랜잭션 및 성능 설정**
   - 트랜잭션 격리 수준을 `READ UNCOMMITTED`로 설정
   - `NOCOUNT`를 ON으로 설정하여 성능 향상

4. **결과 반환**
   - `hr_master` 테이블과 `dept_master` 테이블을 INNER JOIN하여 해당 부서에 속한 인원 정보를 반환
   - 반환 컬럼:
     - `EMP_ID` (직원 ID)
     - `NAME` (직원 이름)
     - `MOIN_ID` (모인 ID)
     - `MOIN_EMAIL` (모인 이메일)
     - `JOB_CODE` (직군 코드)
     - `JOB_GRADE_NM` (직급 이름)
     - `DEPT_CODE` (부서 코드)
     - `DEPT_NAME` (부서 이름)

### 예시 실행 코드
```sql
DECLARE @result_project_id INT,
        @result_cd INT,
        @result_msg VARCHAR(100);

EXEC [dbo].[spGetDeptMember]
    @pDept_cd = '13010101',
    @result_cd = @result_cd OUTPUT,
    @result_msg = @result_msg OUTPUT;

SELECT @result_cd as result_cd,
       @result_msg as result_msg;
```

### 요약
이 프로시저는 부서 코드를 기준으로 해당 부서에 속한 인원 정보를 조회하는 기능을 수행합니다. 입력된 부서 코드가 유효하지 않거나 누락되면 오류 메시지를 반환하며, 유효한 부서 코드가 입력되면 해당 부서의 인원 정보를 반환합니다.

--- spGetCodeMasterForLine ---
아래는 요청하신 SQL 프로시저 코드의 주요 로직을 정리한 내용입니다.

### 프로시저명: [dbo].[spGetCodeMasterForLine]

#### 주요 기능:
1. **코드 마스터 데이터 검색**
   - `code_master` 테이블에서 데이터 검색
   - 그룹 코드(`group_cd`)와 상태 코드(`is_active_cd`) 조건에 따라 레코드 추출

2. **페이지네이션**
   - 페이지 번호(`@pPage_no`)와 페이지 크기(`@pPage_size`)를 기반으로 페이지별 데이터 추출
   - 전체 레코드 수(`@total_count`)와 전체 페이지 수(`@total_pages`) 계산

3. **출력 파라미터**
   - 결과 코드(`@result_cd`), 결과 메시지(`@result_msg`), 전체 레코드 수(`@total_count`), 전체 페이지 수(`@total_pages`)를 출력 파라미터로 반환

#### 주요 로직:
1. **입력 파라미터 검사**
   - `@pGroup_cd`가 NULL일 경우, 그룹 코드 조건 없이 전체 데이터를 추출
   - `@pPage_no`, `@pPage_size`가 NULL 또는 0인 경우, 기본값으로 1, 20 사용

2. **데이터 검색**
   - `code_master` 테이블에서 `group_cd`와 `is_active_cd` 조건에 맞는 데이터를 추출
   - `group_cd`가 `'20001', '20002'`인 경우, `group_cd < '90000'` 조건 추가
   - 결과 데이터를 페이지 단위로 분할하여 반환

3. **오류 처리**
   - 오류 발생 시 `@result_cd`를 -1로, `@result_msg`를 오류 메시지로 설정
   - 전체 레코드 수와 페이지 수를 0으로 설정

#### 반환 값:
- `result_cd`: 0(성공) 또는 -1(실패)
- `result_msg`: 성공 시 '성공', 실패 시 오류 메시지
- `total_count`: 전체 레코드 수
- `total_pages`: 전체 페이지 수

이 프로시저는 라인 코드 검색 기능을 제공하며, 페이지네이션을 통해 대량의 데이터를 효율적으로 처리할 수 있습니다.

--- spDeleteOutputForTask ---
아래는 요청하신 SQL 프로시저 코드의 주요 로직을 정리한 내용입니다.

### 프로시저명: [dbo].[spDeleteOutputForTask]

**주요 기능: 산출물 정보를 삭제하는 프로시저**

---

### 주요 로직 요약:

1. **입력 파라미터**
   - `@pTask_id` (INT): 태스크 ID
   - `@pFile_path` (VARCHAR): 파일 경로
   - `@pModifier_id` (VARCHAR): 수정자 ID
   - `@result_cd` (INT): 결과 코드 (OUTPUT)
   - `@result_msg` (VARCHAR): 결과 메시지 (OUTPUT)

2. **주요 처리 로직**
   - **존재하지 않는 태스크 검증**:
     - `task` 테이블에서 `@pTask_id`로 해당 태스크가 존재하는지 확인
     - 존재하지 않으면 오류 반환 (`RAISERROR`)

   - **산출물 삭제**:
     - `task_output` 테이블에서 `@pTask_id`와 `@pFile_path`를 조건으로 해당 산출물의 `is_active_cd`를 '90'(비활성)으로 업데이트
     - 수정자 정보와 시간을 현재 날짜로 설정 (`Modifier_id`, `modified_at`)

   - **결과 반환**:
     - 성공 시 `@result_cd = 0`, `@result_msg = '성공'`
     - 실패 시 `@result_cd = -1`, `@result_msg`에 오류 메시지 반환

3. **트랜잭션 관리**
   - 트랜잭션 격리 수준을 `READ UNCOMMITTED`로 설정
   - 성공 시 커밋, 실패 시 롤백

4. **로깅**
   - 프로시저 실행 내역을 `use_log` 테이블에 기록
   - 입력 파라미터와 결과 정보를 포함하여 로깅

---

### 주요 기능 정리

- **기능**: 태스크에 대한 산출물 삭제
- **삭제 조건**: `@pTask_id`와 `@pFile_path`를 기준으로 일치하는 산출물만 삭제
- **삭제 후 처리**: 삭제된 산출물의 `is_active_cd`를 '90'(비활성)으로 설정
- **반환 값**: 성공/실패 여부와 메시지를 `@result_cd`와 `@result_msg`로 반환

이 프로시저는 특정 태스크에 대한 산출물을 삭제하는 기능을 수행하며, 삭제 후 관련 정보를 로깅합니다.

--- spUpdateOutputForTask ---
아래는 요청하신 SQL 프로시저 코드의 주요 로직을 정리한 내용입니다:

### 프로시저명: [dbo].[spUpdateOutputForTask]

**목적:** 태스크에 대한 산출물 정보를 수정하는 프로시저.

**주요 로직:**

1. **입력 파라미터 및 출력 파라미터 정의**
   - 입력 파라미터: `@pTask_id` (태스크 ID), `@pOutput_comment` (산출물 댓글), `@pModifier_id` (수정자 ID)
   - 출력 파라미터: `@result_cd` (결과 코드), `@result_msg` (결과 메시지)

2. **트랜잭션 및 잠금 설정**
   - 트랜잭션 격리 수준을 `READ UNCOMMITTED`로 설정.
   - `NOCOUNT`를 `ON`으로 설정하여 성능 향상.

3. **태스크 존재 여부 확인**
   - 태스크 테이블에서 해당 `@pTask_id`를 가진 태스크가 존재하는지 확인.
   - 존재하지 않을 경우 오류를 발생시킴.

4. **산출물 정보 수정**
   - `task_output` 테이블에서 해당 태스크 ID에 대한 산출물 댓글(`output_comment`)과 수정자 ID(`Modifier_id`)를 수정.
   - 수정 시간(`modified_at`)을 현재 시간으로 설정.

5. **오류 처리**
   - 오류가 발생할 경우 트랜잭션을 롤백하고, 오류 정보를 `@result_cd`와 `@result_msg`에 반환.

6. **로깅**
   - 프로시저 호출 정보와 결과를 로그 테이블(`use_log`)에 기록.
   - 로그 정보에는 태스크 ID, 산출물 댓글, 수정자 ID, 결과 코드, 결과 메시지 등을 포함.

### 예시 호출 코드:
```sql
DECLARE @result_cd INT, @result_msg VARCHAR(100);

EXEC [dbo].[spUpdateOutputForTask]
    @pTask_id = 15,
    @pFile_path = '/nas/wellfood/marketing/20250528_신제품 디자인 초안2.pptx',
    @pOutput_comment = '디자인 초안 확인용',
    @pModifier_id = 1,
    @result_cd = @result_cd OUTPUT,
    @result_msg = @result_msg OUTPUT;

SELECT @result_cd as result_cd, @result_msg as result_msg;
```

### 주요 기능 요약:
- 태스크에 대한 산출물 정보(댓글 및 수정자)를 수정하고 결과를 반환.
- 오류 발생 시 롤백 및 오류 정보 반환.
- 프로시저 호출 정보와 결과를 로깅.

이 프로시저는 태스크에 대한 산출물 정보를 안전하게 수정하는 기능을 제공합니다.

--- spGetDashBoardDataForMember ---
아래는 요청하신 SQL 프로시저 코드의 주요 로직을 정리한 내용입니다.

### 프로시저명: spGetDashBoardDataForMember

#### 주요 로직:
1. **입력 파라미터 및 출력 변수 선언**
   - 출력 파라미터: `@result_cd` (INT), `@result_msg` (VARCHAR(200))

2. **트랜잭션 및 격리 수준 설정**
   - 트랜잭션 격리 수준을 `READ UNCOMMITTED`로 설정하여 성능 최적화
   - `NOCOUNT`를 `ON`으로 설정하여 결과 행 수 반환을 억제

3. **회원별 대시보드 데이터 조회**
   - `hr_master` 테이블에서 회원 정보 조회
   - `project` 및 `task` 테이블과 조인하여 프로젝트별 상태를 집계
   - `task_owner` 테이블을 통해 회원별 프로젝트 참여 정보 확인
   - 집계 항목:
     - 진행 중인 프로젝트 수(`progress_cnt`) 및 ID(`progress_project_ids`)
     - 지연된 프로젝트 수(`delayed_cnt`) 및 ID(`delayed_project_ids`)
     - 완료된 프로젝트 수(`done_cnt`) 및 ID(`done_project_ids`)

4. **부서 정보 조회**
   - 회원 부서(`member_dept_cd`), 팀(`member_team_cd`), 분사(`member_division_cd`) 정보를 조회
   - `dept_master` 테이블과 조인을 통해 부서명, 팀명, 분사명을 확인

5. **오류 처리**
   - `BEGIN TRY` 및 `BEGIN CATCH` 블록을 사용한 오류 처리
   - 오류 발생 시 `@result_cd`를 `-1`로, `@result_msg`를 오류 메시지로 설정

6. **결과 반환**
   - 정상 완료 시 `@result_cd`를 `0`으로, `@result_msg`를 '성공'으로 설정
   - 최종 결과를 출력 파라미터를 통해 반환

#### 주요 기능 요약:
- 회원별로 진행 중인 프로젝트, 지연된 프로젝트, 완료된 프로젝트 수 및 ID를 집계하여 반환
- 회원의 부서, 팀, 분사 정보를 조회하여 반환
- 모든 데이터는 읽기 전용 트랜잭션으로 조회되며, 성능을 위해 `NOLOCK` 힌트 사용
- 오류가 발생하면 `@result_cd`에 `-1`을, `@result_msg`에 오류 메시지를 반환

이 프로시저는 회원별 대시보드에 필요한 데이터를 제공하는 역할을 수행합니다.

--- spInsertDeptAuth ---
아래는 요청하신 SQL 프로시저 코드의 주요 로직을 정리한 내용입니다:

### 프로시저명: [dbo].[spInsertDeptAuth]

**목적:** 부서별 권한 등록을 수행하는 프로시저입니다.

**주요 로직:**

1. **입력 파라미터 확인:**
   - `@pDept_cd` (부서 코드), `@pAuth_cd` (권한 코드), `@pCreator_id` (생성자 ID)가 입력 파라미터로 받습니다.
   - 권한 코드(`@pAuth_cd`)는 MST('90000', 사용자권한)에 정의된 값이어야 하며, 예를 들어 '10'은 관리자, '20'은 마케터 등을 나타냅니다.

2. **결과 출력 파라미터:**
   - `@result_cd` (결과 코드)와 `@result_msg` (결과 메시지)가 출력 파라미터로 설정되어 있습니다. 이 값을 통해 성공 또는 실패 결과를 반환합니다.

3. **권한 코드 유효성 검사:**
   - `code_master` 테이블에서 권한 코드가 유효한지 확인합니다. 권한 코드가 정의되지 않으면 오류 메시지를 반환합니다.

4. **부서 코드 유효성 검사:**
   - `dept_master` 테이블에서 부서 코드가 유효한지 확인합니다. 부서 코드가 존재하지 않으면 오류 메시지를 반환합니다.

5. **권한 등록 로직:**
   - `dept_auth` 테이블에 권한을 등록합니다.
   - 해당 부서 코드에 대한 권한이 이미 존재하면 업데이트하고, 존재하지 않으면 새로 삽입합니다.
   - 삽입 또는 업데이트 작업은 트랜잭션을 통해 수행되며, 성공 시 결과 메시지를 설정하고 반환합니다.

6. **오류 처리:**
   - 트랜잭션 중 오류가 발생하면 롤백을 수행하고, 오류 메시지를 반환합니다.

### 예시 실행 코드:
아래는 프로시저를 실행하는 예시 코드입니다:

```sql
DECLARE @result_cd INT, @result_msg VARCHAR(100);

EXEC [dbo].[spInsertDeptAuth]
    @pDept_cd = '13010101',
    @pAuth_cd = '10',
    @result_cd = @result_cd OUTPUT,
    @result_msg = @result_msg OUTPUT;

SELECT @result_cd as result_cd, @result_msg as result_msg;
```

### 요약:
이 프로시저는 부서 코드에 대한 권한을 등록하거나 업데이트하며, 입력된 권한 코드가 유효한지, 부서 코드가 존재하는지 검사하여 오류 메시지를 반환합니다. 성공적으로 권한이 등록되면 결과 메시지를 반환합니다.

--- spGetMappingCodeLineToBrand ---
아래는 요청하신 SQL 프로시저 코드의 주요 로직을 정리한 내용입니다.

### 프로시저명: spGetMappingCodeLineToBrand

**목적:** 라인 코드에 맵핑된 브랜드 정보를 가져온다.

**주요 로직:**

1. **입력 파라미터**
   - `@pLine_cd` (VARCHAR(8)): 라인 코드 (필수 아님)
   - `@pBrand_name` (NVARCHAR(240)): 브랜드 이름 (필수 아님)
   - `@pBrand_cd` (NVARCHAR(16)): 브랜드 코드 (필수 아님)
   - `@result_cd` (INT): 결과 코드 (출력)
   - `@result_msg` (VARCHAR(200)): 결과 메시지 (출력)

2. **주요 처리 로직**
   - **유효성 검사**:
     - 입력된 `@pLine_cd`가 존재하는지 `code_master` 테이블에서 확인.
     - 존재하지 않으면 오류 반환.

   - **데이터 조회**:
     - `mapper_line_brand`와 `IF_SAP_NPD_BRAND` 테이블을 조인하여 데이터를 조회.
     - `code_master` 테이블과도 왼쪽 조인을 수행.
     - 조건:
       - `group_cd`가 `'20001'` 또는 `'20002'`인 경우만 선택.
       - 입력된 `@pLine_cd`, `@pBrand_name`, `@pBrand_cd`에 따라 필터링.

3. **오류 처리**
   - `TRY-CATCH` 블록을 사용하여 오류를 처리.
   - 오류 발생 시 `@result_cd`는 `-1`로, `@result_msg`는 오류 메시지로 설정됨.

4. **결과 반환**
   - 성공 시 `@result_cd`는 `0`, `@result_msg`는 `'성공'`으로 설정됨.
   - 조회된 데이터는 결과 집합으로 반환됨.

**실행 예시:**
```sql
DECLARE @result_cd INT, @result_msg VARCHAR(100);

EXEC [dbo].[spGetMappingCodeLineToBrand]
    @pLine_cd = NULL,
    @pBrand_name = '거북알',
    @pBrand_cd = NULL,
    @result_cd = @result_cd OUTPUT,
    @result_msg = @result_msg OUTPUT;

SELECT @result_cd as result_cd, @result_msg as result_msg;
```

**주요 기능:**
- 입력된 라인 코드와 브랜드 정보에 따라 매핑된 데이터를 조회하고 결과를 반환.
- 입력값이 유효하지 않을 경우 오류를 반환.

--- spInsertMappingCodeLineToBrand ---
아래는 요청하신 SQL 프로시저 코드의 주요 로직을 정리한 내용입니다:

### 프로시저명: spInsertMappingCodeLineToBrand

**목적:** 라인(LINE) 코드와 브랜드(BRAND) 코드 간의 매핑 관계를 인서트한다.

**주요 로직:**

1. **입력 파라미터**
   - `@pLine_cd` (VARCHAR(8)): 라인 코드
   - `@pBrand_cds` (NVARCHAR(MAX)): 인서트할 브랜드 코드 목록 (CSV 형식)

2. **출력 파라미터**
   - `@result_cd` (INT): 결과 코드 (0: 성공, -1: 실패)
   - `@result_msg` (VARCHAR(200)): 결과 메시지

3. **주요 처리 로직**
   - **CSV 파싱**: `@pBrand_cds`의 CSV 문자열을 개별 브랜드 코드로 분리하여 테이블 `@vBrand_cd_list`에 삽입
   - **매핑 인서트**: `dbo.mapper_line_brand` 테이블에 `@pLine_cd`와 `@vBrand_cd_list`의 브랜드 코드를 조합하여 인서트
     - `LEFT JOIN`을 사용하여 이미 존재하는 브랜드 코드는 제외
   - **트랜잭션 관리**: 성공 시 커밋, 실패 시 롤백 수행

4. **에러 처리**
   - 실패 시 `@result_cd`는 -1, `@result_msg`는 에러 메시지를 반환
   - 에러 발생 시 트랜잭션 롤백 수행

**예시 실행 코드:**
```sql
DECLARE @result_cd INT, @result_msg VARCHAR(100);

EXEC [dbo].[spInsertMappingCodeLineToBrand]
    @pLine_cd = 1102,
    @pBrand_cds = '10000001,10000002',
    @result_cd = @result_cd OUTPUT,
    @result_msg = @result_msg OUTPUT;

SELECT @result_cd as result_cd, @result_msg as result_msg;
```

**결과:**
- 성공 시: `@result_cd = 0`, `@result_msg = '성공'`
- 실패 시: `@result_cd = -1`, `@result_msg = 에러 메시지`

--- spDeleteMappingCodeLineToBrand ---
아래는 요청하신 SQL 프로시저 코드의 주요 로직을 정리한 내용입니다.

### 프로시저명: [dbo].[spDeleteMappingCodeLineToBrand]

#### 주요 기능: 맵핑된 라인(line_cd)과 브랜드 코드(brand_cd)를 삭제하는 프로시저.

---

### 주요 로직 요약:

1. **입력 파라미터**
   - `@pLine_cd` (VARCHAR(8)): 삭제할 라인 코드
   - `@pBrand_cd` (NVARCHAR(16)): 삭제할 브랜드 코드
   - `@result_cd` (INT): 프로시저 실행 결과 코드 (출력 파라미터)
   - `@result_msg` (VARCHAR(200)): 프로시저 실행 결과 메시지 (출력 파라미터)

2. **SQL DELETE 문**
   - `dbo.mapper_line_brand` 테이블에서 해당 라인 코드와 브랜드 코드를 삭제.
   - `NOLOCK` 힌트를 사용하여 삭제 성능을 향상시키고, 트랜잭션 충돌을 최소화.

3. **트랜잭션 관리**
   - `BEGIN TRY` 블록: 삭제 작업이 성공적으로 완료되면 `@result_cd`를 0으로, `@result_msg`를 '성공'으로 설정.
   - `BEGIN CATCH` 블록: 오류가 발생하면 트랜잭션을 롤백하고, `@result_cd`를 -1로, `@result_msg`를 오류 메시지로 설정.

4. **오류 처리**
   - 오류 발생 시 `@result_cd`, `@result_msg`, `@vSeverity`를 설정하여 상세한 오류 정보를 반환.

---

### 예시 실행 코드:
```sql
DECLARE @result_cd INT,
        @result_msg VARCHAR(100);

EXEC [dbo].[spDeleteMappingCodeLineToBrand]
    @pLine_cd = 1102,
    @pBrand_cd = '10000001',
    @result_cd = @result_cd OUTPUT,
    @result_msg = @result_msg OUTPUT;

SELECT @result_cd as result_cd,
       @result_msg as result_msg;
```

- **@result_cd**: 프로시저 실행 결과 코드 (0: 성공, -1: 실패)
- **@result_msg**: 프로시저 실행 결과 메시지 ('성공' 또는 오류 메시지)

---

### 주요 특징:
- **트랜잭션 안전성**: `BEGIN TRY`와 `BEGIN CATCH`를 사용하여 데이터 무결성을 보장.
- **성능 향상**: `NOLOCK` 힌트를 사용하여 삭제 작업의 성능을 최적화.
- **상세한 오류 정보**: 오류 발생 시 `@result_cd`, `@result_msg`, `@vSeverity`를 통해 오류를 쉽게 파악할 수 있도록 설계.

이 프로시저는 특정 라인 코드와 브랜드 코드의 매핑을 안전하게 삭제하는 기능을 제공합니다.

--- sp_upgraddiagrams ---
이 SQL Server 프로시저의 주요 로직을 다음과 같이 요약할 수 있습니다:

### 프로시저의 주요 목적
1. **sysdiagrams 테이블 생성 및 업데이트**
   - 데이터베이스 내의 다이어그램(디agram) 정보를 관리하는 테이블인 `sysdiagrams`를 생성하거나 업데이트하는 프로시저입니다.
   - `sysdiagrams` 테이블은 다이어그램 이름, 소유자 ID, 다이어그램 ID, 버전, 그리고 다이어그램 정의(정의)를 포함합니다.

### 주요 로직 흐름
1. **sysdiagrams 테이블 존재 여부 확인**
   - 프로시저 시작 시, `sysdiagrams` 테이블이 이미 데이터베이스에 존재하는지 확인합니다.
   - 테이블이 존재하면 프로시저를 종료합니다.

2. **sysdiagrams 테이블 생성**
   - `sysdiagrams` 테이블이 존재하지 않으면 새로 생성합니다.
   - 테이블 생성 시, `name`, `principal_id`, `diagram_id`, `version`, `definition` 컬럼을 포함하며, `diagram_id`를 기본키로 설정합니다.
   - `UK_principal_name`이라는 고유 키 제약 조건을 `principal_id`와 `name`에 설정합니다.

3. **sysdiagram_properties 테이블 생성 여부 확인**
   - `sysdiagram_properties` 테이블은 다이어그램의 확장 속성을 저장하는 테이블입니다.
   - 이 부분은 주석 처리되어 있으며, 필요 시 테이블을 생성할 수 있습니다.

4. **dtproperties 테이블에서 다이어그램 정보 읽기**
   - `dtproperties` 테이블에서 다이어그램 관련 정보를 읽어 `sysdiagrams` 테이블에 데이터를 삽입합니다.
   - `dtproperties` 테이블은 다이어그램 이름, GUID, 버전, 그리고 다이어그램 정의를 포함하고 있습니다.
   - 이 데이터를 `sysdiagrams` 테이블에 삽입하며, `principal_id`는 `dbo`의 데이터베이스 프린시팔 ID로 설정하고, `version`은 0으로 초기화합니다.

5. **반환 값 설정**
   - 프로시저는 여러 조건에 따라 0, 1, 또는 2라는 값을 반환합니다.
   - 0은 `sysdiagrams` 테이블이 이미 존재하는 경우 반환됩니다.
   - 1은 `sysdiagrams` 테이블이 새로 생성된 경우 반환됩니다.
   - 2는 `dtproperties` 테이블에서 다이어그램 정보를 성공적으로 읽고 삽입한 경우 반환됩니다.

### 주요 목적 요약
- 이 프로시저는 `sysdiagrams` 테이블을 생성하고, `dtproperties` 테이블에서 다이어그램 정보를 읽어 `sysdiagrams` 테이블에 데이터를 삽입하는 과정을 수행합니다.
- 또한, `sysdiagram_properties` 테이블을 필요 시 생성할 수 있는 로직을 포함하고 있습니다.

--- spGetDashBoardDataForAll ---
아래는 요청하신 SQL 프로시저 코드의 주요 로직을 정리한 내용입니다.

### 프로시저명: [dbo].[spGetDashBoardDataForAll]

#### 주요 로직:

1. **입력 파라미터 및 출력 변수 선언**
   - 입력 파라미터: `@pWork_type_cd` (작업 유형 코드, 기본값 NULL)
   - 출력 변수: `@result_cd` (결과 코드), `@result_msg` (결과 메시지)

2. **템플릿 테이블 (@vTemplate) 생성**
   - `line_type_cd`, `line_type_name`, `line_cd`, `line_name` 컬럼을 가진 테이블
   - `code_master` 테이블에서 `group_cd = '20101'`인 데이터를 조회하여 초기화

3. **결과 테이블 (@vResult) 생성**
   - `line_cd`, `progress_cnt`, `progress_project_ids`, `delayed_cnt`, `delayed_project_ids`, `done_cnt`, `done_project_ids` 컬럼을 가진 테이블
   - `project` 테이블과 `task_finish_plan` 테이블을 조회하여 각 상태별(진행, 지연, 완료) 프로젝트 개수와 ID를 집계

4. **주요 데이터 처리**
   - `project` 테이블에서 `project_type_cd = '10'`인 프로젝트만 선택
   - `work_type_cd`가 입력 파라미터와 일치하는 경우만 선택
   - `state_cd`에 따라 진행, 지연, 완료 상태를 판단
   - `STRING_AGG`를 사용하여 각 상태별 프로젝트 ID를 쉼표로 구분된 문자열로 집계

5. **결과 처리**
   - `vTemplate`와 `vResult`를 `LEFT JOIN`하여 모든 라인에 대해 결과가 포함되도록 함
   - `progress_total` (진행 및 지연 총합), `total` (전체 프로젝트 수)을 계산
   - 오류 발생 시 `@result_cd`와 `@result_msg`를 설정

#### 주요 기능:
- 전체 조회 대시보드 데이터를 제공
- 프로젝트 상태별(진행, 지연, 완료) 개수 및 프로젝트 ID 집계
- 특정 작업 유형에 대한 필터링 가능
- 결과 코드와 메시지를 출력 변수로 반환

#### 사용 예시:
```sql
DECLARE @result_cd INT, @result_msg VARCHAR(100);

EXEC [dbo].[spGetDashBoardDataForAll]
    @pWork_type_cd = NULL,
    @result_cd = @result_cd OUTPUT,
    @result_msg = @result_msg OUTPUT;

SELECT @result_cd as result_cd, @result_msg as result_msg;
```

#### 주의사항:
- `NOLOCK` 힌트를 사용하여 성능 향상
- `READ UNCOMMITTED` 트랜잭션 격리 수준 사용
- 오류 처리 및 예외 처리 포함
- `STRING_AGG`는 SQL Server 2017 이상에서 사용 가능

--- sp_helpdiagrams ---
아래는 요청하신 SQL 프로시저 코드의 주요 로직을 정리한 것입니다.

### 프로시저명: `dbo.sp_helpdiagrams`

#### 주요 목적:
`sysdiagrams` 테이블에서 데이터베이스 다이어그램 정보를 조회하고, 현재 사용자가 소유한 다이어그램 또는 특정 다이어그램 이름을 기준으로 다이어그램 정보를 반환하는 프로시저입니다.

---

### 주요 로직 정리:

1. **현재 사용자 및 권한 확인**
   - `EXECUTE AS CALLER`를 사용하여 호출자의 권한으로 실행됩니다.
   - 현재 사용자(`@user`)와 `db_owner` 권한 여부(`@dboLogin`)를 확인합니다.

2. **매개변수 검사**
   - 입력 매개변수 `@diagramname`과 `@owner_id`를 기반으로 `sysdiagrams` 테이블에서 조건적으로 다이어그램 정보를 조회합니다.
   - `@diagramname`은 다이어그램 이름을 필터링하며, `@owner_id`는 다이어그램 소유자의 `principal_id`를 필터링합니다.

3. **다이어그램 정보 조회**
   - `sysdiagrams` 테이블에서 다음 정보를 선택합니다:
     - `Database`: 다이어그램이 속한 데이터베이스 이름
     - `Name`: 다이어그램 이름
     - `ID`: 다이어그램 ID
     - `Owner`: 다이어그램 소유자 이름
     - `OwnerID`: 다이어그램 소유자의 `principal_id`

4. **결과 정렬**
   - 결과를 `Owner`, `OwnerID`, `Database` 순으로 정렬합니다.

---

### 예시
#### 호출 방법:
```sql
-- 특정 다이어그램 이름과 소유자 ID로 조회
EXEC dbo.sp_helpdiagrams @diagramname = 'Diagram1', @owner_id = 123;

-- 모든 다이어그램 조회
EXEC dbo.sp_helpdiagrams;
```

#### 결과 예시:
| Database | Name    | ID  | Owner   | OwnerID |
|----------|---------|----|---------|--------|
| MyDB     | Diagram1 | 1    | User1   | 123     |
| MyDB     | Diagram2 | 2    | User2   | 124     |

---

### 주요 기능 요약:
- 다이어그램 정보 조회 및 필터링 기능
- 권한에 따른 다이어그램 정보 반환
- 다이어그램 소유자 및 이름 기반 검색 기능

--- spGetDashBoardDataForMonthly ---
아래는 요청하신 SQL 프로시저 코드의 주요 로직을 정리한 내용입니다.

### 프로시저의 주요 로직 요약

1. **입력 파라미터 및 출력 변수 선언**
   - 입력 파라미터: `@pWork_type_cd` (작업 유형 코드, 기본값 NULL)
   - 출력 파라미터: `@start_month` (시작 월), `@result_cd` (결과 코드), `@result_msg` (결과 메시지)

2. **데이터베이스 작업**
   - 트랜잭션 격리 수준을 `READ UNCOMMITTED`로 설정.
   - 임시 테이블 `@vResult_org`와 `@vTemplate` 선언.

3. **라인 템플릿 구성**
   - `code_master` 테이블에서 라인 유형 및 코드 정보를 조회하여 `@vTemplate` 테이블에 삽입.
   - 라인 유형 코드와 이름을, 그리고 하위 라인 코드와 이름을 추출.

4. **원본 프로젝트 데이터 수집**
   - `project` 테이블과 `task_finish_plan` 테이블을 조회하여 프로젝트 정보 추출.
   - `project_type_cd`가 '10'인 프로젝트만 선택.
   - `work_type_cd`가 입력된 값과 일치하는 경우만 선택.
   - 각 라인별로 계획 종료 월과 프로젝트 개수, 프로젝트 ID를 집계하여 `@vResult_org` 테이블에 삽입.

5. **기준 월별 데이터 조합**
   - `@vTemplate`와 월 리스트를 결합하여 월별 데이터를 표현.
   - `@vResult_org` 테이블과 결합하여 각 월별 프로젝트 개수와 ID를 추출.
   - 결과 데이터를 `@base` 테이블에 삽입.

6. **결과 출력**
   - `@base` 테이블에서 월별 데이터를 그룹화하여 최종 결과 출력.
   - 각 라인 유형과 코드별로 월별 프로젝트 개수와 ID를 집계.
   - 결과 코드(`@result_cd`)와 메시지(`@result_msg`)를 설정.

### 주요 기능 설명
- **월별 조회 대시보드**: 특정 작업 유형에 대한 월별 프로젝트 현황을 조회.
- **프로젝트 집계**: 각 라인별로 월별 프로젝트 개수와 ID를 집계하여 표시.
- **유연한 월별 데이터**: 사용자가 원하는 월 범위를 쉽게 조정 가능.

### 예시 코드 실행
```sql
DECLARE @start_month VARCHAR(7), @result_cd INT, @result_msg VARCHAR(100);

EXEC [dbo].[spGetDashBoardDataForMonthly]
    @pWork_type_cd = NULL,
    @start_month = @start_month OUTPUT,
    @result_cd = @result_cd OUTPUT,
    @result_msg = @result_msg OUTPUT;

SELECT @start_month as start_month, @result_cd as result_cd, @result_msg as result_msg;
```

### 예시 결과
- **출력**: 시작 월(`@start_month`)과 결과 코드(`@result_cd`), 메시지(`@result_msg`)를 반환.
- **데이터**: 각 라인 유형과 코드별 월별 프로젝트 개수와 ID를 포함한 결과를 반환.

이 프로시저는 특정 작업 유형에 대한 월별 프로젝트 현황을 대시보드 형식으로 제공하는 기능을 수행합니다.

--- sp_helpdiagramdefinition ---
아래는 요청하신 SQL 프로시저 코드의 주요 로직을 정리한 것입니다.

### 프로시저명: `dbo.sp_helpdiagramdefinition`

#### 주요 목적:
- 데이터베이스 다이어그램의 정의(version과 definition)를 조회하고 반환하는 프로시저입니다.
- 다이어그램 이름이 제공되지 않으면 오류를 반환합니다.
- 다이어그램이 존재하지 않거나 권한이 없는 경우 오류를 반환합니다.

---

### 주요 로직 흐름:

1. **매개변수 검사**
   - `@diagramname`이 `NULL`인 경우 오류를 반환합니다.

2. **현재 사용자의 ID 및 권한 확인**
   - 현재 사용자의 `DATABASE_PRINCIPAL_ID()`를 `@theId`로 저장합니다.
   - 사용자가 `db_owner` 역할에 속한지 확인하여 `@IsDbo` 변수에 저장합니다.
   - `@owner_id`가 `NULL`이면 현재 사용자의 ID로 설정합니다.

3. **다이어그램 존재 여부 확인**
   - `dbo.sysdiagrams` 테이블에서 다이어그램 이름이 `@diagramname`과 일치하고, `principal_id`가 `@owner_id`인 행을 조회합니다.
   - 다이어그램이 존재하지 않거나 권한이 없는 경우 오류를 반환합니다.

4. **다이어그램 정보 반환**
   - `dbo.sysdiagrams` 테이블에서 다이어그램의 `version`과 `definition`을 조회하여 반환합니다.

---

### 주요 기능 요약:
- 다이어그램의 존재 여부 및 권한 검사
- 다이어그램의 `version`과 `definition` 조회 및 반환
- 오류 처리 및 적절한 오류 메시지 반환

이 프로시저는 데이터베이스 다이어그램에 대한 정보를 안전하게 조회할 수 있도록 설계되었습니다.

--- sp_creatediagram ---
아래는 요청하신 SQL 프로시저 코드의 주요 로직을 정리한 것입니다.

### 프로시저 `sp_creatediagram`의 주요 로직 요약

1. **입력 파라미터 검증**
   - `diagramname`(이름)과 `version`(버전)이 `NULL`인 경우 오류 반환 (`E_INVALIDARG`).
   - `owner_id`(소유자 ID)가 `NULL`이면 현재 사용자의 ID를 사용.

2. **소유자 권한 검증**
   - 현재 사용자 ID(`@theId`)와 지정된 소유자 ID(`@owner_id`)가 다르다면:
     - 사용자가 `db_owner` 역할에 속한 경우에만 소유자 ID를 강제로 설정.
     - 그렇지 않으면 오류 반환 (`E_INVALIDARG`).

3. **디아그램 이름 중복 확인**
   - `dbo.sysdiagrams` 테이블에서 동일한 이름과 소유자 ID를 가진 디아그램이 이미 존재하는지 확인.
   - 중복된 경우 오류 반환 ("The name is already used.").

4. **디아그램 정보 삽입**
   - `dbo.sysdiagrams` 테이블에 새 디아그램 정보를 삽입.
   - 삽입 후 자동 증가 ID 값을 반환.

### 주요 기능 설명
- **디아그램 생성**: 데이터베이스 다이어그램(ER 다이어그램 등)을 생성하는 프로시저입니다.
- **접근 제한**: 소유자 ID가 지정되지 않으면 현재 사용자의 ID를 소유자로 설정.
- **보안 검사**: 소유자 변경 시 `db_owner` 권한을 확인하여 무단 변경 방지.
- **중복 방지**: 동일한 이름의 다이어그램이 여러 번 생성되는 것을 막음.

### 반환 값
- 성공 시 삽입된 행의 자동 증가 ID 반환.
- 실패 시 -1 또는 -2 반환.

이 프로시저는 데이터베이스 다이어그램 관리에 필요한 보안 및 데이터 무결성을 보장하는 로직을 포함하고 있습니다.

--- sp_renamediagram ---
아래는 요청하신 SQL 프로시저 코드의 주요 로직을 정리한 것입니다.

### 프로시저 `sp_renamediagram`의 주요 로직 요약

1. **입력 파라미터 검증**
   - `diagramname`과 `new_diagramname`이 모두 제공되었는지 확인.
   - 만약 누락된 값이 있으면 오류 반환 (`RAISERROR`) 및 프로시저 종료.

2. **현재 사용자 및 권한 확인**
   - 현재 데이터베이스 사용자의 `ID`(`@theId`)와 `dbo` 권한 여부(`@IsDbo`) 확인.
   - `owner_id`가 제공되지 않으면 현재 사용자의 `ID`를 기본값으로 사용.

3. **기존 다이어그램 존재 여부 확인**
   - `sysdiagrams` 테이블에서 `owner_id`와 `diagramname`을 기반으로 다이어그램 존재 여부 확인.
   - 다이어그램이 존재하지 않거나 권한이 없는 경우 오류 반환.

4. **새 다이어그램 이름 충돌 확인**
   - `new_diagramname`이 이미 사용 중인지 확인.
   - `sysdiagrams` 테이블에서 `owner_id`와 `new_diagramname`을 기반으로 검색.
   - 충돌이 발생하면 오류 반환.

5. **다이어그램 이름 변경**
   - `sysdiagrams` 테이블에서 `diagram_id`에 해당하는 행의 `name` 컬럼을 `new_diagramname`으로 업데이트.
   - `owner_id`가 현재 사용자(`@theId`)인 경우 `principal_id`도 `@theId`로 업데이트.

6. **오류 처리**
   - 다양한 오류 조건을 검사하여 적절한 오류 메시지를 반환.
   - 오류 시 프로시저 종료.

### 예시 시나리오
1. **유효한 입력으로 다이어그램 이름 변경**
   - `diagramname`과 `new_diagramname`이 모두 제공되고, `owner_id`가 현재 사용자의 `ID`인 경우.
   - `sysdiagrams` 테이블에서 `diagram_id`에 해당하는 행의 `name`을 `new_diagramname`으로 업데이트.
   - `owner_id`가 현재 사용자(`@theId`)인 경우 `principal_id`도 `@theId`로 업데이트.

2. **다이어그램 이름 변경 시 오류 발생**
   - `new_diagramname`이 이미 사용 중인 경우.
   - `owner_id`가 현재 사용자의 `ID`가 아닌 경우.
   - `sysdiagrams` 테이블에서 `diagram_id`에 해당하는 행이 없는 경우.

이와 같은 로직을 통해 다이어그램 이름을 안전하게 변경할 수 있습니다.

--- sp_alterdiagram ---
아래는 요청하신 SQL 프로시저 코드의 주요 로직을 정리한 것입니다.

### 프로시저 `sp_alterdiagram`의 주요 로직 요약

1. **입력 파라미터 확인**
   - `@diagramname`, `@owner_id`, `@version`, `@definition`을 받아서 유효성을 검사합니다.
   - `@diagramname`이 `NULL`인 경우 오류를 반환합니다.

2. **현재 사용자의 권한 확인**
   - 현재 사용자의 `DATABASE_PRINCIPAL_ID`(@theId)와 `IS_MEMBER(N'db_owner')`(@IsDbo)를 확인합니다.
   - `@owner_id`가 `NULL`이면 현재 사용자의 ID로 설정합니다.

3. **다이어그램 존재 여부 및 권한 검사**
   - `dbo.sysdiagrams` 테이블에서 `@owner_id`와 `@diagramname`을 조건으로 `diagram_id`(@DiagId)와 `principal_id`(@UIDFound)를 조회합니다.
   - `@DiagId`가 `NULL`이거나 `@IsDbo`가 `0`이고 `@theId`와 `@UIDFound`가 같지 않으면 오류를 반환합니다.

4. **다이어그램 정의 및 소유자 변경**
   - `@ShouldChangeUID`를 설정하여 소유자가 변경되어야 하는지 여부를 판단합니다.
   - `dbo.sysdiagrams` 테이블에서 `definition`, `principal_id`, `version`을 업데이트합니다.

5. **출력**
   - 모든 작업이 성공적으로 완료되면 `0`을 반환합니다.

### 주요 기능
- 다이어그램의 정의를 변경하고 소유자를 현재 사용자로 변경할 수 있습니다.
- 다이어그램의 버전을 업데이트할 수 있습니다.
- 권한 검사를 통해 다이어그램에 대한 적절한 접근 권한을 확인합니다.

이 프로시저는 다이어그램의 정의를 변경하거나 소유자를 변경하는 작업을 수행하며, 관련된 권한을 관리하는 역할을 합니다.

--- spDeleteTemplateProject ---
아래는 요청하신 SQL 프로시저 코드의 주요 로직을 정리한 것입니다:

### 프로시저명: [dbo].[spDeleteTemplateProject]

#### 주요 목적: 템플릿 프로젝트 삭제

1. **입력 파라미터**
   - `@pProject_id` (INT, NULL 가능): 프로젝트 ID
   - `@pModifier_id` (VARCHAR(7), NULL 가능): 수정자 ID

2. **출력 파라미터**
   - `@result_cd` (INT): 결과 코드 (0=성공, -1=실패)
   - `@result_msg` (VARCHAR(200)): 결과 메시지

3. **주요 로직**
   - **TRANSACTION**으로 데이터 변경 관리
     - `READ UNCOMMITTED` 트랜잭션 격리 수준 사용
   - **UPDATE** 테이블 `dbo.project`
     - `project_id`와 `project_type_cd` 조건에 맞는 레코드의 `is_active` 값을 '90'(비활성)으로 설정
     - 수정자 정보 `@pModifier_id`와 수정 시간 `GETDATE()` 업데이트
   - **ERROR HANDLING**
     - 실패 시 트랜잭션 롤백
     - 오류 메시지 및 심각도 저장
   - **로그 기록** (`dbo.use_log` 테이블)
     - 호출자 ID, 심각도, 프로젝트 ID, 로그 메시지, 프로시저 이름, 파라미터, 결과 코드 및 메시지 기록

4. **결과 반환**
   - 성공 시: `@result_cd = 0`, `@result_msg = '성공'`
   - 실패 시: `@result_cd = -1`, `@result_msg = 오류 메시지`

이 프로시저는 특정 프로젝트 ID를 비활성화(삭제)하고, 관련 로그를 기록하는 기능을 수행합니다.

--- sp_dropdiagram ---
아래는 요청하신 SQL 프로시저 코드의 주요 로직을 정리한 것입니다.

### 프로시저명: `dbo.sp_dropdiagram`

#### 주요 기능: 데이터베이스 다이어그램 삭제

1. **매개변수**
   - `@diagramname`: 삭제할 다이어그램의 이름
   - `@owner_id`: 다이어그램 소유자의 ID (기본값: `null`)

2. **주요 로직**

   - **권한 검사**:
     - 사용자가 `db_owner` 역할에 속한 경우에만 다이어그램을 삭제할 수 있음
     - 소유자 ID가 제공되지 않으면 현재 사용자의 ID를 사용
     - 다이어그램이 존재하지 않거나 권한이 없는 경우 오류 반환

   - **다이어그램 삭제**:
     - `dbo.sysdiagrams` 테이블에서 해당 다이어그램 삭제

3. **반환값**
   - 성공 시: `0`
   - 오류 시: `-1` 또는 `-3`

#### 예시 실행:
```sql
-- 다이어그램 삭제 예시
EXEC dbo.sp_dropdiagram @diagramname = 'MyDiagram', @owner_id = 1;
```

--- spGetProjectMember ---
아래는 요청하신 SQL 프로시저 코드의 주요 로직을 정리한 것입니다.

### 프로시저명: [dbo].[spGetProjectMember]

#### 주요 기능: 프로젝트 멤버를 조회하여 결과를 출력

#### 입력 파라미터:
- `@pProject_id` (INT, NULL 가능): 프로젝트 ID

#### 출력 파라미터:
- `@result_cd` (INT): 결과 코드
- `@result_msg` (VARCHAR(200)): 결과 메시지

#### 주요 로직:
1. **트랜잭션 설정**:
   - 트랜잭션 격리 수준을 `READ UNCOMMITTED`로 설정하여 성능을 최적화하고, 데이터 일관성을 보장합니다.

2. **프로젝트 멤버 조회**:
   - `project_member` 테이블에서 `project_id`가 입력된 값과 일치하고, `status_cd`가 '10'인 레코드를 조회합니다.
   - `hr_master` 테이블과 `dept_master` 테이블을 각각 왼쪽 JOIN하여 회원 정보와 부서 정보를 포함시킵니다.
   - `ISNULL`을 사용하여 회원이 존재하지 않을 경우 '미존재 회원'으로 표시합니다.

3. **결과 처리**:
   - 조회된 데이터를 출력하며, `@result_cd`를 0(성공)으로 설정하고 `@result_msg`를 '성공'으로 설정합니다.

#### 예시 실행 코드:
```sql
DECLARE @result_cd INT, @result_msg VARCHAR(100);

EXEC [dbo].[spGetProjectMember]
    @pProject_id = 25080009,
    @result_cd = @result_cd OUTPUT,
    @result_msg = @result_msg OUTPUT;

SELECT @result_cd as result_cd, @result_msg as result_msg;
```

#### 주요 특징:
- **성능 최적화**: `NOLOCK` 힌트를 사용하여 테이블 잠금을 최소화하고, `READ UNCOMMITTED` 격리 수준으로 성능을 향상시킵니다.
- **데이터 일관성**: `project_id`와 `status_cd` 조건을 통해 정확한 데이터를 조회합니다.
- **유연한 출력**: 결과 코드와 메시지를 출력 파라미터로 반환하여 호출자에게 자세한 정보를 전달합니다.

--- spGetMemberInfo ---
아래는 요청하신 SQL 프로시저 코드의 주요 로직을 정리한 내용입니다.

### 프로시저명: [dbo].[spGetMemberInfo]

**목적:** 이름 또는 회원 아이디를 기반으로 회원 정보를 조회한다.

**주요 로직:**

1. **입력 파라미터 확인**
   - `@pMember_id` (회원 아이디): `VARCHAR(7)` 타입, 기본값 `NULL`
   - `@pMember_name` (회원 이름): `VARCHAR(20)` 타입, 기본값 `NULL`

2. **출력 파라미터 정의**
   - `@result_cd` (결과 코드): `INT` 타입, 출력 값
   - `@result_msg` (결과 메시지): `VARCHAR(200)` 타입, 출력 값

3. **트랜잭션 및 격리 수준 설정**
   - `TRANSACTION ISOLATION LEVEL READ UNCOMMITTED`로 설정하여 읽기 트랜잭션 동안 다른 트랜잭션이 데이터에 영향을 주지 않도록 함.

4. **회원 정보 조회**
   - `hr_master` 테이블에서 `EMP_ID`, `NAME`, `MOIN_ID`, `MOIN_EMAIL`, `DEPT_CODE`, `DEPT_NAME`, `JOB_CODE`, `JOB_GRADE_NM`, `JOB_DUTY`, `JOB_DUTY_NM` 컬럼을 선택.
   - `dept_master` 테이블과 `hr_master` 테이블을 `DEPT_CODE` 기준으로 LEFT JOIN.
   - 조회 조건:
     - `@pMember_id`가 제공되면 `HRM.EMP_ID = @pMember_id`로 필터링.
     - `@pMember_name`이 제공되면 `HRM.NAME LIKE '%' + @pMember_name + '%'`로 필터링.

5. **오류 처리**
   - `BEGIN TRY` 블록에서 오류 발생 시 `RAISERROR`로 오류 메시지를 반환.
   - `BEGIN CATCH` 블록에서 오류 세버리티와 메시지를 `@vSeverity`와 `@result_msg`에 저장.

6. **결과 반환**
   - 성공 시 `@result_cd = 0`, `@result_msg = '성공'`으로 설정.
   - 실패 시 `@result_cd = -1`, `@result_msg`에 오류 메시지를 설정.

### 예시 사용법:

- **이름으로 조회**
  ```sql
  DECLARE @result_project_id INT,
      @result_cd INT,
      @result_msg VARCHAR(100);

  EXEC [dbo].[spGetMemberInfo]
      @pMember_id = NULL,
      @pMember_name = '최민주',
      @result_cd = @result_cd OUTPUT,
      @result_msg = @result_msg OUTPUT;

  SELECT @result_cd as result_cd,
      @result_msg as result_msg;
  ```

- **아이디로 조회**
  ```sql
  DECLARE @result_project_id INT,
      @result_cd INT,
      @result_msg VARCHAR(100);

  EXEC [dbo].[spGetMemberInfo]
      @pMember_id = '2400016',
      @pMember_name = NULL,
      @result_cd = @result_cd OUTPUT,
      @result_msg = @result_msg OUTPUT;

  SELECT @result_cd as result_cd,
      @result_msg as result_msg;
  ```

### 주요 특징:
- **유연한 조회 조건**: 회원 아이디 또는 회원 이름 중 하나만 제공하면 조회가 가능.
- **명확한 오류 처리**: 오류 발생 시 세부 메시지를 반환하여 문제를 쉽게 파악.
- **트랜잭션 격리**: 데이터 일관성을 보장하기 위해 적절한 격리 수준 설정.

이 프로시저는 회원 정보를 안전하고 효율적으로 조회할 수 있도록 설계되었습니다.

--- spGetProjectHistory ---
아래는 요청하신 SQL 프로시저 코드의 주요 로직을 정리한 내용입니다:

### 프로시저명: spGetProjectHistory

#### 주요 기능:
1. **프로젝트 이력 조회**
   - 입력 파라미터: @pProject_id (프로젝트 ID), @pPage_no (페이지 번호), @pPage_size (페이지 크기)
   - 출력 파라미터: @total_count (전체 건수), @total_pages (전체 페이지 수), @result_cd (결과 코드), @result_msg (결과 메시지)

2. **데이터 처리**
   - 프로젝트 ID에 해당하는 프로젝트 이름을 조회
   - use_log 테이블에서 프로젝트 ID에 해당하는 로그 데이터를 조회하여 임시 테이블(@vResult)에 저장
   - 전체 건수(@total_count)와 페이지 수(@total_pages)를 계산

3. **결과 반환**
   - 프로젝트 ID, 프로젝트 이름, 로그 데이터(콜러 ID, 로그 일자, 로그 메시지, 생성 일자)를 페이지 단위로 반환
   - 페이징 처리: OFFSET과 FETCH NEXT를 사용하여 요청된 페이지의 데이터만 반환

4. **에러 처리**
   - 프로젝트 확인이 불가능한 경우 오류 반환
   - 전체 건수 계산 및 페이지 수 계산
   - 오류 발생 시 @result_cd를 -1로, @result_msg를 오류 메시지로 설정

#### 주요 특징:
- 트랜잭션 격리 수준을 READ UNCOMMITTED로 설정
- 임시 테이블(@vResult)을 사용하여 데이터 처리
- 페이징 처리 및 정렬(생성 일자 기준 DESC)
- 오류 처리 및 명확한 결과 메시지 반환

이 프로시저는 특정 프로젝트의 이력 로그를 페이지 단위로 조회하는 기능을 수행하며, 전체 건수와 페이지 수를 함께 반환합니다.

--- spGetCodeMaster ---
아래는 요청하신 SQL 프로시저 코드의 주요 로직을 정리한 내용입니다.

### 프로시저명: [dbo].[spGetCodeMaster]

**주요 기능: 코드마스터 데이터 검색**

1. **입력 파라미터**
   - `@pGroup_cd`: 그룹 코드 (8자)
   - `@pGroup_name`: 그룹 이름 (50자)
   - `@pDetail_cd`: 상세 코드 (8자)
   - `@pDetail_name`: 상세 이름 (50자)
   - `@pPage_no`: 페이지 번호
   - `@pPage_size`: 페이지 크기
   - `@result_cd`: 결과 코드 (출력)
   - `@result_msg`: 결과 메시지 (출력)
   - `@total_count`: 전체 레코드 수 (출력)
   - `@total_pages`: 전체 페이지 수 (출력)

2. **주요 로직**
   - **전체 레코드 수 계산**:
     - `code_master` 테이블에서 그룹 코드가 '90000' 미만인 레코드 수를 계산
     - 검색 조건에 따라 `group_cd`, `group_name`, `detail_cd`, `detail_name` 필터링 적용

   - **전체 페이지 수 계산**:
     - 전체 레코드 수를 페이지 크기로 나눈 값을 올림 처리

   - **데이터 검색**:
     - `code_master` 테이블에서 활성화된 레코드(`is_active_cd` = '10')만 선택
     - 검색 조건에 따라 `group_cd`, `group_name`, `detail_cd`, `detail_name` 필터링 적용
     - 결과는 `group_cd`, `detail_cd` 순으로 정렬
     - 페이징 처리(Offset-Fetch 방식)

3. **결과 처리**
   - 성공 시: `@result_cd` = 0, `@result_msg` = '성공'
   - 실패 시: `@result_cd` = -1, `@result_msg` = 오류 메시지
   - 전체 레코드 수와 페이지 수는 출력 파라미터로 반환

4. **트랜잭션 및 성능 설정**
   - 트랜잭션 격리 수준을 `READ UNCOMMITTED`로 설정
   - `NOCOUNT` 옵션을 사용해 성능 향상
   - `WITH (NOLOCK)`을 사용해 읽기 성능 향상

### 예시 실행 코드
```sql
DECLARE @result_cd INT, @result_msg VARCHAR(100), @total_count INT, @total_pages INT;

EXEC [dbo].[spGetCodeMaster]
    @pGroup_cd = '20100',
    @pGroup_name = NULL,
    @pDetail_cd = NULL,
    @pDetail_name = NULL,
    @pPage_no = 1,
    @pPage_size = 20,
    @result_cd = @result_cd OUTPUT,
    @result_msg = @result_msg OUTPUT,
    @total_count = @total_count OUTPUT,
    @total_pages = @total_pages OUTPUT;

SELECT
    @result_cd AS result_cd,
    @result_msg AS result_msg,
    @total_count AS total_count,
    @total_pages AS total_pages;
```

### 주요 특징
- **페이징 처리**: `Offset-Fetch` 방식을 사용해 대량 데이터에서 빠른 성능을 제공
- **활성화 필터링**: `is_active_cd` 필드를 통해 비활성화된 데이터는 표시하지 않음
- **유연한 검색 조건**: `group_cd`, `group_name`, `detail_cd`, `detail_name` 필터링 조건을 옵션으로 제공
- **오류 처리**: 오류 발생 시 `@result_cd`와 `@result_msg`를 통해 명확한 오류 정보를 반환

이 프로시저는 대량의 코드마스터 데이터를 효율적으로 검색하고 페이징 처리하는 데 유용하게 사용됩니다.

--- spGetDeptCdByName ---
### 프로시저 `spGetDeptCdByName`의 주요 로직 요약

1. **입력 파라미터**
   - `@pDept_name`: 부서 이름을 검색할 때 사용되는 입력 파라미터 (예: '푸드사업부').

2. **출력 파라미터**
   - `@result_cd`: 프로시저 실행 결과 코드 (0은 성공을 의미).
   - `@result_msg`: 프로시저 실행 결과 메시지 (성공 시 '성공').

3. **주요 로직**
   - `dept_master` 테이블에서 `DEPT_NAME`이 입력된 `@pDept_name`과 일치하는 행을 검색.
   - 검색 조건은 `%@pDept_name%`를 사용하여 대소문자 구분 없이 부분 일치를 찾음.
   - 결과로 `DEPT_CODE`와 `DEPT_NAME`을 반환.

4. **트랜잭션 및 성능 설정**
   - 트랜잭션 격리 수준을 `READ UNCOMMITTED`로 설정하여 성능을 최적화.
   - `NOCOUNT`를 설정하여 `SELECT` 쿼리의 행 수 메시지를 억제.

5. **결과 반환**
   - `@result_cd`는 0(성공)으로, `@result_msg`는 '성공'으로 설정된 후 반환.

### 예시 실행 코드
```sql
DECLARE @result_cd INT, @result_msg VARCHAR(100);

EXEC [dbo].[spGetDeptCdByName] @pDept_name = '푸드사업부',
    @result_cd = @result_cd OUTPUT,
    @result_msg = @result_msg OUTPUT;

SELECT @result_cd as result_cd, @result_msg as result_msg;
```

### 반환 값 예시
- `@result_cd`: 0
- `@result_msg`: '성공'

이 프로시저는 입력된 부서 이름을 기준으로 `dept_master` 테이블에서 일치하는 부서 코드를 검색하고, 성공 시 해당 값을 반환합니다.

--- spGetOutputListForTask ---
아래는 요청하신 SQL 프로시저 코드의 주요 로직을 정리한 것입니다.

### 프로시저명: [dbo].[spGetOutputListForTask]

#### 주요 기능: TASK에 연결된 산출물 목록을 가져온다.

---

### 로직 요약:

1. **파라미터 및 출력 변수 선언**
   - 입력 파라미터: `@pTask_id` (INT, null 가능)
   - 출력 파라미터: `@result_cd` (INT), `@result_msg` (VARCHAR(200))

2. **트랜잭션 및 격리 수준 설정**
   - 트랜잭션 격리 수준을 `READ UNCOMMITTED`로 설정하여 성능을 최적화하고, 데이터 일관성은 보장하지 않음.

3. **파라미터 유효성 체크**
   - `task_id`가 존재하지 않으면 오류 메시지를 반환하고 프로시저를 종료함.

4. **주요 비즈니스 로직 (SELECT 문)**
   - `task_output` 테이블에서 `task_id`와 `is_active_cd` 조건에 맞는 데이터를 선택함.
   - `is_active_cd`는 '10'인 경우만 반환됨.

5. **오류 처리**
   - `TRY-CATCH` 블록을 사용하여 오류 발생 시 `@result_cd`와 `@result_msg`를 설정함.

---

### 주요 SQL 예시 코드 (출력 예시)
```sql
DECLARE @result_cd INT,
        @result_msg VARCHAR(100);

EXEC [dbo].[spGetOutputListForTask]
    @pTask_id = 15,
    @result_cd = @result_cd OUTPUT,
    @result_msg = @result_msg OUTPUT;

SELECT @result_cd AS result_cd,
       @result_msg AS result_msg;
```

- **@result_cd**:
  - 0: 성공
  - 1: 존재하지 않는 태스크
  - -1: 오류 발생

- **@result_msg**:
  - 성공 시 '성공', 오류 시 오류 메시지가 반환됨.

--- spGetDeptAuth ---
아래는 요청하신 SQL 프로시저 코드의 주요 로직을 정리한 것입니다.

### 프로시저명: [dbo].[spGetDeptAuth]

#### 주요 로직:
1. **입력 파라미터**
   - `@pDept_cd`: 부서 코드 (varchar(8), nullable)

2. **출력 파라미터**
   - `@result_cd`: 결과 코드 (int)
   - `@result_msg`: 결과 메시지 (varchar(200))

3. **로직 구현**
   - `dept_auth` 테이블과 `dept_master` 테이블을 조회하여 부서 권한 정보를 가져옵니다.
   - `dept_auth_cd`의 상세 이름을 조회하기 위해 `fnGetDetailNameByDetailCode` 함수를 사용합니다.
   - 결과가 성공이면 `@result_cd`를 0으로, `@result_msg`를 '성공'으로 설정합니다.

#### 예시 실행 코드:
```sql
DECLARE @result_cd INT, @result_msg VARCHAR(100);

EXEC [dbo].[spGetDeptAuth] @pDept_cd = '12020102', @result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT;

SELECT @result_cd as result_cd, @result_msg as result_msg;
```

#### 주요 특징:
- 트랜잭션 격리 수준을 `READ UNCOMMITTED`로 설정하여 성능을 최적화합니다.
- `NOLOCK` 힌트를 사용하여 데이터베이스 잠금을 최소화합니다.
- `fnGetDetailNameByDetailCode` 함수를 통해 권한 코드에 대한 상세 이름을 가져옵니다.

--- spGetProjectApplicants ---
아래는 주어진 SQL 프로시저 코드의 주요 로직을 정리한 내용입니다.

### 프로시저명: spGetProjectApplicants

**목적:** 프로젝트에 참여 신청 목록을 가져온다.

**주요 로직:**

1. **입력 파라미터 확인**
   - `@pProject_id`, `@pProject_name`, `@pProject_owner_id`, `@pPage_no`, `@pPage_size` 등의 파라미터를 받는다.

2. **프로젝트 존재 여부 검사**
   - `project_id`가 유효한지 확인한다.
   - 존재하지 않는 프로젝트일 경우 오류 메시지를 반환한다.

3. **대상 프로젝트 추출**
   - `project` 테이블과 `project_owner` 테이블을 조인하여 프로젝트 목록을 추출한다.
   - `project_name`과 `project_owner_id`에 대한 필터 조건을 적용한다.

4. **전체 건수 계산**
   - `project_member` 테이블에서 상태가 '20'(신청)인 경우의 전체 건수를 계산한다.

5. **페이지 수 계산**
   - 전체 건수를 페이지 크기(`@pPage_size`)로 나눠 전체 페이지 수를 계산한다.

6. **결과 데이터 추출**
   - `project_id`, `project_name`, `member_id`, `status_cd` 등 다양한 정보를 포함하여 결과를 반환한다.
   - `project_owner` 정보와 `project_member` 정보를 조인하여 필요한 데이터를 가져온다.

7. **오류 처리**
   - 트랜잭션 내에서 오류가 발생할 경우 `@result_cd`, `@result_msg`, `@total_count`, `@total_pages` 값을 설정하여 반환한다.

8. **결과 반환**
   - 성공 시 `@result_cd`는 0, 오류 시 -1을 반환한다.
   - 결과 메시지, 전체 건수, 전체 페이지 수를 출력한다.

### 주요 기능 요약
- 프로젝트 참여 신청 목록을 페이지별로 가져오며, 각 프로젝트의 상세 정보를 반환한다.
- 프로젝트 소유자, 멤버, 부서 정보 등을 포함하여 필요한 데이터를 조인하여 반환한다.
- 전체 건수와 페이지 수를 계산하여 반환한다.
- 오류 처리 및 메시지 반환이 명확하게 이루어져 있다.

--- spGetProjectList ---
아래는 요청하신 SQL 프로시저 코드의 주요 로직을 정리한 내용입니다.

---

### 프로시저명: spGetProjectList

#### 주요 기능: 프로젝트 목록 조회

- **조회 조건**:
  - 프로젝트명(@pProject_name), 프로젝트 담당자 ID(@pProject_member_id), 프로젝트 ID 목록(@pProject_ids), 완료 프로젝트 제외 여부(@pExclude_fin_project), 특정 멤버 ID(@pMy_member_id)를 기준으로 프로젝트를 조회할 수 있습니다.
  - 페이징 정보(@pPage_no, @pPage_size) 제공.

- **결과 반환**:
  - 프로젝트 기본 정보 및 상태, 담당자, 멤버, 진행률, 일정 등 다양한 정보를 반환합니다.
  - 총 레코드 수(@total_count)와 총 페이지 수(@total_pages)를 반환합니다.

---

### 주요 로직 흐름

#### 1. 입력 파라미터 처리
- CSV 형식의 프로젝트 ID 목록(@pProject_ids)을 파싱하여 임시 테이블(@ParsedProjectIds)에 저장.

#### 2. 대상 프로젝트 선정
- 사용자가 특정 멤버 ID(@pMy_member_id)를 입력한 경우:
  - 해당 멤버가 소유자 또는 멤버로 참여한 프로젝트만 대상에 포함됩니다.
- 그렇지 않은 경우:
  - 모든 프로젝트 중 조건에 맞는 프로젝트를 대상에 포함됩니다.

#### 3. 프로젝트 결과 생성
- 대상 프로젝트 테이블(@TargetProject)을 기반으로, 프로젝트 상세 정보를 포함한 임시 결과 테이블(@ProjectResult)을 생성합니다.
- 각 프로젝트의 진행률, 상태, 담당자, 멤버 등 다양한 정보를 조회 및 계산하여 임시 결과 테이블에 저장합니다.

#### 4. 페이징 및 결과 반환
- 임시 결과 테이블(@ProjectResult)에서 총 레코드 수와 총 페이지 수를 계산합니다.
- 페이징 조건에 따라 결과를 정렬하고, 해당 페이지의 데이터를 반환합니다.

#### 5. 오류 처리
- 프로시저 실행 중 오류가 발생할 경우:
  - 결과 코드(@result_cd)는 -1로 설정되고, 오류 메시지가 @result_msg에 저장됩니다.
  - 총 레코드 수와 총 페이지 수는 0으로 설정됩니다.

---

### 주요 기능 요약

- **다양한 조건**으로 프로젝트 목록을 조회할 수 있습니다.
- **페이징** 기능을 통해 대량의 데이터를 효율적으로 반환합니다.
- **프로젝트 상세 정보**와 **진행률, 상태** 등을 포함한 결과를 제공합니다.
- **오류 처리**가 명확하게 구현되어 있습니다.

이 프로시저는 프로젝트 관리를 위한 다양한 조회 조건과 페이징 기능을 제공하는 안정적인 SQL 쿼리입니다.

--- spGetProjectOwnerList ---
아래는 요청하신 SQL 프로시저 코드의 주요 로직을 정리한 것입니다.

### 프로시저명: [dbo].[spGetProjectOwnerList]

#### 주요 기능: 프로젝트 담당자 조회

1. **파라미터 및 반환값 정의**
   - 입력 파라미터: `@pProject_id` (프로젝트 ID)
   - 출력 파라미터: `@result_cd` (결과 코드), `@result_msg` (결과 메시지)

2. **트랜잭션 및 격리 수준 설정**
   - 트랜잭션 격리 수준을 `READ UNCOMMITTED`로 설정하여 성능 최적화
   - `NOCOUNT ON`으로 결과 집합의 행 수 반환을 방지하여 성능 향상

3. **파라미터 유효성 체크**
   - 프로젝트 ID가 유효한지 확인
   - 존재하지 않는 프로젝트일 경우 오류 반환

4. **주요 로직 (조회 쿼리)**
   - 프로젝트 정보와 담당자 정보를 조회
   - `project` 테이블과 `project_owner` 테이블을 내부 조인으로 결합
   - 담당자의 인적사항 및 부서 정보를 `hr_master`와 `dept_master` 테이블과 좌측 조인
   - 프로젝트 ID와 담당자 활성화 상태를 조건으로 설정

5. **오류 처리**
   - `TRY-CATCH` 블록을 사용하여 오류 발생 시 처리
   - 오류 발생 시 `@result_cd`를 -1로, `@result_msg`를 오류 메시지로 설정

6. **결과 반환**
   - 성공 시 `@result_cd`를 0으로, `@result_msg`를 '성공'으로 설정
   - 실패 시 적절한 오류 코드와 메시지를 반환

### 실행 예시:
```sql
DECLARE @result_cd INT,
        @result_msg VARCHAR(100);

EXEC [dbo].[spGetProjectOwnerList]
    @pProject_id = 25080015,
    @result_cd = @result_cd OUTPUT,
    @result_msg = @result_msg OUTPUT;

SELECT @result_cd as result_cd,
       @result_msg as result_msg;
```

### 주요 목적:
프로젝트 ID를 입력받아 해당 프로젝트의 담당자 정보를 조회하고, 성공 여부를 반환하는 프로시저입니다.

--- spGetProjectProgressRate ---
아래는 요청하신 SQL 프로시저 코드의 주요 로직을 정리한 내용입니다.

### 프로시저명: [dbo].[spGetProjectProgressRate]

#### 주요 기능: 프로젝트 공정률 계산 및 관련 정보 반환

---

### 1. **파라미터 및 반환값 정의**
- **입력 파라미터**: `@pProject_id` (프로젝트 ID, `INT` 타입)
- **출력 파라미터**:
  - `@result_cd` (결과 코드, `INT` 타입)
  - `@result_msg` (결과 메시지, `VARCHAR(200)` 타입)

---

### 2. **주요 로직**
#### ① **파라미터 유효성 체크**
- `project_id`가 유효한 프로젝트인지 확인
  - `project_id`가 존재하지 않으면 오류 반환
    - `@result_cd = 1`
    - `@result_msg = '존재하지 않는 프로젝트 입니다.'`

#### ② **지연 일수 계산**
- **계획 최대 종료일**과 **실제 최대 종료일**을 기반으로 지연 일수 계산
  - `task_finish_plan` 테이블에서 `plan_cd = '20'` (계획) 및 `plan_cd = '30'` (실제)인 경우 최대 종료일을 조회
  - 두 날짜 간 차이를 `dbo.fnCalcWorkingDay` 함수로 계산하여 지연 일수 산출

#### ③ **프로젝트 공정률 및 지연 정보 조회**
- `project` 테이블과 `task` 테이블을 조인하여 다음 정보를 반환
  - `project_id`, `project_name`
  - `actual_rate` (실제 공정률), `planed_rate` (계획 공정률)
  - `delayed_tasks` (지연된 작업 수), `delayed_days` (지연 일수)

---

### 3. **오류 처리**
- **`TRY-CATCH` 블록**을 사용한 오류 처리
  - 오류 발생 시 `@result_cd = -1` 및 오류 메시지를 `@result_msg`에 반환

---

### 4. **트랜잭션 및 성능 설정**
- `TRANSACTION ISOLATION LEVEL READ UNCOMMITTED`로 성능 최적화
- `NOCOUNT ON`으로 불필요한 결과 행 수 반환 방지

---

### 5. **함수 및 사용자 정의 함수**
- `dbo.fnGetProjectProgressRateActual`, `dbo.fnGetProjectProgressRatePlan`, `dbo.fnCalcWorkingDay` 등의 사용자 정의 함수를 활용하여 공정률 및 지연 일수 계산

---

### 요약
이 프로시저는 특정 프로젝트 ID에 대한 프로젝트 공정률 (계획 및 실제)을 계산하고, 작업 지연 현황 및 지연 일수 등을 반환합니다. 또한, 유효하지 않은 프로젝트 ID가 입력되거나 오류가 발생할 경우 적절한 오류 메시지를 반환합니다.

--- spGetProjectTemplateList ---
아래는 요청하신 SQL 프로시저 코드의 주요 로직을 정리한 것입니다.

### 프로시저명: [dbo].[spGetProjectTemplateList]

#### 주요 기능: 프로젝트 템플릿 목록 조회

---

### 입력 파라미터:
- `@pProject_name` (VARCHAR(50)): 프로젝트 이름 필터링 조건
- `@pPage_no` (INT): 조회할 페이지 번호
- `@pPage_size` (INT): 한 페이지당 표시할 레코드 수

---

### 출력 파라미터:
- `@result_cd` (INT): 결과 코드 (0: 성공, -1: 실패)
- `@result_msg` (VARCHAR(200)): 결과 메시지
- `@total_count` (INT): 전체 레코드 수
- `@total_pages` (INT): 전체 페이지 수

---

### 주요 로직:

1. **전체 템플릿 개수 계산**
   - `dbo.project` 테이블에서 `project_type_cd`가 '90'이고 `is_active`가 '10'인 레코드 중, `@pProject_name`이 null이거나 `project_name`이 `@pProject_name`을 포함하는 레코드 수를 계산합니다.

2. **페이지 수 계산**
   - 전체 레코드 수를 `@pPage_size`로 나눈 값을 올림하여 전체 페이지 수를 계산합니다.

3. **프로젝트 목록 조회**
   - `dbo.project` 테이블에서 `project_type_cd`가 '90'이고 `is_active`가 '10'인 레코드 중, `@pProject_name`이 null이거나 `project_name`이 `@pProject_name`을 포함하는 레코드를 페이지 단위로 조회합니다.
   - 조회 결과는 `created_at` 기준으로 내림차순 정렬되며, `@pPage_no` 페이지의 데이터를 `@pPage_size`만큼 반환합니다.

4. **결과 처리**
   - 정상적인 결과 반환 시 `@result_cd`는 0, `@result_msg`는 '성공'으로 설정됩니다.
   - 오류 발생 시 `@result_cd`는 -1, `@result_msg`는 오류 메시지를 설정하며, `@total_count`와 `@total_pages`는 0으로 설정됩니다.

---

### 주요 기능 요약:
- 프로젝트 템플릿 목록을 페이지 단위로 조회하고, 전체 레코드 수와 페이지 수를 반환합니다.
- `@pProject_name` 필터링 조건을 통해 특정 프로젝트 이름을 포함하는 레코드만 조회할 수 있습니다.

--- spGetTaskInfoDetail ---
이 SQL 프로시저의 주요 로직을 요약하면 다음과 같습니다:

1. 입력된 태스크 ID(@pTask_id)에 대한 상세 정보를 조회합니다.
2. 태스크의 프로젝트 ID를 확인합니다.
3. 파라미터 유효성 검사를 수행하여 태스크가 존재하는지 확인합니다.
4. 태스크의 지연 이력 정보를 조회하고, 지연 사유와 날짜를 피벗하여 10개의 지연 이력 정보를 포함합니다.
5. 태스크의 기본 정보, 계획 정보, 실제 수행 정보, 지연 정보 등을 포함하여 상세 정보를 반환합니다.
6. 결과 코드(@result_cd)와 메시지(@result_msg)를 출력 파라미터로 반환합니다.
7. 에러 발생 시에는 결과 코드를 -1로 설정하고, 에러 메시지를 반환합니다.

이 프로시저는 태스크의 상세 정보를 포함한 지연 이력 정보를 반환하는 데 중점을 두고 있습니다.

--- spGetTaskList ---
아래는 요청하신 SQL 프로시저 코드의 주요 로직을 정리한 내용입니다:

### 프로시저의 주요 목적
- 프로젝트에 등록된 태스크 리스트를 가져오는 것

### 주요 로직
1. **파라미터 유효성 체크**
   - 프로젝트 ID가 유효한지 확인
   - 프로젝트가 존재하지 않으면 오류 반환

2. **태스크 정보 조회**
   - 프로젝트 ID에 해당하는 태스크 정보를 조회
   - 태스크 정보에는 다음과 같은 내용이 포함됨:
     - 태스크 ID
     - 태스크 이름
     - 의존성 정보
     - 계획 및 실제 시작 및 종료 날짜
     - 작업일 수
     - 태스크 상태
     - 프로젝트 정보
     - 담당자 정보
     - 출력 필요 여부 및 등록 상태
     - 지연 정보 (최대 10개)

3. **지연 정보 처리**
   - 지연 정보는 최대 10개까지 조회
   - 지연 날짜와 지연 사유를 피벗하여 처리
   - 지연 정보는 LEFT JOIN을 통해 태스크 정보와 결합

4. **결과 처리**
   - 모든 정보를 임시 테이블(#RESULT_TMP)에 저장
   - 넘버링 처리를 위한 별도의 로직 수행
   - 최종적으로 임시 테이블에서 필요한 컬럼들을 선택하여 반환

5. **오류 처리**
   - 프로시저 실행 중 오류 발생 시 결과 코드와 메시지 설정

### 주요 기능 요약
- 프로젝트 ID에 대한 유효성 검사
- 태스크 정보 및 지연 정보 조회 및 처리
- 다양한 피벗과 JOIN을 사용하여 필요한 정보를 가져옴
- 결과 데이터에 대한 넘버링 처리
- 오류 발생 시 적절한 반환 값 설정

이 프로시저는 프로젝트 관리 시스템에서 프로젝트별 태스크 정보를 포함한 상세한 태스크 리스트를 제공하는 데 사용됩니다.

--- spGetTaskOwnerList ---
아래는 요청하신 SQL 프로시저 코드의 주요 로직을 정리한 것입니다.

### 프로시저명: spGetTaskOwnerList

#### 주요 기능: TASK에 할당된 인원 목록 조회

---

### 로직 요약:

1. **파라미터 및 반환값 정의**
   - 입력 파라미터: `@pTask_id` (INT)
   - 출력 파라미터: `@result_cd` (INT), `@result_msg` (VARCHAR(200))

2. **트랜잭션 및 격리 수준 설정**
   - 트랜잭션 격리 수준을 `READ UNCOMMITTED`로 설정하여 성능 최적화
   - `NOCOUNT ON`으로 결과 집합의 행 수 반환을 방지하여 성능 향상

3. **파라미터 유효성 체크**
   - `task_id`가 존재하지 않으면 오류 반환
   - 존재하지 않는 태스크일 경우:
     - `@result_cd`를 1로 설정
     - `@result_msg`에 "존재하지 않는 태스크 입니다." 메시지 할당
     - 프로시저 종료

4. **주요 비즈니스 로직 (인원 목록 조회)**
   - `project`, `task`, `task_owner`, `hr_master` 테이블을 조인하여 해당 태스크에 할당된 인원 정보를 조회
   - 결과 집합은 `project_id`, `project_name`, `task_id`, `task_name`, `member_id`, `member_name`을 포함
   - 성공 시:
     - `@result_cd`를 0으로 설정
     - `@result_msg`에 "성공" 메시지 할당

5. **에러 처리**
   - `TRY-CATCH` 블록을 사용하여 오류 발생 시:
     - `@result_cd`를 -1로 설정
     - `@result_msg`에 오류 메시지를 할당

---

### 실행 예시:

```sql
DECLARE @result_cd INT,
        @result_msg VARCHAR(100);

EXEC [dbo].[spGetTaskOwnerList]
    @pTask_id = 3,
    @result_cd = @result_cd OUTPUT,
    @result_msg = @result_msg OUTPUT;

SELECT @result_cd AS result_cd,
       @result_msg AS result_msg;
```

- 성공 시: `@result_cd = 0`, `@result_msg = '성공'`
- 실패 시: `@result_cd = 1` 또는 `-1`, `@result_msg`에 오류 메시지 반환

--- spInsertCodeMaster ---
아래는 요청하신 SQL 프로시저 코드의 주요 로직을 정리한 내용입니다:

### 프로시저명: [dbo].[spInsertCodeMaster]

**목적:** 코드 마스터값 추가

**주요 로직:**

1. **입력 파라미터 및 출력 변수 선언**
   - 입력 파라미터: `@pGroup_cd` (그룹 코드), `@pDetail_name` (상세 이름), `@pCreator_id` (생성자 ID)
   - 출력 변수: `@result_cd` (결과 코드), `@result_msg` (결과 메시지)

2. **트랜잭션 설정**
   - 트랜잭션 격리 수준을 `READ UNCOMMITTED`로 설정.
   - `@vSeverity` 변수를 선언하여 오류 심각도를 저장.

3. **그룹 코드의 최대 상세 코드(`detail_cd`) 추출**
   - `code_master` 테이블에서 해당 그룹 코드의 최대 `detail_cd` 값을 조회하고, 이를 기반으로 새로운 `detail_cd`를 부여.

4. **유효성 검사**
   - **그룹 코드 채번 중복 체크:** 이미 동일한 그룹 코드와 상세 코드가 존재하는지 확인.
   - **시스템 코드 접근 제한:** `@pGroup_cd` 값이 '90000' 이상인 경우 오류 반환.
   - **상세 이름 중복 체크:** 동일한 그룹 코드와 상세 이름이 이미 존재하는지 확인.
   - **그룹 코드 존재 여부:** 그룹 코드가 존재하지 않는 경우 오류 반환.

5. **데이터 삽입**
   - `code_master` 테이블에 새로운 레코드를 삽입.
   - `detail_cd`는 자동으로 증가된 값으로 설정.
   - `is_active_cd`는 기본값 '10'으로 설정.
   - `created_at`은 현재 시간으로 설정.

6. **트랜잭션 완료**
   - 삽입 작업이 성공하면 트랜잭션을 커밋.
   - `@result_cd`를 0(성공)으로 설정.
   - `@result_msg`를 '성공'으로 설정.

7. **오류 처리**
   - `TRY-CATCH` 블록을 사용하여 오류 발생 시 롤백 수행.
   - 오류 발생 시 `@result_cd`를 -1로, `@result_msg`를 오류 메시지로 설정.

8. **로그 기록**
   - `use_log` 테이블에 프로시저 실행 내역을 기록.
   - 실행 결과와 관련된 정보를 저장.

### 예시 실행 코드:
```sql
DECLARE @result_cd INT, @result_msg VARCHAR(100);

EXEC [dbo].[spInsertCodeMaster]
    @pGroup_cd = '99999',
    @pDetail_name = '마스터코드테스트1',
    @pCreator_id = 1,
    @result_cd = @result_cd OUTPUT,
    @result_msg = @result_msg OUTPUT;

SELECT @result_cd as result_cd, @result_msg as result_msg;
```

### 주요 기능 요약:
- 그룹 코드에 대한 상세 코드 추가.
- 그룹 코드 채번 관리.
- 데이터 중복 체크.
- 시스템 코드 접근 제한.
- 로그 기록.

이 프로시저는 코드 마스터값을 추가하는 기능을 제공하며, 다양한 유효성 검사를 통해 데이터 무결성을 유지합니다.

--- spInsertOutputForTask ---
아래는 요청하신 SQL 프로시저 코드의 주요 로직을 정리한 내용입니다.

### 프로시저명: [dbo].[spInsertOutputForTask]

**주요 기능: 태스크에 대한 산출물 정보를 입력하는 프로시저**

---

### 주요 로직 요약:

1. **입력값 검증**
   - 태스크 ID가 존재하지 않으면 오류 반환
   - 동일한 태스크에 동일한 파일 경로의 산출물이 이미 존재하면 오류 반환

2. **산출물 정보 삽입**
   - `task_output` 테이블에 새로운 산출물 정보 삽입
   - 삽입 시 기본값으로 `is_active_cd`는 '10'(사용)으로 설정

3. **오류 처리**
   - 삽입 실패 시 트랜잭션 롤백 수행
   - 오류 코드와 메시지를 출력값으로 반환

4. **로깅**
   - 프로시저 실행 내역을 `dbo.use_log` 테이블에 기록
   - 입력값, 결과 코드, 결과 메시지 등을 로그에 저장

---

### 예시 실행 코드:
```sql
DECLARE @result_cd INT, @result_msg VARCHAR(100);

EXEC [dbo].[spInsertOutputForTask]
    @pTask_id = 15,
    @pFile_path = '/nas/wellfood/marketing/20250528_신제품 디자인 초안2.pptx',
    @pOutput_comment = '디자인 초안 확인용',
    @pCreator_id = 1,
    @result_cd = @result_cd OUTPUT,
    @result_msg = @result_msg OUTPUT;

SELECT @result_cd as result_cd, @result_msg as result_msg;
```

- **입력값 설명:**
  - `@pTask_id`: 태스크 ID (예: 15)
  - `@pFile_path`: 저장할 파일 경로
  - `@pOutput_comment`: 산출물에 대한 설명
  - `@pCreator_id`: 생성자 ID

- **출력값 설명:**
  - `@result_cd`: 프로시저 실행 결과 코드 (0:성공, -1:실패)
  - `@result_msg`: 프로시저 실행 결과 메시지

---

### 주요 기능 정리:
- 태스크에 대한 산출물 정보 삽입
- 중복 태스크 및 파일 검증
- 오류 처리 및 로깅 기능
- 출력값을 통한 결과 반환

--- spGetAccessStateForUser ---
아래는 요청하신 SQL 프로시저 코드의 주요 로직을 정리한 것입니다.

### 프로시저명: [dbo].[spGetAccessStateForUser]

#### 주요 로직 요약:

1. **입력 파라미터 및 출력 파라미터 정의**
   - 입력 파라미터: `@pMember_id` (회원 ID, `VARCHAR(7)`)
   - 출력 파라미터: `@result_cd` (결과 코드, `INT`), `@result_msg` (결과 메시지, `VARCHAR(200)`)

2. **트랜잭션 및 격리 수준 설정**
   - `SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED`로 설정하여 읽기 작업의 성능을 최적화하고, 데이터 변경은 없는 상태로 가정합니다.

3. **회원 ID 존재 여부 확인**
   - `dbo.hr_master` 테이블에서 회원 ID가 존재하는지 확인합니다.
   - 존재하지 않을 경우 오류를 발생시킵니다: `'존재하지 않는 회원 아이디 입니다.'`

4. **접근 상태 조회**
   - `dbo.hr_master` 테이블과 `dbo.login_control` 테이블을 조회하여 회원의 접근 상태(`access_yn`)를 확인합니다.
   - `access_yn` 값은 기본적으로 'Y'로 설정되며, `login_control` 테이블에서 해당 회원의 접근 제한 정보가 있는 경우 이를 반영합니다.

5. **결과 처리**
   - 정상적인 경우: `@result_cd`를 0으로, `@result_msg`를 '성공'으로 설정합니다.
   - 오류 발생 시: `@result_cd`를 -1로, `@result_msg`를 오류 메시지로 설정합니다.

6. **오류 처리**
   - `BEGIN CATCH` 블록을 사용하여 오류가 발생한 경우에 대한 처리를 합니다.
   - 오류 메시지와 심각성을 출력 파라미터에 저장합니다.

#### 예시 실행 코드:
```sql
DECLARE @result_cd INT,
        @result_msg VARCHAR(100);

EXEC [dbo].[spGetAccessStateForUser]
    @pMember_id = '2204901',
    @result_cd = @result_cd OUTPUT,
    @result_msg = @result_msg OUTPUT;

SELECT @result_cd as result_cd,
       @result_msg as result_msg;
```

#### 예시 결과:
- 정상적인 경우: `result_cd`는 0, `result_msg`는 '성공'으로 출력됩니다.
- 회원 ID가 존재하지 않는 경우: `result_cd`는 -1, `result_msg`는 '존재하지 않는 회원 아이디 입니다.'로 출력됩니다.

이 프로시저는 회원의 접근 상태를 제어하기 위한 로직을 포함하고 있으며, 주로 회원 ID가 유효한지 확인하고 해당 회원의 접근 권한을 검사하는 데 사용됩니다.

--- spInsertProjectInfo ---
다음은 SQL 프로시저 `spInsertProjectInfo`의 주요 로직을 정리한 것입니다:

### 1. **입력값 유효성 검증**
- 필수 입력값 (`@project_type_cd`, `@project_name`)이 누락되었는지 확인.
- 브랜드 코드 (`@brand_cd`)와 패밀리 브랜드 코드 (`@fml_brand_cd`)가 유효한지 확인.
- 프로젝트 이름 (`@project_name`)이 중복되지 않는지 확인.
- 프로젝트 타입 코드 (`@project_type_cd`)가 유효한지 확인.

### 2. **템플릿 기반 프로젝트 생성**
- 템플릿(`@project_type_cd = '90'`)인 경우, `line_cd`, `brand_cd`, `fml_brand_cd`는 null로 설정.
- 템플릿 기반으로 일반 프로젝트를 생성할 때, 전달받은 프로젝트 아이디(`@project_id`)가 템플릿인지 확인.

### 3. **프로젝트 및 태스크 데이터 삽입**
- **프로젝트 정보 삽입**:
  - `project` 테이블에 새로운 프로젝트 정보를 삽입.
  - `project_id`, `project_type_cd`, `line_cd`, `brand_cd`, `fml_brand_cd`, `work_type_cd`, `project_name`, `planed_start_dt`, `is_active` 등의 정보를 저장.
- **태스크 정보 복사**:
  - 템플릿 기반으로 생성된 프로젝트의 경우, 해당 템플릿의 태스크를 복사하여 `task` 테이블에 삽입.
  - 태스크의 순서(`order_no`)와 상태(`status_cd`) 등을 유지하며 복사.

### 4. **태스크 종속성 및 계획 일정 설정**
- **태스크 종속성 복사**:
  - 템플릿의 태스크 간 종속성을 `task_dependency` 테이블에 복사.
- **태스크 계획 일정 생성**:
  - `task_finish_plan` 테이블에 태스크의 계획된 시작 및 종료 일정을 삽입.
  - 계획 일정을 실제로 복제하고, 프로젝트 타입에 따라 `plan_cd`를 설정.

### 5. **트랜잭션 관리**
- 모든 작업은 트랜잭션으로 관리되며, 오류 발생 시 롤백 수행.
- 성공 또는 실패 결과를 `@result_cd`와 `@result_msg`에 저장.

### 6. **로깅**
- 프로젝트 생성 시 입력값과 결과 메시지를 `use_log` 테이블에 기록.

### 주요 특징:
- **유연성**: 프로젝트 생성 시 템플릿을 기반으로 할 수 있으며, 다양한 프로젝트 타입(`project_type_cd`)을 지원.
- **검증**: 입력값에 대한 철저한 검증을 통해 데이터 무결성을 유지.
- **복사 기능**: 템플릿의 태스크와 종속성을 새로운 프로젝트에 복사하여 빠른 설정을 가능하게 함.

이 프로시저는 프로젝트 생성 시 필요한 모든 정보를 검증하고 적절히 저장하는 역할을 수행합니다.

--- spUpdateAccessStateForUser ---
아래는 요청하신 SQL 프로시저 코드의 주요 로직을 정리한 내용입니다:

### 프로시저명: spUpdateAccessStateForUser

#### 주요 기능:
1. **파라미터 검증**
   - `@pMember_id`, `@pAccess_yn`이 NULL일 경우 오류 반환
   - `@pAccess_yn` 값이 'Y' 또는 'N'이 아닐 경우 오류 반환

2. **회원 존재 여부 확인**
   - `dbo.hr_master` 테이블에서 `@pMember_id`에 해당하는 회원이 존재하지 않으면 오류 반환

3. **로그인 컨트롤 테이블 관리**
   - `dbo.login_control` 테이블이 존재하지 않으면 새로 생성
   - 존재할 경우 `access_yn`, `modifier_id`, `modified_at` 컬럼 업데이트

4. **오류 및 예외 처리**
   - 오류 발생 시 `@result_cd`를 -1로, `@result_msg`를 오류 메시지로 설정
   - 오류 세버리티를 `@vSeverity`로 저장

5. **로그 기록**
   - `dbo.use_log` 테이블에 프로시저 실행 내역 저장
   - `result_cd`, `result_msg`, `created_at` 컬럼 업데이트

#### 주요 테이블:
- `dbo.hr_master`: 회원 정보 확인
- `dbo.login_control`: 로그인 접근 상태 관리
- `dbo.use_log`: 프로시저 실행 로그 기록

#### 비즈니스 로직 요약:
1. 입력 파라미터 검증을 통해 누락 또는 잘못된 값 방지
2. 회원 존재 여부를 확인하여 잘못된 회원 방지
3. 로그인 컨트롤 테이블에 데이터가 없으면 새로 생성, 있으면 업데이트
4. 모든 오류 및 예외를 세밀하게 처리하여 명확한 메시지 전달
5. 프로시저 실행 내역을 체계적으로 로깅

이 프로시저는 회원의 로그인 접근 상태를 안전하고 체계적으로 관리하기 위한 목적으로 작성되었습니다.

--- spInsertProjectMember ---
아래는 요청하신 SQL 프로시저 코드의 주요 로직을 정리한 내용입니다.

### 프로시저명: spInsertProjectMember

#### 주요 기능: 프로젝트 멤버 참여 신청

---

### 입력 파라미터:
- @project_id (INT): 프로젝트 ID
- @member_id (VARCHAR(7)): 멤버 ID
- @status_cd (VARCHAR(8)): 상태 코드 (mst ref: 90102, 10 승인, 20 신청, 90 반려)
- @creator_id (VARCHAR(7)): 생성자 ID
- @result_cd (INT, OUTPUT): 결과 코드
- @result_msg (VARCHAR(200), OUTPUT): 결과 메시지

---

### 주요 로직:

1. **프로젝트 유효성 체크**
   - 프로젝트 ID가 존재하지 않으면 오류 반환

2. **마스터 코드 유효성 체크**
   - 상태 코드(@status_cd)가 마스터 테이블에 존재하지 않으면 오류 반환

3. **템플릿 프로젝트 멤버 추가 제한**
   - 프로젝트 유형이 '90'(템플릿)인 경우 멤버 추가를 제한하고 오류 반환

4. **이미 참여한 멤버 체크**
   - 해당 프로젝트에 이미 참여 중인 멤버라면 오류 반환

5. **프로젝트 멤버 신청 상태 체크**
   - 해당 프로젝트에 이미 신청 상태인 멤버라면 오류 반환

6. **프로젝트 멤버 반려 상태 체크**
   - 해당 프로젝트에 이미 반려 상태인 멤버라면 오류 반환

7. **프로젝트 멤버 추가**
   - 모든 유효성 검사를 통과하면 프로젝트 멤버를 추가하고 결과를 반환

---

### 출력 결과:
- 성공 시: @result_cd = 0, @result_msg = '성공'
- 실패 시: @result_cd = 1 또는 -1, @result_msg에 오류 메시지 반환

---

### 예시 실행 코드:
```sql
DECLARE @result_cd INT, @result_msg VARCHAR(100);

-- 프로젝트 멤버 신청 예시
EXEC [dbo].[spInsertProjectMember]
    @project_id = 2,
    @member_id = '2400010',
    @status_cd = 20,
    @creator_id = '2400010'
    @result_cd = @result_cd OUTPUT,
    @result_msg = @result_msg OUTPUT;

SELECT @result_cd as result_cd, @result_msg as result_msg;
```

---

### 주요 기능 요약:
프로젝트 멤버의 참여 신청을 처리하며, 프로젝트 및 멤버의 유효성을 검사한 후 결과를 반환합니다.

--- spInsertProjectOwner ---
아래는 요청하신 SQL 프로시저 코드의 주요 로직을 정리한 내용입니다.

### 프로시저명: [dbo].[spInsertProjectOwner]

**주요 기능: 프로젝트에 담당자(오너)를 할당하는 프로시저**

---

### 주요 로직 요약:

1. **입력 파라미터**
   - `@pProject_id`: 프로젝트 ID (INT)
   - `@pMember_ids`: CSV 형식의 회원 ID 목록 (VARCHAR(MAX))
   - `@pIsActive_cd`: 활성화 코드 (VARCHAR(8), 기본값 '10')
   - `@pCreator_id`: 생성자 ID (VARCHAR(7))
   - `@result_cd`: 결과 코드 (INT, OUT)
   - `@result_msg`: 결과 메시지 (VARCHAR(200), OUT)

---

2. **프로시저 실행 로직**

   - **트랜잭션 설정**: `READ UNCOMMITTED` 수준으로 설정
   - **에러 처리**: `BEGIN TRY`/`BEGIN CATCH` 블록을 사용한 오류 처리

---

3. **주요 검증 로직**

   - **프로젝트 유효성 검사**:
     - 프로젝트 ID가 존재하지 않으면 오류 반환
     - 프로젝트 타입이 '90'(템플릿)인 경우 오너 할당 불가

   - **회원 ID 유효성 검사**:
     - CSV 문자열을 테이블로 분리하여 유효한 회원 ID인지 확인
     - 유효하지 않은 회원 ID가 포함되어 있으면 오류 반환

---

4. **데이터 삽입 로직**

   - `project_owner` 테이블에 데이터 삽입:
     - 프로젝트 ID, 회원 ID, 활성화 코드, 생성자 ID, 생성 일자 등을 포함
     - 중복 제거 및 이미 등록된 항목 제외 후 삽입

---

5. **결과 반환**:
   - 성공 시: `@result_cd = 0`, `@result_msg = '성공'`
   - 실패 시: `@result_cd = -1`, `@result_msg = 오류 메시지`

---

6. **로깅**:
   - 프로시저 실행 내역을 `dbo.use_log` 테이블에 기록
   - 입력 파라미터와 결과 등을 포함하여 로깅

---

### 예시 실행 코드 (SQL Query):

```sql
DECLARE @result_cd INT, @result_msg VARCHAR(100);

EXEC [dbo].[spInsertProjectOwner]
    @pProject_id = 25080009,
    @pMember_ids = '2400001, 2400002, 2400003',
    @pIsActive_cd = '10',
    @pCreator_id = 1,
    @result_cd = @result_cd OUTPUT,
    @result_msg = @result_msg OUTPUT;

SELECT @result_cd as result_cd, @result_msg as result_msg;
```

---

### 주요 기능 정리:

- 프로젝트 오너 지정 및 관리
- 프로젝트 및 회원 ID의 유효성 검증
- 중복 제거 및 데이터 정합성 유지
- 프로시저 실행 로깅

--- spGenerateProjectId ---
아래는 요청하신 SQL 프로시저 코드의 주요 로직을 정리한 내용입니다.

### 프로시저의 주요 로직 요약

1. **시퀀스 증가 및 조회**
   - `project_seq` 테이블에서 현재 년월(`@yymm`)을 기준으로 시퀀스를 증가시키고, 증가된 시퀀스를 조회합니다.
   - `MERGE` 문을 사용하여 `project_seq` 테이블을 업데이트하거나 삽입합니다.

2. **후보 프로젝트 ID 생성**
   - 형식: `YYMM + SEQ`
   - 예: `25070001` (25년 7월, 시퀀스 1)

3. **기존 프로젝트 ID와의 비교**
   - 현재 년월 기준 `project` 테이블에서 최대 프로젝트 ID(`@existing_max_id`)를 조회합니다.
   - 후보 프로젝트 ID가 기존 최대 ID보다 작거나 같으면 시퀀스를 보정합니다.

4. **시퀀스 보정**
   - 기존 최대 프로젝트 ID의 시퀀스를 1 증가시키고, `project_seq` 테이블을 업데이트합니다.
   - 보정된 시퀀스로 새로운 프로젝트 ID를 생성합니다.

5. **결과 반환**
   - 최종적으로 생성된 프로젝트 ID를 출력 파라미터(`@project_id`)에 할당합니다.

### 주요 로직의 핵심 목적
- **프로젝트 ID의 고유성 보장**: 년월과 시퀀스를 조합하여 고유한 프로젝트 ID를 생성합니다.
- **연속된 시퀀스 관리**: `project_seq` 테이블을 통해 년월별로 시퀀스를 관리하고, 이미 사용된 ID와 중복되지 않도록 보정합니다.

이 프로시저는 프로젝트 ID를 체계적으로 관리하기 위한 로직을 제공하며, 고유성과 연속성을 유지하도록 설계되었습니다.

--- spInsertProjectTask ---
다음은 주어진 SQL 프로시저 코드의 주요 로직을 정리한 것입니다.

### 프로시저명: spInsertProjectTask

#### 주요 기능: 단건 태스크 인서트

#### 입력 파라미터:
- @task_name (VARCHAR): 태스크 이름
- @project_id (INT): 프로젝트 ID
- @dependency_id (INT): 의존 태스크 ID (null 가능)
- @dependency_cd (VARCHAR): 의존 태스크 코드 (null 가능)
- @pre_order_no (FLOAT): 앞 태스크의 order_no (null 가능)
- @post_order_no (FLOAT): 뒤 태스크의 order_no (null 가능)
- @planed_start_dt (VARCHAR): 계획 시작일 (null 가능)
- @planed_end_dt (VARCHAR): 계획 종료일 (null 가능)
- @working_day (INT): 워킹데이 (null 가능)
- @status_cd (VARCHAR): 태스크 상태 코드
- @is_active_cd (VARCHAR): 사용 여부 코드
- @is_output_need (VARCHAR): 산출물 필요 여부 코드
- @creator_id (VARCHAR): 생성자 ID

#### 출력 파라미터:
- @task_id (INT): 생성된 태스크 ID
- @result_cd (INT): 결과 코드 (0:성공, -1:실패)
- @result_msg (VARCHAR): 결과 메시지

#### 주요 로직:
1. 입력값 유효성 검사
   - 프로젝트 ID가 존재하는지 확인
   - 의존 태스크 ID가 유효한지 확인
   - order_no가 존재하는지 확인
   - 날짜 형식이 올바른지 확인
   - 코드 값이 유효한지 확인

2. 태스크 및 관련 데이터 삽입
   - task 테이블에 태스크 정보 삽입
   - task_dependency 테이블에 의존 태스크 정보 삽입 (필요시)
   - task_finish_plan 테이블에 계획 정보 삽입

3. 오류 처리
   - 입력값이 잘못된 경우 오류 반환
   - 프로젝트 ID가 존재하지 않는 경우 오류 반환
   - 의존 태스크 ID가 잘못된 경우 오류 반환
   - 날짜 형식이 잘못된 경우 오류 반환

4. 로깅
   - 입력 파라미터와 결과 정보를 로그 테이블에 기록

#### 예시 실행:
```sql
DECLARE @task_id INT, @result_cd INT, @result_msg VARCHAR(100);

EXEC [dbo].[spInsertProjectTask]
    @task_name = '표시사항',
    @project_id = 15,
    @dependency_id = NULL,
    @dependency_cd = NULL,
    @pre_order_no = 3,
    @post_order_no = NULL,
    @planed_start_dt = '2025-06-10',
    @planed_end_dt = '2025-06-12',
    @working_day = 10,
    @status_cd = '10',
    @is_active_cd = '10',
    @is_output_need = '10',
    @creator_id = 1,
    @task_id = @task_id OUTPUT,
    @result_cd = @result_cd OUTPUT,
    @result_msg = @result_msg OUTPUT;

SELECT @task_id as task_id, @result_cd as result_cd, @result_msg as result_msg;
```

#### 주요 기능 설명:
- 입력값 검증을 통해 데이터 무결성 유지
- 태스크 및 관련 계획 정보를 데이터베이스에 저장
- 의존 태스크가 올바르게 설정된지 확인
- 프로젝트 상태에 따라 적절한 계획 코드 설정
- 오류 발생 시 롤백 수행
- 모든 작업 결과에 대한 로깅

--- spInsertTaskOwner ---
아래는 요청하신 SQL 프로시저 코드의 주요 로직을 정리한 내용입니다:

### 프로시저명: [dbo].[spInsertTaskOwner]

**목적:** 태스크 담당자 할당

**주요 로직:**

1. **입력 파라미터**
   - `@pTask_id` (태스크 ID, `INT`, nullable)
   - `@pMember_ids` (할당할 멤버 ID 목록, `VARCHAR(MAX)`, nullable)
   - `@pIsActive_cd` (활성화 코드, `VARCHAR(8)`, nullable)
   - `@pCreator_id` (생성자 ID, `VARCHAR(7)`, nullable)
   - `@result_cd` (결과 코드, `INT`, 출력 파라미터)
   - `@result_msg` (결과 메시지, `VARCHAR(200)`, 출력 파라미터)

2. **CSV 문자열 파싱**
   - `String_Split`을 사용하여 `@pMember_ids`를 개별 멤버 ID로 분리
   - 분리된 멤버 ID를 `@MemberList` 테이블에 삽입

3. **유효성 검사**
   - **템플릿 프로젝트 검사**: 프로젝트 유형이 '10'이 아닌 경우 담당자 할당 불가
   - **태스크 존재 여부 확인**: `@pTask_id`에 해당하는 태스크가 존재하는지 확인

4. **주요 기능**
   - `task_owner` 테이블에 데이터 삽입
   - 각 멤버 ID에 대해 `task_id`, `member_id`, `is_active_cd`, `creator_id`를 설정
   - 현재 시간(`GETDATE()`)을 `created_at`에 저장

5. **트랜잭션 처리**
   - `BEGIN TRAN`과 `COMMIT TRAN`으로 데이터 일관성 유지
   - 오류 발생 시 `ROLLBACK TRAN` 수행

6. **결과 반환**
   - 성공 시 `@result_cd = 0`, `@result_msg = '성공'`
   - 실패 시 `@result_cd = 1` 또는 `-1`, `@result_msg`에 오류 메시지 저장

### 예시 실행 코드:
```sql
DECLARE @result_cd INT, @result_msg VARCHAR(100);

EXEC [dbo].[spInsertTaskOwner]
    @pTask_id = 25,
    @pMember_ids = '2400000, 2400001',
    @pIsActive_cd = '10',
    @pCreator_id = 1,
    @result_cd = @result_cd OUTPUT,
    @result_msg = @result_msg OUTPUT;

SELECT @result_cd as result_cd, @result_msg as result_msg;
```

### 주요 기능 요약:
- 멤버 ID 목록을 `task_owner` 테이블에 할당
- 유효성 검사를 통한 오류 방지
- 트랜잭션을 통한 데이터 안정성 유지

--- spIsAccsProject ---
아래는 요청하신 SQL 프로시저 코드의 주요 로직을 정리한 내용입니다.

### 프로시저명: [dbo].[spIsAccsProject]

**주요 기능: 프로젝트에 대한 접근 권한 확인**

---

### 로직 요약:

1. **파라미터 유효성 체크**
   - 프로젝트 ID(@pProject_id)가 유효한지 확인
     - 존재하지 않는 프로젝트일 경우:
       - @result_cd = 1
       - @result_msg = '존재하지 않는 프로젝트 입니다.'
       - 프로시저 종료

   - 회원 ID(@pMember_id)가 유효한지 확인
     - 존재하지 않는 회원일 경우:
       - @result_cd = 1
       - @result_msg = '존재하지 않는 회원 입니다.'
       - 프로시저 종료

2. **프로젝트 접근 권한 확인**
   - 프로젝트 멤버(PM) 또는 프로젝트 소유자(PO)로 등록되어 있는지 확인
   - 유효한 접근 권한이 있는 경우:
     - @result_cd = 0
     - @result_msg = '성공'
     - isAccessable = '1' 반환
   - 유효한 접근 권한이 없는 경우:
     - @result_cd = 0
     - @result_msg = '성공'
     - isAccessable = '0' 반환

3. **에러 처리**
   - 프로시저 실행 중 오류 발생 시:
     - @result_cd = -1
     - @result_msg = 오류 메시지 반환

---

### 주요 특징:
- **트랜잭션 격리 수준**: READ UNCOMMITTED 사용
- **출력 파라미터**: @result_cd (결과 코드), @result_msg (결과 메시지)
- **반환 값**: 프로젝트 접근 가능 여부(isAccessable: '1' 또는 '0')

이 프로시저는 특정 프로젝트에 대한 회원의 접근 권한을 확인하여, 권한이 있는 경우 해당 정보를 반환합니다.

--- spMakeTaskFinishPlanDate ---
아래는 요청하신 SQL 프로시저 코드의 주요 로직을 정리한 내용입니다:

### 프로시저의 주요 목적
- 프로젝트 ID를 입력받아 해당 프로젝트의 작업 완료 계획 날짜를 자동으로 계산하고 업데이트하는 프로시저입니다.

### 주요 로직 흐름
1. **입력 파라미터 및 출력 변수 선언**
   - `@pProject_id` (프로젝트 ID, 입력)
   - `@result_cd` (결과 코드, 출력)
   - `@result_msg` (결과 메시지, 출력)

2. **트랜잭션 및 격리 수준 설정**
   - 트랜잭션 격리 수준을 `READ UNCOMMITTED`로 설정하여 성능을 최적화합니다.

3. **최상위 노드 처리**
   - `task_dependency` 테이블과 `task` 테이블을 조인하여 프로젝트의 최상위 노드(dependency_cd = '20'인 경우)를 찾습니다.
   - 각 최상위 노드를 처리하며, `task_finish_plan` 테이블의 `start_dt`와 `end_dt`를 업데이트합니다.
   - `start_dt`는 `planed_start_dt`를 그대로 사용하고, `end_dt`는 `working_day`를 고려하여 계산됩니다.

4. **하위 노드 처리**
   - 최상위 노드 처리 후, `task_dependency`와 `task` 테이블을 조인하여 하위 노드들을 처리합니다.
   - `dependency_cd`가 '10'인 경우, 부모 작업의 `start_dt`와 `end_dt`를 하위 작업에 반영합니다.
   - `dependency_cd`가 '20'인 경우, 부모 작업의 `end_dt`에 2일을 더한 날짜를 `start_dt`로 설정하고, `working_day`를 고려하여 `end_dt`를 계산합니다.

5. **트랜잭션 관리**
   - 모든 작업은 트랜잭션 내에서 이루어지며, 오류 발생 시 롤백을 수행합니다.

6. **결과 반환**
   - 성공적으로 작업이 완료되면 `@result_cd`는 0, `@result_msg`는 '성공'으로 설정됩니다.
   - 오류가 발생하면 `@result_cd`는 -1, `@result_msg`는 오류 메시지를 설정합니다.

### 주요 테이블 및 함수
- **테이블**:
   - `project`: 프로젝트 정보
   - `task`: 작업 정보
   - `task_dependency`: 작업 간 의존성 정보
   - `task_finish_plan`: 작업 완료 계획 정보

- **사용자 정의 함수**:
   - `fnGetWorkingDateAdd`: 날짜에 일수를 더하여 계산된 날짜를 반환하는 함수로, 주말 및 비업무일을 고려하여 실제 업무일이 되는 날짜를 반환합니다.

### 요약
이 프로시저는 프로젝트 ID를 입력받아 해당 프로젝트의 작업 완료 계획을 계산하고 업데이트하는 과정을 수행합니다. 최상위 노드부터 하위 노드까지 순차적으로 처리하며, 각 작업의 시작 및 종료 날짜를 의존성 관계를 고려하여 자동으로 계산합니다.

--- spDeleteTasks ---
아래는 요청하신 SQL 프로시저 코드의 주요 로직을 정리한 내용입니다:

### 프로시저명: spDeleteTasks

**목적:** 태스크들을 삭제하는 프로시저

**주요 로직:**

1. **입력 파라미터**
   - `@pTask_ids`: 삭제할 태스크 ID 목록 (CSV 형식)
   - `@pModifier_id`: 수정자 ID
   - `@result_cd`: 결과 코드 (출력)
   - `@result_msg`: 결과 메시지 (출력)

2. **CSV 문자열 파싱**
   - `STRING_SPLIT`을 사용해 CSV 문자열을 개별 ID로 분리
   - 분리된 ID를 `@vTaskList` 테이블에 삽입

3. **유효성 검사**
   - `@vTaskList`에 포함된 태스크 ID 중 존재하지 않는 ID가 있으면 오류 반환
   - 1단계 태스크는 한 번에 하나만 삭제 가능. 여러 1단계 태스크를 삭제하려 하면 오류 반환

4. **태스크 삭제 로직**
   - **1단계 태스크 처리**:
     - 선행, 중심, 후행 태스크 ID 찾기
     - 후행 태스크의 의존성 업데이트 (선행 태스크를 후행 태스크의 의존성으로 설정)
   - **태스크 상태 변경**:
     - `@vResultTaskList`에 삭제 대상 태스크 ID 추가
     - 태스크 상태를 비활성화 (`is_active_cd = '90'`)로 변경
     - 태스크 순서 (`order_no`)를 90000으로 설정
     - 수정자 정보 및 시간 업데이트

5. **관련 데이터 삭제**
   - 태스크 피니시 플랜 (`task_finish_plan`) 삭제
   - 태스크 의존성 (`task_dependency`) 삭제

6. **일지 기록**
   - 삭제된 태스크 ID, 수정자, 결과 코드, 결과 메시지 등을 `use_log` 테이블에 기록

7. **트랜잭션 관리**
   - 트랜잭션 시작
   - 오류 발생 시 롤백 수행
   - 결과 코드 및 메시지 설정

**결과:**
- 성공 시 `@result_cd = 0`, `@result_msg = '성공'`
- 실패 시 `@result_cd = -1`, `@result_msg`에 오류 메시지 설정

이 프로시저는 삭제하려는 태스크가 1단계 태스크인 경우, 해당 태스크를 비활성화하고 관련 의존성을 조정하는 방식으로 삭제를 처리합니다.

--- spUpdateProjectMembers ---
아래는 요청하신 SQL 프로시저 코드의 주요 로직을 정리한 내용입니다:

### 프로시저명: spUpdateProjectMembers

**목적:** 프로젝트의 멤버를 변경하는 로직을 수행하는 프로시저입니다.

**주요 로직:**

1. **입력 파라미터**
   - `@pProject_id`: 프로젝트 ID (INT, NULL 가능)
   - `@pMember_ids`: 변경할 멤버 ID 목록 (CSV 형식의 VARCHAR(MAX), NULL 가능)
   - `@pModifier_id`: 수정자 ID (VARCHAR(7), NULL 가능)
   - `@result_cd`: 결과 코드 (OUTPUT, INT)
   - `@result_msg`: 결과 메시지 (OUTPUT, VARCHAR(200))

2. **프로시저 실행 로직**
   - **프로젝트 유효성 체크**:
     - 프로젝트 ID가 존재하지 않으면 오류 반환
     - 프로젝트 타입이 '90'(템플릿)인 경우 멤버 할당 불가 오류 반환

   - **멤버 ID 처리**:
     - CSV 형식의 `@pMember_ids`를 테이블로 변환 (`@member` 테이블)

   - **멤버 상태 변경**:
     - `@member` 테이블의 멤버 ID들이 이미 프로젝트 멤버로 신청된 상태라면:
       - 상태를 '10'(승인)으로 변경
       - 수정자 정보와 시간을 업데이트
     - `@member` 테이블의 멤버 ID들이 프로젝트 멤버로 존재하지 않으면:
       - 새로운 멤버로 추가 (상태 '10', 현재 시간과 수정자 정보 저장)

   - **기존 멤버 중 `@member` 테이블에 없는 멤버들은 반려 처리**:
     - 상태를 '90'(반려)으로 변경
     - 수정자 정보와 시간을 업데이트

3. **트랜잭션 관리**
   - 전체 로직은 트랜잭션으로 처리되며, 오류 발생 시 롤백 수행
   - 정상 완료 시 결과 코드(@result_cd) 0 반환
   - 오류 발생 시 결과 코드(@result_cd) -1 반환 및 오류 메시지 저장(@result_msg)

4. **로그 기록**
   - 프로젝트 멤버 변경 내역을 로그 테이블(dbo.use_log)에 기록
   - 로그 내용: 프로젝트 ID, 변경된 멤버 목록, 수정자 ID, 결과 코드, 결과 메시지 등

**예외 처리:**
- 프로젝트 ID가 잘못되거나 템플릿 프로젝트일 경우 오류 반환
- 멤버 ID가 중복되거나 유효하지 않을 경우 처리 로직에 따라 상태 변경
- 모든 오류는 트랜잭션으로 관리되어 부분적인 데이터 변경 방지

이 프로시저는 프로젝트 멤버의 상태를 일괄적으로 변경하거나 새로운 멤버를 추가하는 기능을 수행하며, 트랜잭션을 통해 데이터의 일관성과 안정성을 유지합니다.

--- spUpdateCodeMaster ---
아래는 요청하신 SQL 프로시저 코드의 주요 로직을 정리한 것입니다.

### 프로시저명: [dbo].[spUpdateCodeMaster]

#### 주요 로직 요약:

1. **입력 파라미터**
   - `@pGroup_cd` (VARCHAR(8)): 그룹 코드
   - `@pDetail_cd` (VARCHAR(8)): 상세 코드
   - `@pDetail_name` (VARCHAR(50)): 상세 이름 (NULL 가능)
   - `@pIs_active_cd` (VARCHAR(8)): 활성화 코드 (NULL 가능)
   - `@pModifier_id` (VARCHAR(7)): 수정자 ID
   - `@result_cd` (INT): 결과 코드 (출력 파라미터)
   - `@result_msg` (VARCHAR(200)): 결과 메시지 (출력 파라미터)

2. **주요 처리 로직**
   - **시스템 코드 체크**: 그룹 코드가 90000 이상인 경우 (시스템 코드) 수정 작업을 중단하고 오류 메시지를 반환합니다.
   - **데이터 업데이트**: `code_master` 테이블에서 해당하는 그룹 코드와 상세 코드를 찾아서 `detail_name`, `is_active_cd`, `modifier_id`, `modified_at` 컬럼을 업데이트합니다.
      - `detail_name`은 NULL이 전달되면 기존 값을 유지합니다.
      - `is_active_cd`는 NULL이 전달되면 기존 값을 유지합니다.
   - **트랜잭션 관리**: 트랜잭션을 READ UNCOMMITTED 수준으로 설정하여 성능을 최적화합니다.

3. **오류 처리**
   - `UPDATE` 작업 중 오류가 발생하면 `@result_cd`를 -1로, `@result_msg`를 오류 메시지로 설정합니다.

4. **출력 파라미터**
   - `@result_cd`: 0은 성공, 1은 시스템 코드 수정 불가, -1은 오류 발생을 나타냅니다.
   - `@result_msg`: 성공 메시지나 오류 메시지를 반환합니다.

#### 예시 코드 (SQL 쿼리)
```sql
DECLARE @result_cd INT,
        @result_msg VARCHAR(100);

EXEC [dbo].[spUpdateCodeMaster]
    @pGroup_cd = '99999',
    @pDetail_cd = '11',
    @pDetail_name = NULL,
    @pIs_active_cd = '90',
    @pModifier_id = 1,
    @result_cd = @result_cd OUTPUT,
    @result_msg = @result_msg OUTPUT;

SELECT @result_cd AS result_cd,
       @result_msg AS result_msg;
```

#### 예시 결과
- 정상적인 경우: `@result_cd = 0`, `@result_msg = '성공'`
- 시스템 코드인 경우: `@result_cd = 1`, `@result_msg = '시스템 코드는 수정 할 수 없습니다.'`
- 오류 발생 시: `@result_cd = -1`, `@result_msg = '오류 메시지'`

이 프로시저는 코드 마스터 테이블에서 특정 조건에 따라 데이터를 업데이트하고, 결과에 따라 적절한 메시지를 반환하는 역할을 합니다.

--- spUpdateProjectOwners ---
아래는 요청하신 SQL 프로시저 코드의 주요 로직을 정리한 내용입니다:

### 프로시저명: [dbo].[spUpdateProjectOwners]

**목적:** 프로젝트의 마케터(owner)를 변경하는 프로시저입니다.

**주요 로직:**

1. **입력 파라미터:**
   - `@pProject_id` (프로젝트 ID)
   - `@pMember_ids` (CSV 형식의 멤버 ID 목록)
   - `@pModifier_id` (수정자 ID)
   - `@result_cd` (결과 코드, OUT 매개변수)
   - `@result_msg` (결과 메시지, OUT 매개변수)

2. **프로시저 실행 로직:**

   - **트랜잭션 관리:** 트랜잭션을 시작하고, 오류 발생 시 롤백 수행.

   - **프로젝트 유효성 체크:**
     - 프로젝트 ID가 존재하지 않으면 오류 반환.
     - 프로젝트 유형이 '90'(템플릿)인 경우 마케터 할당 불가 오류 반환.

   - **멤버 ID 처리:**
     - CSV 형식의 `@pMember_ids`를 테이블로 분리하여 고유한 멤버 ID 목록을 생성.

   - **마케터 변경 로직:**
     - 기존 프로젝트 소유자 중 요청된 멤버가 있다면 활성화 상태를 유지하고 수정자 및 시간 업데이트.
     - 요청된 멤버가 없으면 새롭게 삽입.
     - 요청되지 않은 기존 멤버는 비활성화.

   - **결과 반환:**
     - 성공 시 `@result_cd = 0`, `@result_msg = '성공'` 반환.
     - 실패 시 `@result_cd = -1`, `@result_msg`에 오류 메시지 반환.

3. **로깅:**
   - 프로시저 실행 내역을 `dbo.use_log` 테이블에 기록.

**예외 처리:**
- 오류 발생 시 트랜잭션 롤백 수행.
- 다양한 오류 조건에 대한 검사를 통해 안정성을 보장.

**결론:**
이 프로시저는 특정 프로젝트의 마케터를 변경하는 데 필요한 모든 검증과 데이터를 처리하는 로직을 포함하고 있습니다.

--- spUpdateForcedFinishForProject ---
아래는 요청하신 SQL 프로시저 코드의 주요 로직을 정리한 것입니다.

### 프로시저명: [dbo].[spUpdateForcedFinishForProject]

#### 주요 로직:

1. **입력 파라미터**
   - `@pProject_id` (프로젝트 ID)
   - `@pForced_end_reason` (강제 종료 사유)
   - `@pExclude_statistics` (통계 제외 여부, 1로 설정 시 통계 제외)
   - `@pModifier_id` (수정자 ID)

2. **출력 파라미터**
   - `@result_cd` (결과 코드, 0은 성공, -1은 실패)
   - `@result_msg` (결과 메시지)

3. **주요 처리 로직**
   - `P.forced_end_dt`를 현재 날짜로 설정
   - `P.forced_end_reason`을 입력값으로 설정
   - `P.project_type_cd`를 '20'(테스트 프로젝트)으로 설정 (통계 제외)
   - `P.modifier_id`와 `P.modified_at`을 설정

4. **트랜잭션 및 오류 처리**
   - 트랜잭션 격리 수준을 `READ UNCOMMITTED`로 설정
   - `UPDATE` 문으로 프로젝트 정보를 수정
   - 성공 시 `@result_cd = 0`, 실패 시 `@result_cd = -1` 설정
   - 오류 발생 시 `@result_msg`에 오류 메시지 저장

#### 예시 코드 (SQL 쿼리):
```sql
DECLARE @result_cd INT, @result_msg VARCHAR(100);

EXEC [dbo].[spUpdateForcedFinishForProject]
    @pProject_id = 2,
    @pForced_end_reason = '조기 종료 요청에 따라 강제 종료 처리',
    @pModifier_id = 1,
    @result_cd = @result_cd OUTPUT,
    @result_msg = @result_msg OUTPUT;

SELECT @result_cd AS result_cd, @result_msg AS result_msg;
```

#### 예시 결과:
- 성공 시: `@result_cd = 0`, `@result_msg = '성공'`
- 실패 시: `@result_cd = -1`, `@result_msg`는 오류 메시지

이 프로시저는 프로젝트의 강제 종료 처리를 수행하며, 통계 제외 여부와 종료 사유 등을 설정할 수 있습니다.

--- spGetDelayedTaskList ---
아래는 요청하신 SQL 프로시저 코드의 주요 로직을 정리한 내용입니다:

### 프로시저명: spGetDelayedTaskList

#### 주요 목적:
- 태스크 지연 리스트를 조회하여 출력

#### 입력 파라미터:
- @pCreator_id (VARCHAR(7)): 사용자 ID, 기본값 NULL

#### 출력 파라미터:
- @result_cd (INT): 결과 코드
- @result_msg (VARCHAR(200)): 결과 메시지

#### 주요 로직:
1. 트랜잭션 설정:
   - 트랜잭션 격리 수준을 READ UNCOMMITTED로 설정
   - NOCOUNT ON으로 설정하여 SELECT 문이 영향을 주는 행의 수를 반환하지 않음

2. 현재 날짜를 문자열 형식으로 변환:
   - @vNow_dt에 현재 날짜를 'YYYY-MM-DD' 형식으로 저장

3. 주요 데이터 조회:
   - 프로젝트(P), 태스크(T), 태스크 완료 계획(TFA), 태스크 완료 계획(TFP) 테이블을 조회
   - 각 태스크의 실제 시작일과 계획된 시작일, 종료일을 계산하여 지연일을 산정
   - 지연된 태스크 목록을 반환

4. 태스크 소유자, 프로젝트 소유자, 리더 정보를 조회:
   - 태스크 소유자, 프로젝트 소유자, 리더의 이메일과 ID를 조회하여 반환

5. 예외 처리:
   - TRY-CATCH 블록을 사용하여 오류 발생 시 롤백 수행
   - 오류 발생 시 @result_cd를 -1로, @result_msg를 오류 메시지로 설정

6. 로그 기록:
   - 사용 로그를 기록하는 INSERT 문으로 프로시저 실행 내역 저장

#### 반환 값:
- 결과 코드(@result_cd)와 결과 메시지(@result_msg)를 출력

#### 주요 활용:
- 프로젝트 관리 시스템에서 태스크 지연을 모니터링하고, 지연된 태스크를 조회할 때 사용

--- spUpdateProjectApplicantsStatus ---
아래는 요청하신 SQL 프로시저 코드의 주요 로직을 정리한 내용입니다.

### 프로시저명: spUpdateProjectApplicantsStatus

**목적:** 프로젝트에 참여 상태를 업데이트 한다.

**주요 로직:**

1. **파라미터 유효성 체크**
   - 프로젝트 ID(@pProject_id)가 유효한지 확인
     - 존재하지 않으면 오류 반환
   - 회원 ID(@pMember_id)가 유효한지 확인
     - 존재하지 않으면 오류 반환

2. **상태 업데이트**
   - 프로젝트 참여 상태를 지정된 값(@pStatus_cd)으로 업데이트
     - 성공 시 결과 코드 0 반환
     - 실패 시 결과 코드 -1 반환

3. **트랜잭션 관리**
   - 트랜잭션 격리 수준을 READ UNCOMMITTED로 설정
   - UPDATE 문 실행
   - 성공 및 실패 시 결과 메시지 설정

**결과 반환:**
- 성공 시 @result_cd = 0, @result_msg = '성공'
- 실패 시 @result_cd = -1, @result_msg = 오류 메시지

**예시 실행 코드:**
```sql
DECLARE @result_cd INT, @result_msg VARCHAR(100);

EXEC [spUpdateProjectApplicantsStatus]
    @pProject_id = 25080009,
    @pMember_id = '2400001',
    @pStatus_cd = '10',
    @result_cd = @result_cd OUTPUT,
    @result_msg = @result_msg OUTPUT;

SELECT @result_cd as result_cd, @result_msg as result_msg;
```

**주요 기능 요약:**
- 프로젝트 참여 상태를 지정 값으로 업데이트
- 유효하지 않은 프로젝트나 회원일 경우 오류 처리
- 트랜잭션을 이용한 데이터 일관성 유지

--- spGetDelayedStartTaskList ---
아래는 요청하신 SQL 프로시저 코드의 주요 로직을 정리한 내용입니다:

### 프로시저명: spGetDelayedStartTaskList

**목적:** 태스크 착수 지연 리스트를 조회하는 프로시저.

**주요 로직:**

1. **입력 파라미터 및 출력 변수 정의**
   - 입력 파라미터: @pCreator_id (VARCHAR(7), NULL 가능)
   - 출력 파라미터: @result_cd (INT), @result_msg (VARCHAR(200))

2. **트랜잭션 및 격리 수준 설정**
   - 트랜잭션 격리 수준을 READ UNCOMMITTED로 설정.
   - NOCOUNT ON으로 결과 행 수 반환을 억제.

3. **현재 날짜 변수 설정**
   - 현재 날짜를 'YYYY-MM-DD' 형식의 문자열로 저장 (@vNow_dt).

4. **착수 지연 태스크 조회**
   - task, project, task_finish_plan 테이블을 조인하여 다음 조건을 만족하는 레코드 선택:
     - task.status_cd = '10' (대기 상태)
     - task_finish_plan.plan_cd = '20'
     - task_finish_plan.start_dt < 현재 날짜 (@vNow_dt)
     - project.forced_end_dt IS NULL
     - project.project_type_cd = '10'

5. **태스크 및 프로젝트 소유자 정보 조회**
   - task_owner 및 project_owner 테이블을 각각 조인하여 소유자 ID와 이메일 정보를 추출.
   - STRING_AGG를 사용하여 소유자 ID와 이메일을 쉼표로 구분된 문자열로 결합.

6. **결과 처리**
   - 성공 시: @result_cd = 0, @result_msg = '성공'
   - 실패 시: 에러 메시지와 세버리티를 출력 변수에 저장.

7. **로그 기록**
   - 프로시저 실행 내역을 use_log 테이블에 기록.
   - 입력 파라미터, 결과 코드, 결과 메시지 등을 포함하여 로그 저장.

**주요 테이블 및 컬럼:**
- task: project_id, task_id, task_name, status_cd, is_active_cd
- project: project_id, project_name, forced_end_dt, project_type_cd
- task_finish_plan: task_id, plan_cd, start_dt, end_dt
- task_owner: task_id, member_id, is_active_cd
- project_owner: project_id, member_id, is_active_cd
- hr_master: EMP_ID, MOIN_EMAIL

**주요 기능:**
- 계획 시작일정이 현재 날짜보다 지난 태스크 중 착수가 지연된 태스크를 조회.
- 태스크 및 프로젝트 소유자 정보를 함께 조회하여 알림 전송용으로 사용.
- 결과 코드와 메시지를 출력 파라미터로 반환하여 성공/실패 결과를 전달.

--- spUpdateTask ---
이 SQL 프로시저의 주요 로직을 요약하면 다음과 같습니다:

### 1. **매개변수 처리**
- 프로시저는 여러 매개변수를 받아 업데이트할 태스크 정보를 처리합니다.
- `@pTask_id`, `@pTask_name`, `@pStatus_cd`, `@pIs_output_need`, `@pStd_workding_day`, `@pMember_ids`, `@pModifier_id` 등의 매개변수를 받으며, 각각의 값이 유효한지 검사합니다.

### 2. **태스크 정보 검증**
- 태스크 ID가 제공되지 않으면 오류를 반환합니다.
- 완료된 태스크(상태 코드가 '90')는 수정할 수 없으므로 오류를 반환합니다.
- 프로젝트 유형이 '90'(템플릿)이 아닌 경우 표준 작업일을 직접 설정할 수 없으므로 오류를 반환합니다.

### 3. **담당자 목록 파싱 및 검증**
- `@pMember_ids`는 CSV 형식으로 제공된 담당자 목록을 파싱하여 테이블 `@MemberList`에 삽입합니다.
- 파싱된 담당자 목록이 유효한 회원인지 확인하고, 존재하지 않는 회원이 있으면 오류를 반환합니다.

### 4. **태스크 및 담당자 정보 업데이트**
- 태스크 정보 업데이트:
   - `task_name`, `status_cd`, `is_output_need`, `modifier_id`, `modified_at` 컬럼을 각각의 매개변수 값으로 설정합니다.
   - `std_workding_day`는 프로젝트 유형이 '90'(템플릿)인 경우에만 설정할 수 있습니다.

- 담당자 정보 업데이트:
   - 기존 담당자와 새로운 담당자 목록을 비교하여:
      - 신규 담당자는 `task_owner` 테이블에 삽입합니다.
      - 기존 담당자 중 제거된 담당자는 `is_active_cd`를 '90'(비활성)으로 설정합니다.
      - 변경된 담당자에 대해 `modifier_id`와 `modified_at`을 업데이트합니다.

### 5. **오류 처리**
- 프로시저 내에서 발생할 수 있는 오류를 처리합니다.
- 오류가 발생하면 트랜잭션을 롤백하고, 오류 메시지를 반환합니다.

### 6. **로깅**
- 프로시저의 실행 내역을 로깅합니다.
- 실행 결과와 관련된 정보를 `use_log` 테이블에 삽입합니다.

### 주요 기능 요약
- 태스크의 기본 정보 및 담당자를 업데이트하고, 관련된 유효성 검사를 수행합니다.
- 담당자 목록을 CSV 형식으로 받아 파싱하고, 이를 기반으로 담당자 정보를 동적으로 업데이트합니다.
- 프로젝트 유형에 따라 표준 작업일을 설정할 수 있으며, 완료된 태스크는 수정할 수 없습니다.

이 프로시저는 태스크 관리 시스템에서 태스크의 기본적인 CRUD 기능을 제공하며, 데이터의 정합성과 무결성을 유지하기 위한 다양한 검증 절차를 포함하고 있습니다.

--- spUpdateTaskPlanDate ---
다음은 요청된 SQL 프로시저 코드의 주요 로직을 정리한 것입니다:

### 프로시저명: spUpdateTaskPlanDate

#### 주요 기능: 태스크의 계획/실제 시작 또는 종료일 업데이트

---

### 주요 로직 요약:

1. **파라미터 유효성 검사**
   - `@pProject_id`, `@pTask_id`, `@pModifier_id`가 NULL일 경우 오류 반환
   - 프로젝트 및 태스크가 존재하지 않으면 오류 반환
   - `@pStart_dt`와 `@pEnd_dt`가 모두 NULL일 경우 오류 반환

2. **지연(40) 처리**
   - 지연 등록 시, 시작일은 실제 시작일로 설정
   - 지연 종료일이 이전 지연 종료일보다 작거나 같을 경우 오류 반환
   - 착수되지 않은 태스크에 대해 지연 등록 시 오류 반환

3. **일정 데이터 삽입 및 수정**
   - 지연인 경우: `task_finish_plan` 테이블에 지연 정보 삽입
   - 지연이 아닌 경우: 기존 일정 정보 수정
   - 일정 수정 시, 상위/하위 일정의 기간 범위를 벗어날 경우 오류 반환

4. **상위-하위 일정 간 기간 동기화**
   - 상위 일정 변경 시, 하위 일정의 시작 및 종료일 조정

5. **일정 변경 후 디펜던시 태스크 조정**
   - 일정이 변경된 태스크에 대해 디펜던시 태스크들의 일정 재계산(쉬프팅) 수행
   - 개별 태스크이거나 2단계 태스크인 경우, 쉬프팅 절차 생략

6. **로그 기록**
   - 모든 실행 내역을 `use_log` 테이블에 기록

---

### 주요 특징:
- **트랜잭션 관리**: 모든 데이터 변경은 트랜잭션으로 관리되며, 오류 발생 시 롤백 수행
- **유효성 검사**: 다양한 조건에 대한 유효성 검사를 통해 데이터 무결성 유지
- **상위-하위 일정 동기화**: 상위 일정의 변경이 하위 일정에 미치는 영향을 고려한 설계
- **디펜던시 태스크 조정**: 일정 변경이 디펜던시 태스크에 미치는 영향을 고려한 추가적인 로직 처리

--- spUpdateTaskState ---
이 SQL 프로시저의 주요 로직을 요약하면 다음과 같습니다:

1. **파라미터 검증**
   - `pTask_id`와 `pState_cd`의 유효성을 검사합니다.
   - `pState_cd`가 '20'(착수) 또는 '90'(완료) 중 하나인지 확인합니다.

2. **상태 변경 로직**
   - **착수('20') 처리**:
     - `task_finish_plan` 테이블에서 `start_dt`를 현재 날짜로 업데이트합니다.
     - `end_dt`를 `start_dt`에 `working_day`를 더한 날짜로 계산합니다.
     - `task` 테이블에서 `status_cd`를 '20'으로 업데이트합니다.

   - **완료('90') 처리**:
     - `task_finish_plan` 테이블에서 `end_dt`를 현재 날짜로 업데이트합니다.
     - `working_day`를 `start_dt`와 `end_dt` 사이의 근무일수로 재계산합니다.
     - `task` 테이블에서 `status_cd`를 '90'으로 업데이트합니다.

3. **디펜던시(의존성) 검사**
   - 완료 처리 시, 하위 태스크가 모두 완료되었는지 확인합니다.
   - 선행 태스크가 완료되었는지 확인합니다.

4. **부모 태스크 일정 조정**
   - 완료 처리 후, 부모 태스크의 `end_dt`가 자식 태스크보다 앞서는 경우, 부모의 `end_dt`를 자식과 동일하게 업데이트합니다.

5. **일정 쉬프팅**
   - `spUpdateDateByShifting` 프로시저를 호출하여 변경된 일정을 기반으로 후속 일정을 조정합니다.

6. **오류 처리**
   - 트랜잭션을 사용하여 오류 발생 시 변경 사항을 롤백합니다.
   - 오류 메시지를 반환합니다.

이 프로시저는 태스크의 착수 및 완료 상태를 관리하고, 이에 따른 일정 업데이트를 수행하는 역할을 합니다.

--- spUpdateProjectKickOff ---
아래는 요청하신 SQL 프로시저 코드의 주요 로직을 정리한 내용입니다:

### 프로시저명: [dbo].[spUpdateProjectKickOff]

#### 주요 로직:

1. **입력 파라미터 및 출력 변수 정의**
   - 입력 파라미터: `@pProject_id` (프로젝트 ID), `@pProject_owner_id` (프로젝트 소유자 ID)
   - 출력 변수: `@result_cd` (결과 코드), `@result_msg` (결과 메시지)

2. **프로젝트 소유자 검증**
   - `dbo.project_owner` 테이블에서 `@pProject_owner_id`가 `@pProject_id`의 소유자인지 확인
   - 소유자가 아닌 경우:
     - `@result_cd` = 1
     - `@result_msg` = "프로젝트 오너가 아닙니다. 프로젝트 오너 그룹에 속한 사람만 킥오프 가능 합니다."
     - 프로시저 종료

3. **킥오프 가능 상태 검증**
   - `dbo.fnGetStateForKickOff` 함수로 `@pProject_id`의 킥오프 가능 상태 확인
   - 상태가 10이 아닌 경우:
     - `@result_cd` = 1
     - `@result_msg` = "킥오프 가능한 조건이 아닙니다. [" + 오류 메시지 + "]"
     - 프로시저 종료

4. **킥오프 로직 실행**
   - `task_finish_plan` 테이블에서 `@pProject_id`의 계획 데이터를 읽어와 실제 일정으로 삽입
   - `project` 테이블에서 `@pProject_id`의 킥오프 상태를 '10'(착수)으로 업데이트
   - `planed_end_dt`와 `planed_working_day` 계산 및 업데이트

5. **트랜잭션 관리**
   - 전체 로직을 트랜잭션으로 관리하여 오류 발생 시 롤백 수행
   - 성공 시:
     - `@result_cd` = 0
     - `@result_msg` = "성공"
   - 실패 시:
     - `@result_cd` = -1
     - `@result_msg` = 오류 메시지

### 주요 기능 요약:
- 프로젝트 소유자 권한 검증
- 킥오프 가능 상태 검증
- 계획 일정을 실제 일정으로 변환
- 프로젝트 킥오프 상태 업데이트
- 트랜잭션 기반의 안정적인 데이터 처리

--- spUpdateTaskActualDate ---
아래는 요청하신 SQL 프로시저 코드의 주요 로직을 정리한 내용입니다.

### 프로시저의 주요 목적
- 전체 1뎁스의 실제 일정 재계산을 수행하는 프로시저입니다.

### 주요 로직 요약
1. **입력 파라미터 및 출력 변수 선언**
   - 입력 파라미터: `@pProject_id` (프로젝트 ID)
   - 출력 파라미터: `@result_cd` (결과 코드), `@result_msg` (결과 메시지)

2. **트랜잭션 및 오류 처리**
   - 트랜잭션 격리 수준을 `READ UNCOMMITTED`로 설정.
   - `BEGIN TRY` 및 `BEGIN CATCH` 블록을 사용하여 오류 처리.

3. **워킹데이(WORKING_DAY) 보정 (시작 전)**
   - `task_finish_plan` 테이블에서 `project_id`와 `plan_cd`를 조건으로 `working_day`를 계산하여 업데이트.
   - `fnCalcWorkingDay` 함수를 사용하여 시작일과 종료일 사이의 워킹데이를 계산.

4. **루트 태스크 처리**
   - `task_dependency` 테이블에서 `project_id`와 `dependency_cd`를 조건으로 루트 태스크를 조회.
   - 루트 태스크를 임시 테이블 `@vRootTask`에 삽입.

5. **일정 재계산 루프**
   - 루트 태스크부터 시작하여 재귀적으로 의존성을 따라가며 일정을 계산.
   - `DependencyChain` CTE를 사용하여 의존성 체인을 처리.
   - 각 태스크의 시작일과 종료일을 `fnGetWorkingDateAdd` 함수로 계산하여 업데이트.

6. **워킹데이 보정 (완료 후)**
   - 일정 재계산이 완료된 후 `task_finish_plan` 테이블의 `working_day`를 다시 계산하여 업데이트.

7. **결과 반환**
   - 성공 시 `@result_cd`를 0으로, 실패 시 -1로 설정.
   - 결과 메시지는 `@result_msg`에 저장.

### 주요 기능 정리
- **일정 재계산**: 루트 태스크부터 시작하여 의존성을 따라가며 시작일과 종료일을 계산.
- **워킹데이 계산**: 시작일과 종료일 사이의 워킹데이를 계산하여 `working_day` 컬럼을 업데이트.
- **트랜잭션 관리**: 트랜잭션을 사용하여 데이터 일관성을 유지하고, 오류 발생 시 롤백 수행.

이 프로시저는 특정 프로젝트 ID에 대한 전체 1뎁스의 실제 일정을 재계산하는 과정을 수행합니다.

--- spGetCodeMasterForBrand ---
아래는 요청하신 SQL 프로시저 코드의 주요 로직을 정리한 내용입니다.

### 프로시저명: [dbo].[spGetCodeMasterForBrand]

#### 주요 로직 요약:

1. **입력 파라미터**
   - `@pBrand_type`: 브랜드 유형을 나타내는 문자열 (예: 'NB', 'FB')

2. **출력 파라미터**
   - `@result_cd`: 프로시저 실행 결과 코드
   - `@result_msg`: 프로시저 실행 결과 메시지

3. **프로시저 로직**
   - `NB` (일반 브랜드) 요청 시:
     - `IF_SAP_NPD_BRAND` 테이블에서 `BRANDTYPE = '200'`인 레코드 조회
     - 결과는 `BRANDCODE`와 `BRANDNAME` 반환
     - 성공 시 `@result_cd = 0`, `@result_msg = '성공'`

   - `FB` (패밀리 브랜드) 요청 시:
     - `IF_SAP_NPD_BRAND` 테이블에서 `BRANDTYPE = '100'`인 레코드 조회
     - 결과는 `BRANDCODE`와 `BRANDNAME` 반환
     - 성공 시 `@result_cd = 0`, `@result_msg = '성공'`

   - 잘못된 `@pBrand_type` 입력 시:
     - `@result_cd = 1`, `@result_msg = '정의되지 않은 브랜드 타입'`

4. **트랜잭션 및 오류 처리**
   - 트랜잭션 격리 수준은 `READ UNCOMMITTED`
   - 오류 발생 시 `@result_cd = -1`, `@result_msg = ERROR_MESSAGE()`

#### 예시 실행 코드:
```sql
-- 일반('NB') 브랜드 실행 예시
DECLARE @result_cd INT, @result_msg VARCHAR(100);
EXEC [dbo].[spGetCodeMasterForBrand] @pBrand_type = 'NB', @result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT;
SELECT @result_cd as result_cd, @result_msg as result_msg;

-- 패밀리('FB') 브랜드 실행 예시
DECLARE @result_cd INT, @result_msg VARCHAR(100);
EXEC [dbo].[spGetCodeMasterForBrand] @pBrand_type = 'FB', @result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT;
SELECT @result_cd as result_cd, @result_msg as result_msg;
```

#### 주요 특징:
- **두 가지 브랜드 유형** (`NB`, `FB`)을 처리하며, 각각의 유형에 따라 다른 조건으로 데이터를 조회합니다.
- 출력 파라미터를 통해 결과 코드와 메시지를 반환합니다.
- 오류 발생 시에는 `@result_cd`에 `-1`을 반환하고, 오류 메시지는 `@result_msg`에 저장됩니다.
