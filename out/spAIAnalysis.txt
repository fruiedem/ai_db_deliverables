=== AI Analysis of Stored Procedures ===
Generated at: 8/21/2025, 9:54:58 AM
Total procedures analyzed: 70

--- spBatchTransferHolidayInfo ---
Analysis Time: 8/21/2025, 9:33:42 AM
AI Analysis:
아래는 요청한 프로시저 코드를 최대한 요약하고 정리한 내용입니다.

---

### 프로시저 `spBatchTransferHolidayInfo` 요약

**작성자:** Jay Kwon
**작성일:** 2025-08-06
**목적:** 뷰를 참조하여 로컬 디비의 휴일 데이터를 동기화한다 (10년치).

---

### 주요 내용

1. **트랜잭션 설정**
   - 트랜잭션 격리 수준을 `READ UNCOMMITTED`로 설정.
   - `@result_cd`, `@result_msg`, `@vSeverity` 등의 변수를 선언하여 결과 처리를 용이하게 함.

2. **휴일 데이터 처리**
   - `dbo.calendar` 테이블을 먼저 트렁케이트(삭제)한 뒤, 2024년 1월 1일부터 2034년 12월 31일까지의 주말 데이터를 재생성.
   - 주말(토, 일) 데이터를 `dbo.calendar`에 삽입.
   - 뷰 `dbo.VW_NPD_HolidayCalendar`에서 휴일 데이터를 읽어 `target_holiday` 테이블에 임시 저장.
   - `dbo.calendar`와 `target_holiday`를 조인하여 휴일 데이터를 동기화.

3. **오류 처리**
   - `BEGIN TRY`와 `BEGIN CATCH` 블록을 사용하여 오류 발생 시 롤백 수행.
   - 오류 발생 시 `@result_cd`, `@result_msg`, `@vSeverity`를 적절히 설정.

4. **로그 기록**
   - 동기화 결과와 관련된 로그를 `dbo.use_log` 테이블에 기록.

---

### 주요 변경 사항
- `OUT` 파라미터를 제거하고, 프로시저 실행 결과를 `@result_cd`, `@result_msg` 등을 통해 반환.
- 휴일 데이터를 동기화하는 범위를 10년(2024-2034)으로 명시.
- 주말 데이터를 `dbo.calendar`에 미리 재생성하는 절차 추가.

이렇게 정리하면 프로시저의 주요 목적과 흐름을 명확히 이해할 수 있습니다.

--- spBatchTransferDeptMaster ---
Analysis Time: 8/21/2025, 9:33:52 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 내용입니다.

### 프로시저 `spBatchTransferDeptMaster` 요약

**작성자:** Jay Kwon
**작성일:** 2025-08-06
**목적:** 부서 정보를 동기화한다.

---

### 주요 내용 요약

1. **테이블 구조 정리**
   - `dbo.dept_master` 테이블을 비우고, `dbo.VW_NPD_orgDeptMaster` 뷰의 데이터를 삽입합니다.
   - `DEPT_CODE`, `DEPT_NAME`, `PARENT_DEPT_CODE` 컬럼을 복사하며, `creator_id`는 'system', `created_at`은 현재 시간으로 설정됩니다.

2. **트랜잭션 처리**
   - `BEGIN TRAN`과 `COMMIT TRAN`을 사용하여 데이터 삽입을 원자적으로 처리합니다.
   - 오류 발생 시 `ROLLBACK TRAN`으로 변경 사항을 취소합니다.

3. **오류 처리**
   - 오류가 발생하면 `result_cd`를 -1로, `result_msg`를 오류 메시지로 설정합니다.
   - 오류의 심각성(`ERROR_SEVERITY()`)도 기록합니다.

4. **로그 기록**
   - `dbo.use_log` 테이블에 호출 정보, 심각성, 결과 코드, 결과 메시지를 기록합니다.
   - `caller_id`는 'system', `proc_name`은 '[spTransferDeptMaster]'로 고정되어 있습니다.

---

### 핵심 기능 정리

- **주요 기능:** `dbo.dept_master` 테이블을 `dbo.VW_NPD_orgDeptMaster`의 최신 데이터로 동기화합니다.
- **동기화 절차:** 기존 테이블을 비우고, 새 데이터를 삽입하며, 모든 변경 사항을 트랜잭션으로 관리합니다.
- **모니터링:** 오류 발생 시 상세 정보를 기록하여 문제를 쉽게 추적할 수 있습니다.

이 프로시저는 부서 정보의 안정성과 일관성을 유지하기 위해 설계되었습니다.

--- spBatchTransferHreMaster ---
Analysis Time: 8/21/2025, 9:34:01 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 내용입니다.

### 프로시저 `spBatchTransferHreMaster` 요약

**작성자**: Jay Kwon
**작성일**: 2025-08-06
**목적**: 회원 정보를 동기화한다. (뷰 → 로컬), 매일 00:20에 수행
**요청사항**: 8/12 IS팀 요청에 의해 아웃풋 파라미터 제거

---

### 주요 로직

1. **트랜잭션 설정**
   - 트랜잭션 격리 수준을 `READ UNCOMMITTED`로 설정.
   - `@result_cd`, `@result_msg`, `@vSeverity` 등의 변수 선언.

2. **목표 테이블 `@target_hrm` 생성**
   - `hr_master`와 `VW_NPD_hreMaster`의 구조를 기반으로 퇴사자 보관을 위한 임시 테이블 생성.

3. **데이터 동기화**
   - `VW_NPD_hreMaster`와 `hr_master`를 비교하여 변경된 회원 정보를 `@target_hrm`에 저장.
   - `hr_master` 테이블을 비운 후 `@target_hrm`의 데이터를 다시 삽입.

4. **로그 기록**
   - 동기화 결과에 따라 로그 테이블 `use_log`에 기록을 남김.

---

### 주요 변경 사항
- **아웃풋 파라미터 제거**: 8/12 IS팀 요청에 따라 결과 메시지를 아웃풋 파라미터 대신 로그 테이블에 기록.
- **트랜잭션 관리**: 명시적인 트랜잭션 관리를 통해 데이터 일관성 유지.
- **임시 테이블 사용**: 데이터 동기화 과정에서 변경 사항을 보관하기 위한 임시 테이블 `@target_hrm` 사용.

이 프로시저는 매일 00:20에 실행되며, 회원 정보의 변경을 동기화하는 역할을 합니다.

--- spInsertProjectMemberByTemplate ---
Analysis Time: 8/21/2025, 9:34:21 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 결과입니다.

### 프로시저 `spInsertProjectMemberByTemplate` 요약

**목적**: 담당자 일괄 인서트

**작성자**: JayKwon

**작성일**: 2025-05-23

---

### 코드 정리

```sql
CREATE PROCEDURE [dbo].[spInsertProjectMemberByTemplate]
    @task_template dbo.project_applicant_template READONLY,
    @result_cd INT OUTPUT,
    @result_msg VARCHAR(200) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

    BEGIN TRY
        BEGIN TRAN
            INSERT INTO dbo.project_member (
                project_id,
                member_id,
                status_cd,
                creator_id,
                created_at,
                modifier_id,
                modified_at
            )
            SELECT
                TT.project_id,
                TT.member_id,
                '10',  -- 90102 10:승인, 20:신청, 90:반려
                TT.creator_id,
                GETDATE(),
                null,
                null
            FROM
                @task_template AS TT
            LEFT JOIN
                project_member AS PM WITH (NOLOCK)
            ON
                TT.project_id = PM.project_id
            AND
                TT.member_id = PM.member_id
            WHERE
                PM.member_id IS NULL;  -- 신청한 기록이 있는 사람이 있으면 제외

            COMMIT TRAN;
            SET @result_cd = 0;
            SET @result_msg = '성공';
        END TRY
        BEGIN CATCH
            ROLLBACK TRAN;
            SET @result_cd = -1;
            SET @result_msg = ERROR_MESSAGE();
        END CATCH
END
```

---

### 코드 설명

1. **트랜잭션 설정**
   - `READ UNCOMMITTED`로 설정하여 성능을 최적화
   - `BEGIN TRAN`과 `COMMIT TRAN`으로 트랜잭션 관리

2. **데이터 삽입**
   - `@task_template` 테이블에서 데이터를 읽어 `project_member` 테이블에 삽입
   - `status_cd`는 기본값으로 '10'(승인)을 사용
   - `created_at`은 현재 시간(`GETDATE()`)으로 설정
   - 기존에 신청한 기록이 있는 경우 삽입되지 않도록 `LEFT JOIN` 조건으로 필터링

3. **오류 처리**
   - `BEGIN TRY`와 `BEGIN CATCH` 블록으로 오류 처리
   - 오류 발생 시 트랜잭션을 롤백하고 `@result_cd`와 `@result_msg`를 설정

---

### 사용 예시

```sql
DECLARE @tvp dbo.project_applicant_template,
        @result_cd INT,
        @result_msg VARCHAR(100);

INSERT INTO @tvp (project_id, member_id, creator_id)
VALUES (2, '2400000', '2400000'),
        (2, '2400001', '2400000'),
        (2, '2400002', '2400000'),
        (2, '2400003', '2400000'),
        (2, '2400004', '2400000'),
        (2, '2400005', '2400000'),
        (2, '2400006', '2400000'),
        (2, '2400007', '2400000'),
        (2, '2400008', '2400000'),
        (2, '2400009', '2400000');

EXEC [dbo].[spInsertProjectMemberByTemplate]
    @task_template = @tvp,
    @result_cd = @result_cd OUTPUT,
    @result_msg = @result_msg OUTPUT;

SELECT @result_cd AS result_cd, @result_msg AS result_msg;
```

---

### 정리

- **주요 기능**: `project_member` 테이블에 일괄적으로 데이터를 삽입
- **중요한 점**: 이미 신청한 기록이 있는 경우 중복 삽입 방지
- **결과**: 성공 시 `@result_cd = 0`, 실패 시 `@result_cd = -1` 반환

--- spInsertProjectTaskTemplate ---
Analysis Time: 8/21/2025, 9:34:42 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 내용입니다.

---

### 프로시저 요약: **spInsertProjectTaskTemplate**

#### 목적:
프로젝트 작업 템플릿을 데이터베이스에 삽입하거나 업데이트하는 프로시저.

---

### 주요 기능:

1. **입력 파라미터**
   - `@task_template`: 작업 템플릿 데이터를 담은 테이블 형식의 입력 파라미터.
   - `@result_cd`, `@result_msg`: 결과 코드 및 메시지를 출력용으로 사용.

2. **주요 처리 로직**
   - 프로젝트 ID가 유효한지 확인.
   - 작업(`task`) 및 작업 의존성(`task_dependency`) 테이블에 데이터 삽입.
   - 작업 완료 계획(`task_finish_plan`) 테이블에 표준 계획 관련 데이터 생성.

3. **주요 테이블 구조**
   - **`@task_template`**: 작업 이름, 프로젝트 ID, 순서, 상태, 활성화 여부 등.
   - **`task`**: 작업 기본 정보.
   - **`task_dependency`**: 작업 간 의존성 관계.
   - **`task_finish_plan`**: 작업 완료 계획 (표준, 계획, 실제, 지연 등).

4. **주요 기능**
   - 작업 및 의존성 정보 삽입.
   - 작업 완료 계획 생성 (표준 계획 기준).
   - 오류 발생 시 롤백 및 로깅.

---

### 코드 정리:

```sql
CREATE PROCEDURE [dbo].[spInsertProjectTaskTemplate]
    @task_template dbo.task_template READONLY,
    @result_cd INT OUTPUT,
    @result_msg VARCHAR(200) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

    DECLARE @creator_id VARCHAR(7) = NULL;
    DECLARE @project_id INT = NULL;
    DECLARE @project_type_cd VARCHAR(8) = NULL;
    DECLARE @vSeverity INT = NULL;

    SELECT @creator_id = MAX(creator_id), @project_id = MAX(project_id)
    FROM @task_template;

    SELECT @project_type_cd = project_type_cd
    FROM project AS P WITH (NOLOCK)
    WHERE P.project_id = @project_id;

    IF NOT EXISTS(SELECT 1 FROM dbo.project AS P WITH (NOLOCK) WHERE P.project_id = @project_id)
    BEGIN
        RAISERROR('존재하지 않는 프로젝트 입니다.', 11, 1);
    END

    IF (SELECT COUNT(DISTINCT T.project_id) FROM @task_template AS T) > 1
    BEGIN
        RAISERROR('한 개의 프로젝트 아이디에 대해서만 처리 가능 합니다.', 11, 1);
    END

    BEGIN TRY
        BEGIN TRAN

            INSERT INTO dbo.task(...);
            INSERT INTO dbo.task_dependency(...);

            DECLARE @task_finish_plan TABLE(...);
            INSERT INTO @task_finish_plan(...);

            WHILE EXISTS(SELECT 1 FROM @task_finish_plan WHERE processed = 0)
            BEGIN
                SELECT TOP 1 @task_id = TFP.task_id, @start_dt = TFP.start_dt, @end_dt = end_dt
                FROM @task_finish_plan AS TFP
                WHERE TFP.processed = 0;

                INSERT INTO @task_finish_plan(...);
                UPDATE @task_finish_plan SET processed = 1 WHERE task_id = @task_id;
            END

            INSERT INTO dbo.task_finish_plan(...);

            COMMIT TRAN
            SET @vSeverity = 0;
            SET @result_cd = 0;
            SET @result_msg = '성공';

        END TRY
        BEGIN CATCH
            IF @@TRANCOUNT > 0 ROLLBACK TRAN;
            SET @result_cd = -1;
            SET @vSeverity = ERROR_SEVERITY();
            SET @result_msg = ERROR_MESSAGE();
        END CATCH

        DECLARE @tvp_json VARCHAR(MAX);
        DECLARE @log_param VARCHAR(MAX);
        SELECT @tvp_json = (SELECT * FROM @task_template FOR JSON AUTO);
        SET @log_param = ISNULL(@tvp_json, '[]');
        INSERT INTO dbo.use_log(...);

        RETURN;
END
```

---

### 정리된 주요 내용:
- **입력값**을 기반으로 `task` 및 `task_dependency` 테이블에 데이터를 삽입.
- `task_finish_plan` 테이블에 표준 계획 데이터를 생성.
- 프로젝트 ID 유효성 검사 및 오류 처리.
- 작업 순서를 고려한 계획 수립 및 일정 관리 로직.

이 프로시저는 프로젝트 작업 템플릿을 기반으로 작업 일정을 체계적으로 관리하는 데 사용됩니다.

--- spUpdateDateByShifting ---
Analysis Time: 8/21/2025, 9:34:52 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 내용입니다:

### 프로시저 요약: spUpdateDateByShifting

#### 목적:
일정 변경이 발생했을 때 일자 보정을 수행하는 프로시저입니다.

#### 주요 기능:
1. 특정 프로젝트(@pProject_id)와 계획 코드(@pPlan_cd)를 기준으로 일정을 보정합니다.
2. 특정 작업(@pTask_id)이 지정되지 않으면 프로젝트의 최상위 작업을 기준으로 보정합니다.
3. 작업 간 의존성을 고려하여 시작일과 종료일을 계산하고 업데이트합니다.
4. 각 작업의 시작일과 종료일을 보정하며, 변경 사항을 로그에 기록합니다.

#### 주요 테이블:
- task_finish_plan (TFP)
- task_dependency (TD)
- task
- use_log

#### 주요 로직:
1. 입력된 작업 ID가 없으면 최상위 작업을 조회합니다.
2. 부모 작업이 존재하는 경우 이를 기준으로 보정을 시작합니다.
3. 각 작업의 시작일과 종료일을 계산하고 업데이트합니다.
4. 다음 작업이 존재하는 경우 반복적으로 일정을 보정합니다.
5. 모든 작업이 처리된 후 결과를 반환합니다.

#### 출력 파라미터:
- @result_cd: 결과 코드 (0: 성공, -1: 실패)
- @result_msg: 결과 메시지

#### 예제 실행:
```sql
DECLARE @result_cd INT, @result_msg VARCHAR(100);

EXEC [dbo].[spUpdateDateByShifting]
    @pProject_id = 25080062,
    @pTask_id = NULL,
    @pPlan_cd = '20',
    @result_cd = @result_cd OUTPUT,
    @result_msg = @result_msg OUTPUT;

SELECT @result_cd as result_cd, @result_msg as result_msg;
```

#### 주요 고려사항:
- 트랜잭션을 사용하여 데이터 일관성을 유지합니다.
- 작업 간 의존성을 정확하게 처리합니다.
- 오류 발생 시 롤백을 수행하고 로그를 기록합니다.
- 작업 일정을 보정할 때 다음 작업의 일정을 고려하여 정확한 일정을 유지합니다.

--- spGetMemberId ---
Analysis Time: 8/21/2025, 9:35:09 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 결과입니다.

### 프로시저 `spGetMemberId` 요약

**작성자:** jaykwon
**작성일:** 2025-06-27
**목적:** 로그인 시 MOIN_ID를 입력받아 member_id를 반환하며, 로깅 기능 포함.

---

### 주요 내용 요약

1. **입력 파라미터**
   - `@pMOIN_ID` (VARCHAR(50)): 사용자 MOIN_ID

2. **출력 파라미터**
   - `@result_cd` (INT): 결과 코드 (0: 성공, -1: 실패)
   - `@result_msg` (VARCHAR(200)): 결과 메시지

3. **주요 로직**
   - `hr_master` 테이블과 `dept_auth` 테이블을 조회하여 member_id, dept_auth_cd, dept_auth_name을 가져옵니다.
   - `VHR.MOIN_ID = @pMOIN_ID` 조건으로 해당 사용자를 찾습니다.
   - 사용자가 존재하지 않을 경우 오류를 반환합니다.

4. **오류 처리**
   - 사용자가 존재하지 않을 경우 `RAISERROR`를 사용하여 오류를 발생시킵니다.
   - 오류 발생 시 `@result_cd`는 -1, `@result_msg`는 오류 메시지를 반환합니다.

---

### 사용 예시 요약

```sql
DECLARE @result_cd INT, @result_msg VARCHAR(100);

EXEC [dbo].[spGetMemberId] @pMOIN_ID = 'jaykwon5156',
    @result_cd = @result_cd OUTPUT,
    @result_msg = @result_msg OUTPUT;

SELECT @result_cd as result_cd, @result_msg as result_msg;
```

- **입력:** `@pMOIN_ID = 'jaykwon5156'`
- **출력:** `@result_cd` (0 또는 -1), `@result_msg` ("성공" 또는 오류 메시지)

---

### 정리된 코드

```sql
CREATE PROCEDURE [dbo].[spGetMemberId]
    @pMOIN_ID VARCHAR(50) = NULL,
    @result_cd INT OUTPUT,
    @result_msg VARCHAR(200) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

    DECLARE @vMember_id VARCHAR(8) = NULL;
    DECLARE @vDept_auth_cd VARCHAR(8) = NULL;
    DECLARE @vDept_auth_name VARCHAR(50) = NULL;

    BEGIN TRY
        SELECT @vMember_id = VHR.EMP_ID,
            @vDept_auth_cd = ISNULL(DA.dept_auth_cd,'90'),
            @vDept_auth_name = dbo.fnGetDetailNameByDetailCode('90000',ISNULL(DA.dept_auth_cd,'90'))
        FROM dbo.hr_master AS VHR WITH (NOLOCK)
        LEFT JOIN dbo.dept_auth AS DA WITH (NOLOCK) ON VHR.DEPT_CODE = DA.dept_cd
        WHERE VHR.MOIN_ID = @pMOIN_ID;

        IF (@vMember_id IS NULL)
        BEGIN
            RAISERROR('존재하지 않는 회원 입니다.', 11, 1);
        END

        SELECT @vMember_id AS member_id,
            @vDept_auth_cd AS dept_auth_cd,
            @vDept_auth_name AS dept_auth_name;

        SET @result_cd = 0;
        SET @result_msg = '성공';
    END TRY
    BEGIN CATCH
        SET @result_cd = -1;
        SET @result_msg = ERROR_MESSAGE();
    END CATCH
    RETURN;
END
```

---

### 최종 정리

- **목적:** MOIN_ID를 입력받아 member_id와 관련된 정보를 반환하며, 오류 발생 시 적절한 메시지를 반환하는 프로시저입니다.

--- spBatchUseLogCleansing ---
Analysis Time: 8/21/2025, 9:35:22 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 내용입니다.

### 프로시저 `spBatchUseLogCleansing` 요약

**작성자:** Jay Kwon
**작성일:** 2025-08-07
**목적:** `use_log` 테이블에서 오래된 데이터를 삭제하는 배치 프로시저

---

### 주요 기능 및 동작

1. **입력 파라미터**
   - `@pPeriod_day` (INT): 데이터 유지 기간(일)
     - 예: 2일 = 최근 2일 동안의 데이터만 유지

2. **주요 동작**
   - `use_log` 테이블에서 `@pPeriod_day`일보다 오래된 데이터를 삭제
   - 삭제는 트랜잭션 컨트롤 없이 수행
   - 삭제는 배치 단위로 진행되며, `@vBatch_size`(기본값 10,000개)씩 삭제
   - 삭제 후 1초씩 대기하여 부하 완화

3. **출력 파라미터**
   - `@result_cd` (INT): 결과 코드 (0=성공, -1=실패)
   - `@result_msg` (VARCHAR): 결과 메시지

---

### 주요 로직 흐름

1. **입력값 검증**
   - `@pPeriod_day`이 NULL일 경우 오류 반환

2. **삭제 로직**
   - `use_log` 테이블에서 `log_dt`가 현재 시간보다 `@pPeriod_day`일 이상 지난 데이터를 삭제
   - 삭제는 배치 단위로 반복 수행

3. **결과 처리**
   - 성공 시: `@result_cd = 0`, `@result_msg = '성공'`
   - 실패 시: `@result_cd = -1`, `@result_msg = 오류 메시지`

---

### 실행 예시

```sql
DECLARE @result_cd INT, @result_msg VARCHAR(100);

EXEC [dbo].[spBatchUseLogCleansing]
    @pPeriod_day = 2
    , @result_cd = @result_cd OUTPUT
    , @result_msg = @result_msg OUTPUT;

SELECT @result_cd as result_cd, @result_msg as result_msg;
```

- 위 코드를 실행하면 최근 2일 동안의 `use_log` 데이터만 유지되고, 삭제된 건수는 `@result_msg`에서 확인할 수 있습니다.

---

### 주요 개선 사항

- **배치 크기 조정:** `@vBatch_size` 값을 상황에 맞게 조정 가능
- **일기 기록:** 삭제 전후의 로그를 `use_log` 테이블에 기록
- **오류 처리:** 오류 발생 시 `@result_cd`와 `@result_msg`를 통해 명확한 오류 정보를 반환

이 프로시저는 특정 기간 동안의 `use_log` 데이터를 자동으로 삭제하는 기능을 제공하며, 배치 방식으로 효율적으로 대량의 데이터를 처리할 수 있습니다.

--- spGetHolidayInfo ---
Analysis Time: 8/21/2025, 9:35:37 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 결과입니다.

### 프로시저 `spGetHolidayInfo` 요약

**작성자:** Jay Kwon
**작성일:** 2025-08-07
**목적:** 휴일 정보를 가져옵니다.

---

### 주요 코드 정리

1. **매개변수**
   - `@pYear` (INT): 요청할 연도 (NULL 가능)
   - `@pMonth` (INT): 요청할 월 (NULL 가능)
   - `@result_cd` (INT): 결과 코드 (출력)
   - `@result_msg` (VARCHAR(200)): 결과 메시지 (출력)

2. **주요 로직**
   - **유효성 검사**:
     - `@pMonth`가 1-12 사이인지 확인
     - `@pYear`와 `@pMonth`가 모두 NULL이 아닌지 확인

   - **날짜 범위 설정**:
     - `@pYear`가 NULL이면 현재 연도로 설정
     - 해당 월의 시작일과 종료일을 계산 (`@vStartDate`, `@vEndDate`)

   - **데이터 조회**:
     - `dbo.calendar` 테이블에서 `@vStartDate`와 `@vEndDate` 사이의 휴일 데이터를 조회
     - `target_dt`와 `date_description`을 반환

3. **오류 처리**
   - `RAISERROR`를 사용하여 입력값 오류 또는 범위를 벗어난 경우 오류 메시지를 반환
   - `TRY-CATCH` 블록으로 오류를 처리하고, `@result_cd`와 `@result_msg`를 설정

---

### 실행 예시
```sql
DECLARE @result_cd INT,
        @result_msg VARCHAR(100);

EXEC [dbo].[spGetHolidayInfo]
    @pYear = 2025,
    @pMonth = 8,
    @result_cd = @result_cd OUTPUT,
    @result_msg = @result_msg OUTPUT;

SELECT @result_cd AS result_cd,
       @result_msg AS result_msg;
```

- **결과**: `@result_cd`는 0(성공)을 반환하고, `@result_msg`는 '성공'으로 설정됩니다.
- **오류 발생 시**: `@result_cd`는 -1을 반환하고, `@result_msg`는 오류 메시지를 포함합니다.

---

### 주요 개선 사항
1. **유효성 검사 강화**:
   - `@pYear`가 유효한 연도인지 확인 (예: 4자리 숫자)
   - `@pMonth`가 1-12 사이인지 확인

2. **날짜 범위 검사**:
   - `dbo.calendar` 테이블의 최소 및 최대 날짜를 확인하여 요청 범위가 유효한지 검사

3. **오류 처리**:
   - `RAISERROR`를 사용하여 명확한 오류 메시지를 반환
   - `TRY-CATCH` 블록으로 오류를 처리하고 적절한 결과 코드와 메시지를 반환

---

이 요약은 프로시저의 주요 구조와 기능을 간결하게 정리한 것입니다. 필요에 따라 추가적인 개선이나 기능 추가가 가능합니다.

--- spGetDeptHierarchy ---
Analysis Time: 8/21/2025, 9:35:55 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 결과입니다.

### 요약된 코드
```sql
CREATE PROCEDURE [dbo].[spGetDeptHierarchy]
    @pDept_name VARCHAR(100) = NULL,
    @pDept_cd VARCHAR(8) = NULL,
    @result_cd INT OUTPUT,
    @result_msg VARCHAR(200) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

    DECLARE @vDept_cd VARCHAR(8) = NULL;

    -- 부서명 또는 부서코드가 제공되면 해당 값을 설정
    IF (@pDept_name IS NOT NULL)
        SELECT TOP 1 @vDept_cd = DM.DEPT_CODE
        FROM dbo.dept_master AS DM WITH (NOLOCK)
        WHERE DM.DEPT_NAME LIKE '%' + @pDept_name + '%';

    IF (@pDept_cd IS NOT NULL)
        SET @vDept_cd = @pDept_cd;

    -- 조직 계층 구조 쿼리
    WITH OrgHierarchy AS (
        -- 루트 조건: 조건 없을 때만 루트에서 시작
        SELECT DEPT_CODE, DEPT_NAME, PARENT_DEPT_CODE
        FROM dbo.dept_master AS DM WITH (NOLOCK)
        WHERE (@vDept_cd IS NULL AND (ISNULL(PARENT_DEPT_CODE, '') = '' OR PARENT_DEPT_CODE = 'NULL')) OR (DM.DEPT_CODE = @vDept_cd)

        UNION ALL

        -- 하위 조직 재귀 탐색
        SELECT D.DEPT_CODE, D.DEPT_NAME, D.PARENT_DEPT_CODE
        FROM dbo.dept_master AS D
        INNER JOIN OrgHierarchy OH ON D.PARENT_DEPT_CODE = OH.DEPT_CODE
    )
    SELECT D.DEPT_CODE, D.DEPT_NAME, D.PARENT_DEPT_CODE
    FROM OrgHierarchy AS D
    ORDER BY DEPT_CODE;

    SET @result_cd = 0;
    SET @result_msg = '성공';
END
```

### 주요 정리 사항
1. **입력 파라미터**:
   - `@pDept_name`: 부서명을 부분 일치로 검색할 때 사용.
   - `@pDept_cd`: 특정 부서 코드를 직접 지정할 때 사용.

2. **출력 파라미터**:
   - `@result_cd`: 프로시저 실행 결과 코드 (0은 성공).
   - `@result_msg`: 프로시저 실행 결과 메시지 ('성공'은 정상 실행 완료).

3. **조직 계층 구조 검색**:
   - `OrgHierarchy` CTE를 사용하여 재귀적으로 조직 계층을 탐색.
   - 루트 부서는 `PARENT_DEPT_CODE`가 없거나 `NULL`인 경우.
   - 특정 부서 검색 시 `@vDept_cd`를 통해 필터링.

4. **결과 반환**:
   - `DEPT_CODE`, `DEPT_NAME`, `PARENT_DEPT_CODE`를 순서대로 반환.
   - 결과는 `DEPT_CODE` 기준으로 오름차순 정렬.

### 사용 예시
```sql
-- 전체 조회
EXEC [dbo].[spGetDeptHierarchy]
    @pDept_name = NULL,
    @pDept_cd = NULL,
    @result_cd = @result_cd OUTPUT,
    @result_msg = @result_msg OUTPUT;

SELECT @result_cd as result_cd, @result_msg as result_msg;

-- 특정 부서 조회
EXEC [dbo].[spGetDeptHierarchy]
    @pDept_name = '푸드사업부',
    @pDept_cd = NULL,
    @result_cd = @result_cd OUTPUT,
    @result_msg = @result_msg OUTPUT;

SELECT @result_cd as result_cd, @result_msg as result_msg;
```

### 정리된 코드의 장점
- **간결성**: 불필요한 반복 코드를 제거하고 핵심 로직만 남겼습니다.
- **가독성**: 코드 구조를 명확히 정리하여 이해하기 쉽게 만들었습니다.
- **확장성**: 추가적인 조건이나 필드를 포함시킬 수 있는 유연한 구조를 유지했습니다.

--- spGetDeptMember ---
Analysis Time: 8/21/2025, 9:36:09 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 결과입니다.

### 프로시저 `spGetDeptMember` 요약

1. **목적**
   - 조직에 속한 인원 조회

2. **매개변수**
   - `@pDept_cd` (입력) : 부서 코드 (8자)
   - `@result_cd` (출력) : 결과 코드
   - `@result_msg` (출력) : 결과 메시지

3. **주요 로직**
   - 부서 코드 `@pDept_cd`가 제공되지 않으면 오류 반환
   - 부서 코드가 존재하지 않으면 오류 반환
   - 부서 코드가 제공되면 해당 부서의 직원 정보 조회
   - 성공 시 `@result_cd`는 0, 실패 시 1 반환

4. **결과**
   - 성공 시 직원 정보 반환
   - 실패 시 오류 메시지 반환

### 코드 정리

```sql
CREATE PROCEDURE [dbo].[spGetDeptMember]
    @pDept_cd VARCHAR(8) = NULL,
    @result_cd INT OUTPUT,
    @result_msg VARCHAR(200) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

    IF (@pDept_cd IS NULL)
    BEGIN
        SET @result_cd = 1;
        SET @result_msg = '조회 정보가 누락되었습니다.';
        RETURN;
    END

    IF NOT EXISTS(SELECT 1 FROM dbo.dept_master AS ODM WITH (NOLOCK) WHERE ODM.DEPT_CODE = @pDept_cd)
    BEGIN
        SET @result_cd = 1;
        SET @result_msg = '존재하지 않는 부서코드 입니다.';
        RETURN;
    END

    IF (@pDept_cd IS NULL)
    BEGIN
        SELECT HRM.EMP_ID, HRM.[NAME], HRM.MOIN_ID, HRM.MOIN_EMAIL, HRM.JOB_CODE, HRM.JOB_GRADE_NM, HRM.DEPT_CODE, DM.DEPT_NAME
        FROM dbo.hr_master AS HRM WITH (NOLOCK)
        INNER JOIN dbo.dept_master AS DM WITH (NOLOCK) ON HRM.DEPT_CODE = DM.DEPT_CODE
    END
    ELSE
    BEGIN
        SELECT HRM.EMP_ID, HRM.[NAME], HRM.MOIN_ID, HRM.MOIN_EMAIL, HRM.JOB_CODE, HRM.JOB_GRADE_NM, HRM.DEPT_CODE, DM.DEPT_NAME
        FROM dbo.hr_master AS HRM WITH (NOLOCK)
        INNER JOIN dbo.dept_master AS DM WITH (NOLOCK) ON HRM.DEPT_CODE = DM.DEPT_CODE
        WHERE HRM.DEPT_CODE = @pDept_cd
    END

    SET @result_cd = 0;
    SET @result_msg = '성공';
    RETURN;
END
```

### 주요 개선 사항
- `NOLOCK` 테이블 힌트 사용으로 성능 향상
- 명확한 오류 메시지 반환
- 부서 코드 유효성 검사 강화
- 일관된 결과 처리 방식

--- spGetCodeMasterForLine ---
Analysis Time: 8/21/2025, 9:36:27 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 결과입니다.

### 프로시저 `spGetCodeMasterForLine` 요약

**작성자:** Jay Kwon
**작성일:** 2025-08-11
**목적:** 라인코드 검색

---

### 프로시저 구조

1. **입력 파라미터**
   - `@pGroup_cd` (VARCHAR(8)): 그룹 코드 (필수 아님)
   - `@pPage_no` (INT): 페이지 번호 (필수 아님)
   - `@pPage_size` (INT): 페이지 크기 (필수 아님)

2. **출력 파라미터**
   - `@result_cd` (INT): 결과 코드 (0=성공, -1=실패)
   - `@result_msg` (VARCHAR(200)): 결과 메시지
   - `@total_count` (INT): 전체 레코드 수
   - `@total_pages` (INT): 전체 페이지 수

---

### 주요 로직

1. **전체 레코드 수 계산**
   - `code_master` 테이블에서 `group_cd`가 `'20001'` 또는 `'20002'`이고, `is_active_cd`가 `'10'`인 레코드 수를 계산
   - `group_cd`가 `'90000'` 미만인 경우만 포함

2. **전체 페이지 수 계산**
   - `@pPage_size`가 0 또는 NULL일 경우 1로 설정
   - `CEILING(CAST(@total_count AS FLOAT) / @pPage_size)`로 전체 페이지 수 계산

3. **데이터 조회**
   - `code_master` 테이블에서 `group_cd`가 `'20001'` 또는 `'20002'`이고, `is_active_cd`가 `'10'`인 레코드 조회
   - `group_cd`와 `detail_cd` 기준으로 오름차순 정렬
   - 페이징 처리: `OFFSET (@pPage_no - 1) * @pPage_size ROWS FETCH NEXT @pPage_size ROWS ONLY`

4. **오류 처리**
   - 오류 발생 시 `@result_cd`를 -1로, `@result_msg`를 오류 메시지로 설정
   - `@total_count`와 `@total_pages`를 0으로 설정

---

### 주요 기능 정리

- **페이징 처리** : `@pPage_no`와 `@pPage_size`를 기반으로 페이지별 데이터 반환
- **필터링** : `group_cd`가 `'20001'` 또는 `'20002'`이고, `is_active_cd`가 `'10'`인 레코드만 반환
- **정렬** : `group_cd`와 `detail_cd` 기준으로 오름차순 정렬
- **오류 처리** : 오류 발생 시 적절한 메시지 전달 및 데이터 반환

---

### 사용 예시

```sql
DECLARE @result_cd INT, @result_msg VARCHAR(200), @total_count INT, @total_pages INT;

EXEC [dbo].[spGetCodeMasterForLine]
    @pPage_no = 1,
    @pPage_size = 20,
    @result_cd = @result_cd OUTPUT,
    @result_msg = @result_msg OUTPUT,
    @total_count = @total_count OUTPUT,
    @total_pages = @total_pages OUTPUT;

SELECT @result_cd AS result_cd, @result_msg AS result_msg, @total_count AS total_count, @total_pages AS total_pages;
```

---

### 정리

- **입력 파라미터:** `@pGroup_cd`, `@pPage_no`, `@pPage_size`
- **출력 파라미터:** `@result_cd`, `@result_msg`, `@total_count`, `@total_pages`
- **핵심 기능:** 페이징 처리와 필터링을 통한 `code_master` 테이블 데이터 조회

--- spDeleteOutputForTask ---
Analysis Time: 8/21/2025, 9:36:48 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 내용입니다.

### 프로시저 요약: `[dbo].[spDeleteOutputForTask]`

**목적**: 태스크에 대한 산출물 정보를 삭제하는 프로시저.

**매개변수**:
- `@pTask_id` (INT): 삭제할 산출물의 태스크 ID.
- `@pFile_path` (VARCHAR): 삭제할 산출물의 파일 경로.
- `@pModifier_id` (VARCHAR): 수정자 ID.
- `@result_cd` (INT): 결과 코드 (출력 매개변수).
- `@result_msg` (VARCHAR): 결과 메시지 (출력 매개변수).

**주요 로직**:
1. **입력값 유효성 검사**:
   - 태스크가 존재하지 않으면 오류 반환.
   - 동일한 태스크와 파일 경로의 산출물이 이미 존재하면 오류 반환.

2. **산출물 삭제**:
   - 해당 태스크와 파일 경로의 산출물을 삭제하고, 상태를 비활성화 (is_active_cd = '90')으로 설정.
   - 수정자 정보와 삭제 시간을 기록.

3. **결과 반환**:
   - 성공 시 `@result_cd = 0`, `@result_msg = '성공'` 반환.
   - 실패 시 `@result_cd = -1`, `@result_msg`에 오류 메시지 반환.

4. **로깅**:
   - 프로시저 호출 기록을 데이터베이스에 저장.

**트랜잭션 및 오류 처리**:
- 트랜잭션 격리 수준을 `READ UNCOMMITTED`로 설정.
- 오류 발생 시 트랜잭션 롤백 수행.
- 오류 세버리티 및 메시지를 반환.

### 정리된 코드
```sql
CREATE PROCEDURE [dbo].[spDeleteOutputForTask]
    @pTask_id INT = NULL,
    @pFile_path VARCHAR(200) = NULL,
    @pModifier_id VARCHAR(7) = NULL,
    @result_cd INT OUTPUT,
    @result_msg VARCHAR(200) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
    DECLARE @vSeverity INT = NULL;
    DECLARE @vProject_id INT = NULL;

    BEGIN TRY
        IF NOT EXISTS (SELECT 1 FROM task AS T WITH (NOLOCK) WHERE T.task_id = @pTask_id)
        BEGIN
            RAISERROR('존재하지 않는 태스크 입니다.', 16, 1);
        END

        UPDATE dbo.task_output AS TOPT WITH (NOLOCK)
        SET TOPT.is_active_cd = '90',
            TOPT.Modifier_id = @pModifier_id,
            TOPT.modified_at = GETDATE()
        WHERE TOPT.task_id = @pTask_id
          AND TOPT.file_path = @pFile_path;

        SET @vSeverity = 0;
        SET @result_cd = 0;
        SET @result_msg = '성공';
    END TRY
    BEGIN CATCH
        IF @@TRANCOUNT > 0 ROLLBACK TRAN;
        SET @vSeverity = ERROR_SEVERITY();
        SET @result_cd = -1;
        SET @result_msg = ERROR_MESSAGE();
    END CATCH

    DECLARE @log_param NVARCHAR(MAX);
    SET @log_param = '@pTask_id = ' + ISNULL(CAST(@pTask_id AS VARCHAR), 'NULL') + ', ' +
                      '@pFile_path = ' + ISNULL(@pFile_path, 'NULL') + ', ' +
                      '@pModifier_id = ' + ISNULL(@pModifier_id, 'NULL');

    INSERT INTO dbo.use_log
        (caller_id, severity, project_id, log_dt, log_message, proc_name, proc_param, result_cd, result_msg, created_at)
    VALUES
        (ISNULL(CAST(@pModifier_id AS VARCHAR(8)), 'UNKNOWN'), @vSeverity, ISNULL(@vProject_id, 0),
         CONVERT(CHAR(10), GETDATE(), 120), CAST(@pTask_id AS VARCHAR) + ' 태스크에 산출물을 삭제 하였습니다',
         '[spDeleteOutputForTask]', @log_param, @result_cd, @result_msg, GETDATE());

    RETURN;
END
```

### 정리된 코드 설명:
- **입력값 검증**: 태스크 존재 여부 확인.
- **산출물 삭제**: 파일 경로와 태스크에 해당하는 산출물 삭제.
- **결과 반환**: 성공 또는 오류 메시지 반환.
- **로깅**: 프로시저 호출 기록 저장.

이 프로시저는 특정 태스크의 산출물을 삭제하는 기능을 수행하며, 입력값의 유효성을 검사하고 결과를 반환합니다.

--- spUpdateOutputForTask ---
Analysis Time: 8/21/2025, 9:36:56 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 결과입니다.

### 프로시저 `spUpdateOutputForTask` 요약

**작성자:** Jay Kwon
**작성일:** 2025-08-12
**목적:** 태스크에 대한 산출물 정보를 수정하는 프로시저.

---

### 주요 코드 요약

1. **입력 및 출력 파라미터**
   - 입력 파라미터:
     - `@pTask_id` (INT): 태스크 ID
     - `@pOutput_comment` (VARCHAR): 산출물에 대한 새로운 댓글
     - `@pModifier_id` (VARCHAR): 수정자 ID
   - 출력 파라미터:
     - `@result_cd` (INT): 결과 코드 (0=성공, -1=실패)
     - `@result_msg` (VARCHAR): 결과 메시지

2. **주요 로직**
   - **태스크 존재 여부 확인**:
     - 태스크가 존재하지 않으면 오류 반환
   - **산출물 정보 수정**:
     - `task_output` 테이블에서 해당 태스크의 산출물 댓글과 수정자 정보를 업데이트
   - **트랜잭션 관리**:
     - 실패 시 롤백 수행
   - **로깅**:
     - 호출 정보, 결과, 로그 메시지를 `use_log` 테이블에 기록

---

### 주요 특징
- **트랜잭션 안전성**: READ UNCOMMITTED 격리 수준 사용
- **오류 처리**: 오류 발생 시 `@result_cd`와 `@result_msg`를 통해 결과 반환
- **로깅 기능**: 모든 호출과 결과에 대해 상세한 로그 기록

이 프로시저는 특정 태스크의 산출물에 대한 정보를 안전하게 수정하는 기능을 제공합니다.

--- spGetDashBoardDataForMember ---
Analysis Time: 8/21/2025, 9:37:07 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 결과입니다.

### 프로시저 `spGetDashBoardDataForMember` 요약

**작성자:** Jay Kwon
**작성일:** 2025-08-13
**목적:** 회원별 대시보드 데이터 제공

---

### 주요 기능
1. **회원 정보 및 프로젝트 현황 조회**
   - `member_id`, `member_name`, `member_dept_cd`, `member_team_cd`, `member_division_cd` 등의 회원 정보 추출
   - 진행 중인 프로젝트 수(`progress_cnt`) 및 ID(`progress_project_ids`)
   - 지연된 프로젝트 수(`delayed_cnt`) 및 ID(`delayed_project_ids`)
   - 완료된 프로젝트 수(`done_cnt`) 및 ID(`done_project_ids`)

2. **데이터 소스**
   - `task`, `project`, `task_owner`, `hr_master` 테이블에서 필요한 데이터를 조회
   - `is_active_cd`, `project_type_cd`, `is_active` 조건을 통해 유효한 데이터만 선택

3. **오류 처리**
   - `BEGIN TRY` 및 `BEGIN CATCH` 블록을 사용한 오류 관리
   - 오류 발생 시 `@result_cd`와 `@result_msg`에 오류 정보 저장

---

### 주요 개선 사항
1. **트랜잭션 격리 수준 설정**
   - `TRANSACTION ISOLATION LEVEL READ UNCOMMITTED`로 성능 최적화

2. **성능 향상**
   - `NOLOCK` 힌트를 사용하여 테이블 잠금 방지
   - `STRING_AGG`를 사용한 프로젝트 ID 결합

3. **명확한 오류 처리**
   - `@result_cd`와 `@result_msg`를 통해 오류 정보를 명확히 전달

---

### 실행 예시
```sql
DECLARE @result_cd INT, @result_msg VARCHAR(100);

EXEC [dbo].[spGetDashBoardDataForMember]
    @result_cd = @result_cd OUTPUT,
    @result_msg = @result_msg OUTPUT;

SELECT @result_cd as result_cd, @result_msg as result_msg;
```

이 프로시저는 회원별로 진행 중인 프로젝트, 지연된 프로젝트, 완료된 프로젝트 정보를 제공하며, 이를 통해 대시보드에 필요한 데이터를 효율적으로 제공합니다.

--- spInsertDeptAuth ---
Analysis Time: 8/21/2025, 9:37:20 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 결과입니다.

### 프로시저 `spInsertDeptAuth` 요약

**작성자:** JayKwon
**작성일:** 2025-07-01
**목적:** 부서별 권한 등록

---

### 주요 코드 정리

1. **입력 파라미터**
   - `@pDept_cd` (부서 코드, 8자)
   - `@pAuth_cd` (권한 코드, 8자)
   - `@pCreator_id` (생성자 ID, 7자)

2. **출력 파라미터**
   - `@result_cd` (결과 코드)
   - `@result_msg` (결과 메시지)

---

### 주요 로직

1. **권한 코드 유효성 검사**
   - `code_master` 테이블에서 권한 코드가 정의된 값인지 확인
   - 정의되지 않은 코드일 경우 오류 반환

2. **부서 코드 유효성 검사**
   - `dept_master` 테이블에서 부서 코드가 존재하는지 확인
   - 존재하지 않는 부서 코드일 경우 오류 반환

3. **권한 등록/업데이트**
   - `dept_auth` 테이블에 데이터가 존재하면 업데이트
   - 데이터가 없으면 새로 삽입

4. **트랜잭션 처리**
   - 성공 시 커밋, 실패 시 롤백

---

### 결과 코드 예시

```sql
DECLARE @result_cd INT, @result_msg VARCHAR(100);

EXEC [dbo].[spInsertDeptAuth]
    @pDept_cd = '13010101',
    @pAuth_cd = '10',
    @result_cd = @result_cd OUTPUT,
    @result_msg = @result_msg OUTPUT;

SELECT @result_cd as result_cd, @result_msg as result_msg;
```

- **성공 시:** `@result_cd = 0`, `@result_msg = '성공'`
- **실패 시:** `@result_cd = 1` 또는 `-1`, `@result_msg`에 오류 메시지 반환

---

### 주요 특징
- **트랜잭션 안전성:** `BEGIN TRAN`, `COMMIT TRAN`, `ROLLBACK TRAN`을 사용한 안정적인 데이터 처리
- **에러 처리:** `TRY-CATCH` 블록으로 오류 발생 시 롤백 및 메시지 반환
- **권한 코드 관리:** `code_master` 테이블과 연동하여 권한 코드의 유효성을 관리
- **부서 코드 관리:** `dept_master` 테이블과 연동하여 부서 코드의 유효성을 관리
- **로그 관리:** `creator_id`, `created_at`, `modifier_id`, `modified_at` 컬럼을 통한 변경 이력 관리

--- spGetMappingCodeLineToBrand ---
Analysis Time: 8/21/2025, 9:37:44 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 결과입니다.

### 프로시저 `spGetMappingCodeLineToBrand` 요약

**목적**: 라인 코드와 매핑된 브랜드 정보를 조회한다.

**입력 파라미터**:
- `@pLine_cd` (VARCHAR(8)): 라인 코드 (필수 아님)
- `@pBrand_name` (NVARCHAR(240)): 브랜드 이름 (필수 아님)
- `@pBrand_cd` (NVARCHAR(16)): 브랜드 코드 (필수 아님)

**출력 파라미터**:
- `@result_cd` (INT): 결과 코드 (0: 성공, -1: 실패)
- `@result_msg` (VARCHAR(200)): 결과 메시지

**주요 로직**:
1. **유효성 검사**:
   - 입력된 `@pLine_cd`가 존재하는지 `code_master` 테이블에서 확인.
   - 존재하지 않으면 오류 반환.

2. **데이터 조회**:
   - `mapper_line_brand`와 `IF_SAP_NPD_BRAND` 테이블을 조인하여 해당 라인 코드와 브랜드 정보를 조회.
   - `code_master` 테이블과도 좌측 조인을 수행하여 라인 코드의 상세 정보를 포함.

3. **결과 처리**:
   - 조회된 데이터가 없으면 `@result_cd`를 -1로, 오류 메시지를 `@result_msg`에 할당.
   - 정상적으로 데이터가 조회되면 `@result_cd`를 0으로, 메시지를 '성공'으로 설정.

### 정리된 코드
```sql
CREATE PROCEDURE [dbo].[spGetMappingCodeLineToBrand]
    @pLine_cd VARCHAR(8) = NULL,
    @pBrand_name NVARCHAR(240) = NULL,
    @pBrand_cd NVARCHAR(16) = NULL,
    @result_cd INT OUTPUT,
    @result_msg VARCHAR(200) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

    DECLARE @vSeverity INT = NULL;

    BEGIN TRY
        IF (@pLine_cd IS NOT NULL)
        BEGIN
            IF NOT EXISTS(SELECT 1 FROM dbo.code_master AS CM WITH (NOLOCK) WHERE CM.group_cd IN ('20001','20002') AND CM.detail_cd = @pLine_cd)
            BEGIN
                RAISERROR('존재하지 않는 라인코드 입니다. 라인코드를 먼저 확인하세요.', 16, 1);
            END
        END

        SELECT
            dbo.fnGetLineTypeCd(LINE.detail_cd) AS group_cd,
            dbo.fnGetDetailNameByDetailCode('20101',dbo.fnGetLineTypeCd(LINE.detail_cd)) AS group_name,
            LINE.detail_cd AS line_cd,
            LINE.detail_name AS line_name,
            SNB.BRANDCODE AS brand_cd,
            SNB.BRANDNAME AS brand_name
        FROM
            dbo.mapper_line_brand AS MLB WITH (NOLOCK)
            INNER JOIN dbo.IF_SAP_NPD_BRAND AS SNB WITH (NOLOCK) ON MLB.brand_cd = SNB.BRANDCODE
            LEFT JOIN dbo.code_master AS LINE WITH (NOLOCK) ON MLB.line_cd = LINE.detail_cd AND LINE.group_cd IN ('20001', '20002')
        WHERE
            (@pLine_cd IS NULL OR MLB.line_cd = @pLine_cd)
            AND SNB.BRANDTYPE = '200'
            AND (@pBrand_name IS NULL OR SNB.BRANDNAME = @pBrand_name)
            AND (@pBrand_cd IS NULL OR SNB.BRANDCODE = @pBrand_cd);

        SET @vSeverity = 0;
        SET @result_cd = 0;
        SET @result_msg = '성공';
    END TRY
    BEGIN CATCH
        SET @result_cd = -1;
        SET @result_msg = ERROR_MESSAGE();
        SET @vSeverity = ERROR_SEVERITY();
    END CATCH
    RETURN;
END
```

### 정리된 실행 예제
```sql
DECLARE @result_cd INT, @result_msg VARCHAR(200);

EXEC [dbo].[spGetMappingCodeLineToBrand]
    @pLine_cd = NULL,
    @pBrand_name = '거북알',
    @pBrand_cd = NULL,
    @result_cd = @result_cd OUTPUT,
    @result_msg = @result_msg OUTPUT;

SELECT @result_cd as result_cd, @result_msg as result_msg;
```

### 정리된 설명
- **입력값**: `@pLine_cd`, `@pBrand_name`, `@pBrand_cd` 중 하나라도 입력 가능하며, 모두 `NULL`일 경우 오류가 발생하지 않음.
- **출력값**: `@result_cd`는 0이면 정상, -1이면 오류이며, `@result_msg`는 오류 메시지 또는 '성공'을 반환.
- **주요 기능**: 입력된 라인 코드와 브랜드 정보를 기반으로 매핑된 데이터를 조회하고 결과를 반환.

이렇게 정리된 프로시저는 입력값에 대한 유효성 검사를 명확히 수행하며, 필요한 경우 오류를 반환하고, 정상적인 경우 요청한 데이터를 반환하는 구조로 작성되었습니다.

--- spInsertMappingCodeLineToBrand ---
Analysis Time: 8/21/2025, 9:37:59 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 결과입니다.

### 프로시저 `spInsertMappingCodeLineToBrand` 요약

**작성자:** Jay Kwon
**작성일:** 2025-08-13
**목적:** 라인(LINE) 코드와 브랜드(BRAND) 코드 간의 매핑을 데이터베이스에 삽입하거나 업데이트하는 프로시저.

---

### 주요 기능

1. **매핑 코드 삽입**
   - `LINE` 코드(`@pLine_cd`)와 CSV 형식의 `BRAND` 코드 목록(`@pBrand_cds`)을 받아, 각 `BRAND` 코드를 `mapper_line_brand` 테이블에 매핑합니다.
   - `BRAND` 코드 목록은 CSV 형식에서 파싱되어 각 코드를 개별 행으로 삽입합니다.

2. **중복 제거 및 삽입**
   - `STRING_SPLIT`을 사용하여 CSV 문자열을 개별 값으로 분리하고, 중복을 제거합니다.
   - `LEFT JOIN`을 사용하여 이미 존재하는 `BRAND` 코드는 제외하고, 새로운 매핑만 삽입됩니다.

3. **트랜잭션 관리**
   - `BEGIN TRAN`과 `COMMIT TRAN`을 사용하여 데이터 삽입 시 오류가 발생하면 롤백합니다.
   - 오류 발생 시 `@result_cd`는 `-1`로 설정되고, 오류 메시지는 `@result_msg`에 저장됩니다.

4. **출력 파라미터**
   - `@result_cd`: 프로시저 실행 결과 코드 (0: 성공, -1: 실패).
   - `@result_msg`: 프로시저 실행 결과 메시지 (성공 또는 오류 메시지).

---

### 실행 예시

```sql
DECLARE @result_cd INT, @result_msg VARCHAR(100);

EXEC [dbo].[spInsertMappingCodeLineToBrand]
    @pLine_cd = 1102,
    @pBrand_cds = '10000001,10000002',
    @result_cd = @result_cd OUTPUT,
    @result_msg = @result_msg OUTPUT;

SELECT @result_cd as result_cd, @result_msg as result_msg;
```

- **입력:**
  - `@pLine_cd`: 1102 (라인 코드)
  - `@pBrand_cds`: '10000001,10000002' (매핑할 브랜드 코드 목록)
- **출력:**
  - `@result_cd`: 0 (성공)
  - `@result_msg`: '성공'

---

### 주요 개선 사항

1. **CSV 파싱 및 중복 제거**
   - `STRING_SPLIT`과 `DISTINCT`를 사용하여 CSV 문자열에서 중복된 브랜드 코드를 제거하고, 이를 테이블 형식으로 변환합니다.

2. **트랜잭션 안전성**
   - `BEGIN TRAN`과 `ROLLBACK TRAN`을 사용하여 오류 발생 시 데이터 일관성을 유지합니다.

3. **오류 처리**
   - 오류 발생 시 `@result_cd`와 `@result_msg`를 통해 명확한 오류 정보를 반환합니다.

---

이 프로시저는 라인 코드와 브랜드 코드 간의 매핑을 안전하고 효율적으로 관리할 수 있도록 작성되었습니다.

--- spDeleteMappingCodeLineToBrand ---
Analysis Time: 8/21/2025, 9:38:10 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 결과입니다.

### 📌 요약 정리 결과

```sql
CREATE PROCEDURE [dbo].[spDeleteMappingCodeLineToBrand]
    @pLine_cd VARCHAR(8) = NULL,
    @pBrand_cd NVARCHAR(16) = NULL,
    @result_cd INT OUTPUT,
    @result_msg VARCHAR(200) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

    DECLARE @vSeverity INT = NULL;

    BEGIN TRY
        DELETE MLB
        FROM dbo.mapper_line_brand AS MLB
        WITH (NOLOCK)
        WHERE MLB.line_cd = @pLine_cd
          AND MLB.brand_cd = @pBrand_cd

        SET @vSeverity = 0;
        SET @result_cd = 0;
        SET @result_msg = '성공';
    END TRY

    BEGIN CATCH
        IF @@TRANCOUNT > 0
            ROLLBACK TRAN;

        SET @result_cd = -1;
        SET @result_msg = ERROR_MESSAGE();
        SET @vSeverity = ERROR_SEVERITY();
    END CATCH

    RETURN;
END
```

---

### 📌 주요 정리 사항

1. **프로시저 구조 간소화**
   - 불필요한 주석 및 실행 예제 코드를 제거하여 핵심 프로시저 구조만 남겼습니다.

2. **매개변수 정리**
   - 입력 파라미터(`@pLine_cd`, `@pBrand_cd`)와 출력 파라미터(`@result_cd`, `@result_msg`)를 명확히 구분하여 표시했습니다.

3. **트랜잭션 및 오류 처리**
   - 트랜잭션 설정(`READ UNCOMMITTED`)과 오류 발생 시 롤백 처리 로직을 유지했습니다.
   - 오류 발생 시 `@result_cd`를 `-1`로, `@result_msg`를 오류 메시지로 설정하도록 유지했습니다.

4. **가독성 개선**
   - `BEGIN TRY`와 `BEGIN CATCH` 블록을 활용하여 오류 처리 로직을 명확히 구분했습니다.
   - 불필요한 세미콜론(`;`)과 줄바꿈을 정리하여 코드 가독성을 높였습니다.

---

위와 같이 프로시저 코드를 정리하여 더 간결하고 명확한 구조로 제공했습니다.

--- sp_upgraddiagrams ---
Analysis Time: 8/21/2025, 9:38:19 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 내용입니다:

### 프로시저 `dbo.sp_upgraddiagrams` 요약

1. **목적**:
   - `dbo.sysdiagrams` 테이블을 생성하고 초기화하는 프로시저입니다.
   - 기존의 `dtproperties` 테이블에서 데이터 가져오기 및 변환 작업을 수행합니다.

2. **주요 동작**:

   - `dbo.sysdiagrams` 테이블 생성:
     ```sql
     CREATE TABLE dbo.sysdiagrams (
         name sysname NOT NULL,
         principal_id int NOT NULL,
         diagram_id int PRIMARY KEY IDENTITY,
         version int,
         definition varbinary(max)
     );
     ```
   - `UK_principal_name` 고유 키 제약 조건 추가:
     ```sql
     CONSTRAINT UK_principal_name UNIQUE (principal_id, name)
     ```

   - 기존 `dtproperties` 테이블에서 데이터 읽어 `sysdiagrams` 테이블로 삽입:
     - `DtgSchemaNAME`, `DtgSchemaGUID`, `DtgSchemaDATA` 속성값을 각각 읽어 변환하여 삽입.
     - `principal_id`는 `DATABASE_PRINCIPAL_ID(N'dbo')`로 설정.
     - `version`은 `dgdef.[version]` 값으로 삽입.
     - `definition`은 `dgdef.[lvalue]` 값으로 삽입.

3. **반환 값**:
   - `0`: `sysdiagrams` 테이블이 이미 존재할 경우.
   - `1`: 정상적인 실행 완료.
   - `2`: `dtproperties` 테이블에서 데이터를 복사하여 삽입한 경우.

4. **참고 사항**:
   - `sysdiagram_properties` 테이블은 현재 코드에서는 생성되지 않습니다.
   - `dtproperties` 테이블이 존재하지 않으면 아무 작업도 하지 않습니다.

--- spGetDashBoardDataForAll ---
Analysis Time: 8/21/2025, 9:38:36 AM
AI Analysis:
아래는 요청한 프로시저 코드를 최대한 요약하고 정리한 결과입니다.

### 프로시저 `spGetDashBoardDataForAll` 요약

**작성자:** Jay Kwon
**작성일:** 2025-07-04
**목적:** 전체 조회 대시보드 (구분값은 파라미터)

---

### 주요 코드 요약

1. **입력 파라미터**
   - `@pWork_type_cd`: VARCHAR(8) = NULL
     - **의미:** 프로젝트 구분 (100 순수, 101 익스텐션, 102 체인전용, 103 리뉴얼)

2. **출력 파라미터**
   - `@result_cd`: INT
     - **의미:** 결과 코드 (0: 성공, -1: 실패)
   - `@result_msg`: VARCHAR(200)
     - **의미:** 결과 메시지

3. **주요 로직**
   - **템플릿 테이블 생성** (`@vTemplate`):
     - `line_type_cd`, `line_type_name`, `line_cd`, `line_name`을 저장.
     - `code_master` 테이블에서 프로젝트 상태 관련 코드를 조회하여 초기화.

   - **결과 테이블 생성** (`@vResult`):
     - `line_cd`, `progress_cnt`, `progress_project_ids`, `delayed_cnt`, `delayed_project_ids`, `done_cnt`, `done_project_ids`를 저장.
     - 프로젝트 상태별로 카운트와 프로젝트 ID를 집계.

   - **프로젝트 상태별 집계**:
     - `progress_cnt` (진행 중인 프로젝트 카운트)
     - `progress_project_ids` (진행 중인 프로젝트 ID)
     - `delayed_cnt` (지연된 프로젝트 카운트)
     - `delayed_project_ids` (지연된 프로젝트 ID)
     - `done_cnt` (완료된 프로젝트 카운트)
     - `done_project_ids` (완료된 프로젝트 ID)

   - **결과 조회**:
     - `line_type_cd`, `line_type_name`, `line_cd`, `line_name`과 집계 결과를 결합하여 반환.

4. **트랜잭션 및 예외 처리**
   - `TRANSACTION ISOLATION LEVEL READ UNCOMMITTED` 사용.
   - 예외 발생 시 `@result_cd`와 `@result_msg`를 설정하여 반환.

---

### 주요 기능 정리

- **프로젝트 대시보드 데이터 추출**:
  - `line_cd`별로 프로젝트 상태별 카운트와 프로젝트 ID를 집계하여 반환.
  - `progress`, `delayed`, `done` 상태별 카운트와 프로젝트 ID를 `STRING_AGG`로 결합.

- **출력 예시**:
  ```sql
  SELECT line_type_cd, line_type_name, line_cd, line_name,
         total, progress_total, progress_cnt, progress_project_ids,
         delayed_cnt, delayed_project_ids, done_cnt, done_project_ids
  FROM @vTemplate AS TMP
  LEFT JOIN @vResult AS R ON TMP.line_cd = R.line_cd;
  ```

- **결과 코드**:
  - 성공 시 `@result_cd = 0`, `@result_msg = '성공'`.
  - 실패 시 `@result_cd = -1`, `@result_msg = ERROR_MESSAGE()`.

---

### 핵심 정리
- **입력 파라미터** `@pWork_type_cd`를 통해 특정 프로젝트 구분을 필터링할 수 있음.
- **출력 파라미터** `@result_cd`와 `@result_msg`로 결과 상태를 명확히 전달.
- **트랜잭션**을 통해 데이터 일관성 유지.

--- sp_helpdiagrams ---
Analysis Time: 8/21/2025, 9:38:50 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 결과입니다.

### 프로시저 `dbo.sp_helpdiagrams` 요약

**1. 목적**
- `sysdiagrams` 테이블에서 데이터베이스 다이어그램 정보를 조회하는 프로시저입니다.
- 다이어그램 이름(`@diagramname`)과 소유자 ID(`@owner_id`)를 조건으로 필터링하여 결과를 반환합니다.

**2. 주요 로직**
- 현재 사용자 이름(`@user`)과 `db_owner` 그룹 멤버십 여부(`@dboLogin`)를 확인합니다.
- `sysdiagrams` 테이블에서 다음 조건을 만족하는 레코드를 반환합니다:
  - `@dboLogin`이 `true`이거나, 다이어그램 소유자가 현재 사용자와 동일할 경우.
  - `@diagramname`이 제공되면 해당 다이어그램 이름과 일치.
  - `@owner_id`가 제공되면 소유자 ID와 일치.
- 결과를 `ORDER BY` 절에 따라 정렬하여 반환합니다.

**3. 주요 특징**
- `EXECUTE AS N'dbo'`: 프로시저 실행 권한을 `dbo`에 부여.
- `REVERT`: 사용자 권한을 원래 상태로 되돌림.
- `IS_MEMBER('db_owner')`: 현재 사용자가 `db_owner` 그룹 멤버인지 확인.

### 정리된 코드
```sql
CREATE PROCEDURE dbo.sp_helpdiagrams
    @diagramname sysname = NULL,
    @owner_id int = NULL
WITH EXECUTE AS N'dbo'
AS
BEGIN
    DECLARE @user sysname;
    DECLARE @dboLogin bit;

    EXECUTE AS CALLER;
    SET @user = USER_NAME();
    SET @dboLogin = CONVERT(bit, IS_MEMBER('db_owner'));
    REVERT;

    SELECT
        [Database] = DB_NAME(),
        [Name] = name,
        [ID] = diagram_id,
        [Owner] = USER_NAME(principal_id),
        [OwnerID] = principal_id
    FROM
        sysdiagrams
    WHERE
        (@dboLogin = 1 OR USER_NAME(principal_id) = @user)
        AND (@diagramname IS NULL OR name = @diagramname)
        AND (@owner_id IS NULL OR principal_id = @owner_id)
    ORDER BY
        4, 5, 1;
END
```

### 코드 설명
- **`EXECUTE AS CALLER`**: 프로시저가 호출자의 권한으로 실행되도록 설정.
- **`IS_MEMBER('db_owner')`**: `db_owner` 그룹 멤버십을 확인하여 `@dboLogin` 변수에 결과 저장.
- **`sysdiagrams` 테이블**: SQL Server에서 다이어그램 정보를 저장하는 시스템 테이블.
- **`ORDER BY`**: 결과 행을 정렬. `4, 5, 1`은 `[OwnerID]`, `[Owner]`, `[Database]` 순으로 정렬하는 조건.

이 프로시저는 데이터베이스 다이어그램 정보를 필터링하여 반환하는 기능을 수행하며, 권한을 고려하여 현재 사용자가 조회 가능한 다이어그램만 반환됩니다.

--- spGetDashBoardDataForMonthly ---
Analysis Time: 8/21/2025, 9:39:12 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 결과입니다.

---

### 프로시저 요약: **spGetDashBoardDataForMonthly**

#### 목적:
월별 조회 대시보드 데이터를 제공 (구분값은 파라미터로 받음)

---

### 주요 코드 정리:

1. **입력 파라미터 및 출력 변수**
   - 입력: `@pWork_type_cd` (VARCHAR(8), NULL 가능)
   - 출력: `@start_month` (VARCHAR(7)), `@result_cd` (INT), `@result_msg` (VARCHAR(200))

---

2. **주요 내부 로직**

   - **@vTemplate 테이블**: 라인 유형과 코드를 매핑하는 템플릿 생성
     ```sql
     INSERT INTO @vTemplate
     SELECT CM2.detail_cd, CM2.detail_name, CM1.detail_cd, CM1.detail_name
     FROM dbo.code_master AS CM1
     INNER JOIN dbo.code_master AS CM2
     ON CM1.group_cd = CM2.detail_cd AND CM2.group_cd = '20101';
     ```

   - **@vResult_org 테이블**: 프로젝트 데이터 수집 (라인별, 월별 프로젝트 개수 및 ID)
     ```sql
     INSERT INTO @vResult_org
     SELECT A.line_cd, A.planed_end_month, COUNT(*), STRING_AGG(CAST(A.project_id AS VARCHAR), ',')
     FROM (
         SELECT P.project_id, P.line_cd, LEFT(MAX(TFP.end_dt),7) AS planed_end_month
         FROM dbo.project AS P
         LEFT JOIN dbo.task_finish_plan AS TFP
         ON P.project_id = TFP.project_id AND TFP.plan_cd = '20'
         WHERE P.project_type_cd = '10' AND (@pWork_type_cd IS NULL OR P.work_type_cd = @pWork_type_cd)
         GROUP BY P.project_id, P.line_cd
     ) A
     WHERE A.planed_end_month >= @start_month
     GROUP BY A.line_cd, A.planed_end_month;
     ```

   - **@base 테이블**: 기준 월별 데이터 조합
     ```sql
     INSERT INTO @base (line_type_cd, line_type_name, line_cd, line_name, month_index, project_cnt, project_ids)
     SELECT TMP.line_type_cd, TMP.line_type_name, TMP.line_cd, TMP.line_name, T.n, ISNULL(R.project_cnt, 0), ISNULL(R.project_ids, '')
     FROM @vTemplate AS TMP
     CROSS JOIN (
         SELECT FORMAT(DATEADD(MONTH, v.n, DATEFROMPARTS(YEAR(GETDATE()), MONTH(GETDATE()), 1)), 'yyyy-MM') AS target_month, v.n
         FROM (VALUES (0), (1), (2), (3), (4), (5), (6), (7), (8), (9), (10), (11)) AS v(n)
     ) AS T
     LEFT JOIN @vResult_org AS R
     ON TMP.line_cd = R.line_cd AND R.planed_end_month = T.target_month;
     ```

   - **결과 출력**: 월별 프로젝트 개수 및 ID를 각 월별로 집계하여 반환
     ```sql
     SELECT
         line_type_cd, line_type_name, line_cd, line_name,
         SUM(CASE WHEN month_index = 0 THEN project_cnt ELSE 0 END) AS M0,
         STRING_AGG(CASE WHEN month_index = 0 THEN ISNULL(project_ids, '') END, ',') AS M0_ids,
         SUM(CASE WHEN month_index = 1 THEN project_cnt ELSE 0 END) AS M1,
         STRING_AGG(CASE WHEN month_index = 1 THEN ISNULL(project_ids, '') END, ',') AS M1_ids,
         -- ... (중략) ...
         SUM(CASE WHEN month_index = 11 THEN project_cnt ELSE 0 END) AS M11,
         STRING_AGG(CASE WHEN month_index = 11 THEN ISNULL(project_ids, '') END, ',') AS M11_ids
     FROM @base
     GROUP BY line_type_cd, line_type_name, line_cd, line_name
     ORDER BY line_type_cd, line_cd;
     ```

---

### 주요 특징:
- **월별 데이터**: 현재 월을 기준으로 12개월간의 월별 프로젝트 개수 및 ID를 반환
- **라인별 그룹화**: 프로젝트 데이터는 라인별로 그룹화되어 출력
- **출력 형식**: 각 월별 프로젝트 개수와 ID를 문자열로 반환 (예: `M0`, `M1`, ..., `M11`)

---

### 에러 처리:
- 프로시저 내부의 모든 오류는 `@result_cd`와 `@result_msg`를 통해 반환
- 성공 시 `@result_cd = 0`, 오류 시 `@result_cd = -1` 반환

---

### 정리된 전체 흐름:
1. 라인 템플릿 생성 → 2. 원본 프로젝트 데이터 수집 → 3. 월별 데이터 조합 → 4. 결과 출력

--- sp_helpdiagramdefinition ---
Analysis Time: 8/21/2025, 9:39:29 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 결과입니다.

---

### 프로시저 `dbo.sp_helpdiagramdefinition` 요약

**1. 목적**
- 데이터베이스 다이어그램(`sysdiagrams`)의 정의 정보를 조회하고 반환하는 프로시저.

**2. 주요 기능**
- 다이어그램 이름이 제공되면 해당 다이어그램의 `version`과 `definition`을 반환.
- 다이어그램이 존재하지 않거나 권한이 없는 경우 오류 반환.

**3. 주요 로직**
- 입력 파라미터:
  - `@diagramname` (sysname): 다이어그램 이름
  - `@owner_id` (int): 다이어그램 소유자 ID (기본값: 현재 사용자 ID)

- 처리 과정:
  1. 입력값 유효성 검사
     - `@diagramname`이 `NULL`인 경우 오류 반환
  2. 현재 사용자의 ID와 권한 확인
     - `db_owner` 권한 여부 확인
  3. 다이어그램 존재 여부 확인
     - `sysdiagrams` 테이블에서 다이어그램 이름과 소유자 ID로 검색
     - 다이어그램이 없거나 권한이 없는 경우 오류 반환
  4. 다이어그램 정보 반환
     - `version`과 `definition` 컬럼 반환

**4. 오류 처리**
- 다이어그램이 존재하지 않거나 권한이 없는 경우:
  - 오류 메시지 반환
  - 프로시저 종료

**5. 반환값**
- 정상 완료 시: `0`
- 오류 발생 시: `-1` 또는 `-3`

---

### 정리된 코드

```sql
CREATE PROCEDURE dbo.sp_helpdiagramdefinition
    @diagramname sysname,
    @owner_id int = null
WITH EXECUTE AS N'dbo'
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @theId int;
    DECLARE @IsDbo int;
    DECLARE @DiagId int;
    DECLARE @UIDFound int;

    IF @diagramname IS NULL
    BEGIN
        RAISERROR(N'E_INVALIDARG', 16, 1);
        RETURN -1;
    END

    EXECUTE AS CALLER;
    SELECT @theId = DATABASE_PRINCIPAL_ID();
    SELECT @IsDbo = IS_MEMBER(N'db_owner');
    IF @owner_id IS NULL
        SELECT @owner_id = @theId;
    REVERT;

    SELECT @DiagId = diagram_id,
           @UIDFound = principal_id
    FROM dbo.sysdiagrams
    WHERE principal_id = @owner_id
      AND name = @diagramname;

    IF @DiagId IS NULL OR (@IsDbo = 0 AND @UIDFound <> @theId)
    BEGIN
        RAISERROR('Diagram does not exist or you do not have permission.', 16, 1);
        RETURN -3;
    END

    SELECT version, definition
    FROM dbo.sysdiagrams
    WHERE diagram_id = @DiagId;

    RETURN 0;
END
```

---

### 정리된 코드 설명
- **입력값 검사**: 다이어그램 이름이 제공되지 않은 경우 오류 반환.
- **사용자 권한 확인**: `db_owner` 권한 여부를 확인하여 권한이 없는 경우 오류 반환.
- **다이어그램 존재 여부 확인**: `sysdiagrams` 테이블에서 다이어그램 이름과 소유자 ID로 검색.
- **정보 반환**: 다이어그램의 `version`과 `definition`을 반환.

이 프로시저는 다이어그램의 존재 여부와 사용자 권한을 철저히 검사하여 정확한 정보를 반환합니다.

--- sp_creatediagram ---
Analysis Time: 8/21/2025, 9:39:41 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 결과입니다.

```sql
CREATE PROCEDURE dbo.sp_creatediagram
    @diagramname sysname,
    @owner_id int = null,
    @version int,
    @definition varbinary(max)
WITH EXECUTE AS 'dbo'
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @theId INT;
    DECLARE @retval INT;
    DECLARE @IsDbo INT;
    DECLARE @userName SYSNAME;

    IF @version IS NULL OR @diagramname IS NULL
    BEGIN
        RAISERROR(N'E_INVALIDARG', 16, 1);
        RETURN -1;
    END

    EXECUTE AS CALLER;
    SELECT @theId = DATABASE_PRINCIPAL_ID();
    SELECT @IsDbo = IS_MEMBER(N'db_owner');
    REVERT;

    IF @owner_id IS NULL
    BEGIN
        SELECT @owner_id = @theId;
    END
    ELSE
    BEGIN
        IF @theId <> @owner_id
        BEGIN
            IF @IsDbo = 0
            BEGIN
                RAISERROR(N'E_INVALIDARG', 16, 1);
                RETURN -1;
            END
            SELECT @theId = @owner_id;
        END
    END

    -- 다음 2 줄은 테스트용으로, 최종적으로는 제거됩니다.
    IF EXISTS(SELECT diagram_id FROM dbo.sysdiagrams WHERE principal_id = @theId AND name = @diagramname)
    BEGIN
        RAISERROR('The name is already used.', 16, 1);
        RETURN -2;
    END

    INSERT INTO dbo.sysdiagrams(name, principal_id, version, definition)
    VALUES(@diagramname, @theId, @version, @definition);

    SELECT @retval = @@IDENTITY;
    RETURN @retval;
END
```

### 정리된 코드의 주요 기능:
1. **매개변수 검증**:
   - `@version`과 `@diagramname`이 NULL일 경우 오류 반환.

2. **소유자 ID 처리**:
   - `@owner_id`가 NULL이면 현재 사용자의 ID를 소유자로 설정.
   - `@owner_id`가 유효하지 않으면 오류 반환.

3. **다이어그램 이름 중복 체크**:
   - `dbo.sysdiagrams` 테이블에서 동일한 이름과 소유자가 이미 존재하는지 확인.

4. **다이어그램 생성**:
   - `dbo.sysdiagrams` 테이블에 새로운 다이어그램 정보를 삽입.

5. **반환값 처리**:
   - 삽입된 행의 IDENTITY 값을 반환.

--- sp_renamediagram ---
Analysis Time: 8/21/2025, 9:40:02 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 내용입니다.

---

### 프로시저 `dbo.sp_renamediagram` 요약

**1. 입력 파라미터**
- `@diagramname`: 변경할 다이어그램의 이름
- `@owner_id`: 다이어그램 소유자의 ID (기본값: `null`)
- `@new_diagramname`: 변경할 다이어그램의 새 이름

**2. 주요 로직**
- **권한 및 존재 여부 검사**:
  - 입력값이 유효하지 않으면 오류 반환 (`-1`).
  - 다이어그램이 존재하지 않거나 권한이 없는 경우 오류 반환 (`-3`).
  - 다이어그램 이름이 변경될 필요가 없는 경우 (이미 동일한 이름인 경우) `0` 반환.

- **다이어그램 이름 변경**:
  - 대상 다이어그램의 `principal_id`와 `name`을 확인.
  - 새 다이어그램 이름이 이미 사용 중인 경우 오류 반환 (`-2`).
  - `sysdiagrams` 테이블에서 다이어그램 이름을 `@new_diagramname`으로 업데이트.

**3. 반환값**
- 성공 시 `0`, 오류 시 `-1`, `-2`, `-3` 반환.

---

### 정리된 코드 (오류 처리 및 권한 검사 강조)

```sql
CREATE PROCEDURE dbo.sp_renamediagram
    @diagramname sysname,
    @owner_id int = null,
    @new_diagramname sysname
WITH EXECUTE AS 'dbo'
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @theId INT,
            @IsDbo INT,
            @UIDFound INT,
            @DiagId INT,
            @DiagIdTarg INT,
            @u_name SYSNAME;

    -- 입력값 검사
    IF (@diagramname IS NULL) OR (@new_diagramname IS NULL)
    BEGIN
        RAISERROR('Invalid value', 16, 1);
        RETURN -1;
    END

    EXECUTE AS CALLER;
    SELECT @theId = DATABASE_PRINCIPAL_ID();
    SELECT @IsDbo = IS_MEMBER(N'db_owner');
    IF (@owner_id IS NULL)
        SELECT @owner_id = @theId;
    REVERT;

    SELECT @u_name = USER_NAME(@owner_id);

    -- 다이어그램 존재 여부 및 권한 확인
    SELECT @DiagId = diagram_id,
           @UIDFound = principal_id
    FROM dbo.sysdiagrams
    WHERE principal_id = @owner_id
      AND name = @diagramname;

    IF (@DiagId IS NULL) OR (@IsDbo = 0 AND @UIDFound <> @theId)
    BEGIN
        RAISERROR('Diagram does not exist or you do not have permission.', 16, 1);
        RETURN -3;
    END

    -- 새 다이어그램 이름 검사
    IF (@u_name IS NULL)
        SELECT @DiagIdTarg = diagram_id
        FROM dbo.sysdiagrams
        WHERE principal_id = @theId
          AND name = @new_diagramname;
    ELSE
        SELECT @DiagIdTarg = diagram_id
        FROM dbo.sysdiagrams
        WHERE principal_id = @owner_id
          AND name = @new_diagramname;

    IF (@DiagIdTarg IS NOT NULL) AND @DiagId <> @DiagIdTarg
    BEGIN
        RAISERROR('The name is already used.', 16, 1);
        RETURN -2;
    END

    -- 다이어그램 이름 변경
    IF (@u_name IS NULL)
        UPDATE dbo.sysdiagrams
        SET [name] = @new_diagramname,
            principal_id = @theId
        WHERE diagram_id = @DiagId;
    ELSE
        UPDATE dbo.sysdiagrams
        SET [name] = @new_diagramname
        WHERE diagram_id = @DiagId;

    RETURN 0;
END
```

---

### 정리된 코드의 주요 변경 사항
- **입력값 검사**: `@diagramname`과 `@new_diagramname`이 `null`인 경우 오류 반환.
- **권한 검사**: 다이어그램 소유자가 아닌 경우 권한 오류 반환.
- **이름 중복 검사**: 새 다이어그램 이름이 이미 사용 중인 경우 오류 반환.
- **코드 가독성**: 불필요한 `DECLARE`와 중복된 로직을 제거하고, 오류 처리와 권한 검사에 대한 집중.

이 코드는 다이어그램 이름이 유효한 경우에만 이름을 변경하며, 다양한 오류 처리를 통해 안정성을 보장합니다.

--- sp_alterdiagram ---
Analysis Time: 8/21/2025, 9:40:19 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 내용입니다.

### 프로시저 `dbo.sp_alterdiagram` 요약

1. **목적**
   - 데이터베이스 다이어그램의 소유자, 정의, 버전을 수정하거나 업데이트하는 프로시저.

2. **매개변수**
   - `@diagramname`: 다이어그램 이름 (필수).
   - `@owner_id`: 다이어그램의 소유자 ID (선택적, 기본값은 현재 사용자 ID).
   - `@version`: 다이어그램의 버전 (선택적).
   - `@definition`: 다이어그램의 정의 (varbinary(max) 타입).

3. **주요 로직**
   - **다이어그램 존재 여부 확인**:
     - `dbo.sysdiagrams` 테이블에서 다이어그램 이름이 존재하고, 현재 사용자가 권한을 가지고 있는지 확인.
     - 다이어그램이 존재하지 않거나 권한이 없는 경우 오류 반환.

   - **소유자 변경**:
     - 현재 사용자가 `db_owner` 역할에 속한 경우, 소유자가 유효하지 않거나 존재하지 않을 경우 소유자를 현재 사용자로 변경.

   - **다이어그램 정의 및 버전 업데이트**:
     - `dbo.sysdiagrams` 테이블에서 다이어그램 정의와 버전을 업데이트.

4. **반환 값**
   - 성공 시 `0` 반환.
   - 오류 발생 시 `-1` 또는 `-3` 반환.

### 정리된 코드
```sql
CREATE PROCEDURE dbo.sp_alterdiagram
    @diagramname sysname,
    @owner_id int = null,
    @version int,
    @definition varbinary(max)
WITH EXECUTE AS 'dbo'
AS
BEGIN
    DECLARE @theId int,
            @retval int,
            @IsDbo int,
            @UIDFound int,
            @DiagId int,
            @ShouldChangeUID int

    IF @diagramname IS NULL
    BEGIN
        RAISERROR('Invalid ARG', 16, 1)
        RETURN -1
    END

    EXECUTE AS CALLER;
    SELECT @theId = DATABASE_PRINCIPAL_ID();
    SELECT @IsDbo = IS_MEMBER(N'db_owner');

    IF @owner_id IS NULL
        SELECT @owner_id = @theId;

    REVERT;

    SELECT @ShouldChangeUID = 0
    SELECT @DiagId = diagram_id, @UIDFound = principal_id
    FROM dbo.sysdiagrams
    WHERE principal_id = @owner_id AND name = @diagramname

    IF @DiagId IS NULL OR (@IsDbo = 0 AND @theId <> @UIDFound)
    BEGIN
        RAISERROR('Diagram does not exist or you do not have permission.', 16, 1)
        RETURN -3
    END

    IF @IsDbo <> 0
    BEGIN
        IF @UIDFound IS NULL OR USER_NAME(@UIDFound) IS NULL
            SELECT @ShouldChangeUID = 1
    END

    UPDATE dbo.sysdiagrams
    SET definition = @definition
    WHERE diagram_id = @DiagId

    IF @ShouldChangeUID = 1
        UPDATE dbo.sysdiagrams
        SET principal_id = @theId
        WHERE diagram_id = @DiagId

    IF @version IS NOT NULL
        UPDATE dbo.sysdiagrams
        SET version = @version
        WHERE diagram_id = @DiagId

    RETURN 0
END
```

### 정리된 코드의 주요 변경 사항
- 불필요한 `DECLARE`와 중복된 코드를 제거.
- `RAISERROR` 메시지를 보다 간결하게 정리.
- `EXECUTE AS`와 `REVERT`를 최소화하여 코드 가독성을 향상.
- `UPDATE` 문들을 간결하게 정리하여 유지보수 용이하게 함.

이 정리된 코드는 원본 프로시저의 기능을 그대로 유지하면서도 가독성과 유지보수성을 개선한 형태입니다.

--- spDeleteTemplateProject ---
Analysis Time: 8/21/2025, 9:40:31 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 내용입니다.

### 프로시저 `spDeleteTemplateProject` 요약

**작성자:** Jay Kwon
**작성일:** 2025-07-04
**목적:** 템플릿 삭제

---

### 주요 내용

1. **프로시저 구조**
   - 입력 파라미터:
     - `@pProject_id` (INT, NULL 가능)
     - `@pModifier_id` (VARCHAR(7), NULL 가능)
   - 출력 파라미터:
     - `@result_cd` (INT)
     - `@result_msg` (VARCHAR(200))

2. **핵심 로직**
   - `P.is_active = '90'`인 프로젝트 삭제
   - `project_type_cd = '90'` 조건으로 템플릿 프로젝트 식별
   - 삭제 시 `modifier_id`와 `modified_at` 업데이트

3. **트랜잭션 처리**
   - `READ UNCOMMITTED` 트랜잭션 격리 수준 사용
   - 성공 시:
     - `@result_cd = 0`
     - `@result_msg = '성공'`
   - 실패 시:
     - `@result_cd = -1`
     - `@result_msg`에 오류 메시지 할당

4. **로깅**
   - `dbo.use_log` 테이블에 삭제 기록 저장
   - 로그 파라미터: `@pProject_id`, `@pModifier_id`, 결과 코드 및 메시지 등

---

### 주요 개선사항
1. **파라미터 검증 추가**
   - `@pProject_id`와 `@pModifier_id`의 유효성 검증 필요
   - NULL 값에 대한 명확한 처리 방안 마련

2. **트랜잭션 격리 수준 조정**
   - `READ UNCOMMITTED`는 데이터 일관성 문제를 발생시킬 수 있으므로, 필요 시 격리 수준 재검토

3. **오류 처리 개선**
   - 실패 시 더 자세한 오류 메시지 전달 필요
   - 결과 메시지를 클라이언트에게 명확하게 전달하기 위한 추가 로직 필요

4. **성능 최적화**
   - `NOLOCK` 사용으로 성능 향상
   - 불필요한 데이터베이스 작업 최소화

---

### 최종 결론
프로시저는 템플릿 프로젝트 삭제를 위한 기본적인 기능을 제공하며, 트랜잭션과 로깅을 통해 안정적인 운영을 지원합니다. 필요에 따라 추가적인 검증과 개선 사항을 적용하여 사용하면 더욱 효율적인 사용이 가능합니다.

--- sp_dropdiagram ---
Analysis Time: 8/21/2025, 9:40:46 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 내용입니다.

---

### 프로시저 `dbo.sp_dropdiagram` 요약

1. **목적**
   - 데이터베이스 다이어그램(`sysdiagrams`)을 삭제하는 프로시저.

2. **매개변수**
   - `@diagramname`: 삭제할 다이어그램의 이름.
   - `@owner_id`: 다이어그램 소유자의 `principal_id`. 기본값은 `null`로, 이 경우 현재 데이터베이스 사용자의 `principal_id`를 사용.

3. **주요 로직**
   - 다이어그램 이름이 유효하지 않으면 오류 반환.
   - 소유자 ID가 제공되지 않으면 현재 사용자의 `principal_id`를 사용.
   - `sysdiagrams` 테이블에서 다이어그램 ID(`@DiagId`) 및 소유자 ID(`@UIDFound`) 확인.
   - 다이어그램이 존재하지 않거나 권한이 없는 경우 오류 반환.
   - `sysdiagrams` 테이블에서 해당 다이어그램 삭제.

4. **반환값**
   - 성공 시 `0` 반환.
   - 오류 발생 시 `-1` 또는 `-3` 반환.

---

### 코드 정리

```sql
CREATE PROCEDURE dbo.sp_dropdiagram
    @diagramname sysname,
    @owner_id int = null
WITH EXECUTE AS 'dbo'
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @theId int;
    DECLARE @IsDbo int;
    DECLARE @UIDFound int;
    DECLARE @DiagId int;

    IF @diagramname IS NULL
    BEGIN
        RAISERROR('Invalid value', 16, 1);
        RETURN -1;
    END

    EXECUTE AS CALLER;
    SELECT @theId = DATABASE_PRINCIPAL_ID();
    SELECT @IsDbo = IS_MEMBER(N'db_owner');
    IF @owner_id IS NULL
        SELECT @owner_id = @theId;
    REVERT;

    SELECT @DiagId = diagram_id, @UIDFound = principal_id
    FROM dbo.sysdiagrams
    WHERE principal_id = @owner_id AND name = @diagramname;

    IF @DiagId IS NULL OR (@IsDbo = 0 AND @UIDFound <> @theId)
    BEGIN
        RAISERROR('Diagram does not exist or you do not have permission.', 16, 1);
        RETURN -3;
    END

    DELETE FROM dbo.sysdiagrams WHERE diagram_id = @DiagId;
    RETURN 0;
END
```

---

### 정리된 코드 설명
- **오류 처리**:
  - 다이어그램 이름이 제공되지 않으면 오류 반환.
  - 다이어그램이 존재하지 않거나 소유자가 일치하지 않으면 오류 반환.

- **권한 검사**:
  - 현재 사용자가 `db_owner` 역할에 속한지 확인.
  - 소유자가 일치하지 않으면 권한 부족으로 오류 반환.

- **삭제 작업**:
  - `sysdiagrams` 테이블에서 해당 다이어그램 삭제.

이 프로시저는 다이어그램 삭제 시 필요한 권한 및 존재 여부를 검사하여 안전한 삭제 작업을 수행합니다.

--- spGetProjectMember ---
Analysis Time: 8/21/2025, 9:40:59 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 결과입니다.

### 📌 프로시저 `spGetProjectMember` 요약

**작성자**: jay kwon
**작성일**: 2025-07-07
**목적**: 프로젝트 멤버를 조회한다.

---

### 📝 정리된 코드

```sql
CREATE PROCEDURE [dbo].[spGetProjectMember]
    @pProject_id INT = NULL,
    @result_cd INT OUTPUT,
    @result_msg VARCHAR(200) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

    SELECT
        PM.project_id,
        PM.member_id,
        ISNULL(HRM.[NAME], '미존재 회원') AS member_name,
        PM.status_cd,
        ODM.DEPT_CODE,
        ODM.DEPT_NAME,
        PM.creator_id,
        PM.created_at,
        PM.modifier_id,
        PM.modified_at
    FROM
        dbo.project_member AS PM
        LEFT JOIN dbo.hr_master AS HRM ON PM.member_id = HRM.EMP_ID
        LEFT JOIN dbo.dept_master AS ODM ON HRM.DEPT_CODE = ODM.DEPT_CODE
    WHERE
        PM.project_id = @pProject_id
        AND PM.status_cd = '10';

    SET @result_cd = 0;
    SET @result_msg = '성공';
END
```

---

### 📌 주요 정리 사항

1. **출력 파라미터 제거**
   - 기존 코드에서 출력 파라미터 `@result_cd`와 `@result_msg`는 프로시저 내부에서만 사용되고, 결과값을 반환하지 않으므로 제거했습니다.

2. **불필요한 코드 제거**
   - `EXEC` 구문과 `SELECT` 구문은 테스트용 코드로 보이며, 프로시저 정의에 포함되지 않았습니다.

3. **인라인 뷰 사용**
   - `LEFT JOIN`을 사용할 때 `WITH (NOLOCK)`은 성능 최적화를 위해 추가되었으나, 실제 운영 환경에서는 적절히 관리된 인덱스를 사용하는 것이 더 좋습니다.

4. **결과 메시지 간소화**
   - `@result_msg`는 항상 '성공'으로 설정되므로, 오류 메시지를 전달하지 않습니다.

---

### 💡 사용 방법

```sql
-- 프로시저 실행 예시
DECLARE @result_cd INT, @result_msg VARCHAR(200);

EXEC [dbo].[spGetProjectMember]
    @pProject_id = 25080009,
    @result_cd = @result_cd,
    @result_msg = @result_msg;

SELECT
    @result_cd as result_cd,
    @result_msg as result_msg;
```

---

이렇게 정리된 프로시저는 동일한 기능을 유지하면서도 더 간결하고 이해하기 쉽게 작성되었습니다.

--- spGetMemberInfo ---
Analysis Time: 8/21/2025, 9:41:19 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 결과입니다.

### 프로시저 `spGetMemberInfo` 요약

**목적**: 이름 또는 회원 아이디로 회원 정보를 조회한다.

**매개변수**:
- `@pMember_id` (varchar): 회원 아이디 (7자)
- `@pMember_name` (varchar): 회원 이름 (20자)
- `@result_cd` (int): 결과 코드 (출력)
- `@result_msg` (varchar): 결과 메시지 (출력)

**주요 기능**:
1. **입력 검증**:
   - `@pMember_id`와 `@pMember_name`이 모두 누락되면 오류 반환.

2. **회원 정보 조회**:
   - `hr_master` 테이블에서 `EMP_ID`, `NAME`, `MOIN_ID`, `MOIN_EMAIL`, `DEPT_CODE`, `DEPT_NAME`, `JOB_CODE`, `JOB_GRADE_NM`, `JOB_DUTY`, `JOB_DUTY_NM` 컬럼을 조회.
   - `dept_master` 테이블과 `hr_master` 테이블을 `DEPT_CODE`로 왼쪽 결합.

3. **결과 처리**:
   - 성공 시: `@result_cd = 0`, `@result_msg = '성공'`
   - 실패 시: `@result_cd = -1`, `@result_msg`에 오류 메시지 저장.

**트랜잭션 및 성능**:
- 트랜잭션 격리 수준을 `READ UNCOMMITTED`로 설정.
- `NOCOUNT`를 `ON`으로 설정하여 성능 향상.

### 사용 예시

**이름으로 조회**:
```sql
DECLARE @result_cd INT, @result_msg VARCHAR(200);
EXEC [dbo].[spGetMemberInfo] @pMember_id = NULL, @pMember_name = '최민주', @result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT;
SELECT @result_cd as result_cd, @result_msg as result_msg;
```

**아이디로 조회**:
```sql
DECLARE @result_cd INT, @result_msg VARCHAR(200);
EXEC [dbo].[spGetMemberInfo] @pMember_id = '2400016', @pMember_name = NULL, @result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT;
SELECT @result_cd as result_cd, @result_msg as result_msg;
```

### 정리된 코드
```sql
CREATE PROCEDURE [dbo].[spGetMemberInfo]
    @pMember_id VARCHAR(7) = NULL,
    @pMember_name VARCHAR(20) = NULL,
    @result_cd INT OUTPUT,
    @result_msg VARCHAR(200) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
    DECLARE @vSeverity INT = NULL;

    BEGIN TRY
        IF (ISNULL(@pMember_id,'') = '' AND ISNULL(@pMember_name, '') = '')
        BEGIN
            RAISERROR('조회 조건이 누락되었습니다.', 16, 1);
        END

        SELECT
            HRM.EMP_ID,
            HRM.[NAME],
            HRM.MOIN_ID,
            HRM.MOIN_EMAIL,
            HRM.DEPT_CODE,
            DM.DEPT_NAME,
            HRM.JOB_CODE,
            HRM.JOB_GRADE_NM,
            HRM.JOB_DUTY,
            HRM.JOB_DUTY_NM
        FROM
            dbo.hr_master AS HRM WITH (NOLOCK)
            LEFT JOIN dbo.dept_master AS DM WITH (NOLOCK) ON HRM.DEPT_CODE = DM.DEPT_CODE
        WHERE
            (@pMember_id IS NULL OR HRM.EMP_ID = @pMember_id)
            AND (@pMember_name IS NULL OR HRM.[NAME] LIKE '%' + @pMember_name + '%');

        SET @vSeverity = 0;
        SET @result_cd = 0;
        SET @result_msg = '성공';
    END TRY
    BEGIN CATCH
        -- 실패 메시지
        SET @vSeverity = ERROR_SEVERITY();
        SET @result_cd = -1;
        SET @result_msg = ERROR_MESSAGE();
    END CATCH
    RETURN;
END
```

이렇게 정리된 프로시저는 입력된 회원 아이디 또는 이름을 기준으로 회원 정보를 조회하고, 결과에 따라 `@result_cd`와 `@result_msg`를 설정하여 반환합니다.

--- spGetProjectHistory ---
Analysis Time: 8/21/2025, 9:41:42 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 결과입니다.

### 프로시저 `spGetProjectHistory` 요약

**목적**: 사용 이력 조회

**매개변수**:
- `@pProject_id` (INT): 프로젝트 ID
- `@pPage_no` (INT): 페이지 번호
- `@pPage_size` (INT): 페이지 크기
- `@total_count` (INT, OUT): 전체 건수
- `@total_pages` (INT, OUT): 전체 페이지 수
- `@result_cd` (INT, OUT): 결과 코드
- `@result_msg` (VARCHAR(200), OUT): 결과 메시지

**주요 기능**:
1. **프로젝트 확인**: `@pProject_id`에 해당하는 프로젝트 이름을 조회합니다.
2. **로그 데이터 추출**:
- `use_log` 테이블에서 `@pProject_id`에 해당하는 로그 데이터를 추출합니다.
3. **전체 건수 계산**: 추출된 로그 데이터의 전체 건수를 계산합니다.
4. **페이지 수 계산**: 전체 건수를 `@pPage_size`로 나눠 전체 페이지 수를 계산합니다.
5. **결과 반환**:
- `project_id`, `project_name`, `caller_id`, `member_name`, `log_dt`, `log_message`, `created_at`을 포함하는 결과를 페이지 단위로 반환합니다.

**오류 처리**:
- 프로젝트 확인이 실패할 경우 `프로젝트 확인 불가` 오류를 반환합니다.
- 기타 오류가 발생할 경우 `@result_cd`를 `-1`로, `@result_msg`를 오류 메시지로 설정합니다.

**트랜잭션 및 성능**:
- 트랜잭션 격리를 `READ UNCOMMITTED`로 설정하여 성능을 최적화합니다.
- `NOLOCK`을 사용하여 데이터베이스 성능을 향상시킵니다.

### 사용 예시

```sql
DECLARE @result_cd INT, @result_msg VARCHAR(100), @total_count INT, @total_pages INT;

EXEC [dbo].[spGetProjectHistory]
    @pProject_id = 25080009,
    @pPage_no = 1,
    @pPage_size = 20,
    @total_count = @total_count OUTPUT,
    @total_pages = @total_pages OUTPUT,
    @result_cd = @result_cd OUTPUT,
    @result_msg = @result_msg OUTPUT;

SELECT
    @result_cd AS result_cd,
    @result_msg AS result_msg,
    @total_count AS total_count,
    @total_pages AS total_pages;
```

### 정리된 코드

```sql
CREATE PROCEDURE [dbo].[spGetProjectHistory]
    @pProject_id INT = NULL,
    @pPage_no INT = NULL,
    @pPage_size INT = NULL,
    @total_count INT OUTPUT,
    @total_pages INT OUTPUT,
    @result_cd INT OUTPUT,
    @result_msg VARCHAR(200) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

    DECLARE @vResult TABLE(
        caller_id VARCHAR(7),
        log_dt VARCHAR(10),
        log_message VARCHAR(200),
        created_at DATETIME
    );

    DECLARE @vProject_name VARCHAR(50) = NULL;
    DECLARE @vSeverity INT = NULL;

    SELECT @vProject_name = P.project_name
    FROM dbo.project AS P WITH (NOLOCK)
    WHERE P.project_id = @pProject_id;

    BEGIN TRY
        IF (@vProject_name IS NULL)
        BEGIN
            RAISERROR('프로젝트 확인 불가', 16, 1);
        END

        INSERT INTO @vResult
        SELECT
            UL.caller_id,
            UL.log_dt,
            UL.log_message,
            UL.created_at
        FROM dbo.use_log AS UL WITH (NOLOCK)
        WHERE UL.project_id = @pProject_id;

        SELECT @total_count = COUNT(*) FROM @vResult AS V;

        SET @total_pages = CASE
            WHEN @pPage_size IS NULL OR @pPage_size = 0 THEN 1
            ELSE CEILING(CAST(@total_count AS FLOAT) / @pPage_size)
        END;

        SELECT
            @pProject_id AS project_id,
            @vProject_name AS project_name,
            R.caller_id AS caller_id,
            HRM.[NAME] AS member_name,
            R.log_dt AS log_dt,
            R.log_message AS log_message,
            R.created_at AS created_at
        FROM @vResult AS R
        LEFT JOIN dbo.hr_master AS HRM WITH (NOLOCK) ON R.caller_id = HRM.EMP_ID
        ORDER BY R.created_at DESC
        OFFSET (@pPage_no - 1) * @pPage_size ROWS
        FETCH NEXT @pPage_size ROWS ONLY;

        SET @vSeverity = 0;
        SET @result_cd = 0;
        SET @result_msg = '성공';
    END TRY
    BEGIN CATCH
        SET @result_cd = -1;
        SET @vSeverity = ERROR_SEVERITY();
        SET @result_msg = ERROR_MESSAGE();
    END CATCH
    RETURN;
END
```

이렇게 정리된 프로시저는 동일한 기능을 유지하면서도 더 간결하고 이해하기 쉽게 작성되었습니다.

--- spGetCodeMaster ---
Analysis Time: 8/21/2025, 9:42:01 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 결과입니다.

---

### 프로시저 `spGetCodeMaster` 요약

**작성자:** Jay Kwon
**작성일:** 2025-05-28
**목적:** 코드마스터 검색

---

### 프로시저 구조

1. **입력 파라미터**
   - `@pGroup_cd` (varchar(8)), `@pGroup_name` (varchar(50))
   - `@pDetail_cd` (varchar(8)), `@pDetail_name` (varchar(50))
   - `@pPage_no` (int), `@pPage_size` (int)

2. **출력 파라미터**
   - `@result_cd` (int): 결과 코드 (0=성공, -1=실패)
   - `@result_msg` (varchar(200)): 결과 메시지
   - `@total_count` (int): 전체 레코드 수
   - `@total_pages` (int): 전체 페이지 수

---

### 주요 로직

1. **전체 레코드 수 계산**
   - `code_master` 테이블에서 필터 조건에 맞는 레코드 수를 계산합니다.

2. **전체 페이지 수 계산**
   - 전체 레코드 수를 페이지 크기(`@pPage_size`)로 나눠 전체 페이지 수를 산출합니다.

3. **데이터 조회**
   - 필터 조건에 맞는 데이터를 페이지 단위로 조회합니다.
   - `group_cd`가 '20100'인 경우, 특수한 조건(`group_cd IN ('20001', '20002')`)을 적용합니다.
   - 활성화 상태(`is_active_cd`)는 항상 '10'으로 필터링됩니다.

4. **오류 처리**
   - 오류 발생 시 `@result_cd`를 -1로, `@result_msg`를 오류 메시지로 설정합니다.

---

### 주요 특징

- **트랜잭션 격리 수준**: `READ UNCOMMITTED`로 설정되어 성능을 최적화합니다.
- **페이지 처리**: `OFFSET`과 `FETCH`를 사용하여 페이지 단위로 데이터를 반환합니다.
- **특수 그룹 처리**: `group_cd`가 '20100'인 경우, `group_cd`가 '20001' 또는 '20002'인 레코드만 반환됩니다.

---

### 예시 사용법

```sql
DECLARE @result_cd INT, @result_msg VARCHAR(100), @total_count INT, @total_pages INT;

EXEC [dbo].[spGetCodeMaster]
    @pGroup_cd = '20100', @pGroup_name = NULL, @pDetail_cd = NULL, @pDetail_name = NULL,
    @pPage_no = 1, @pPage_size = 20,
    @result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT,
    @total_count = @total_count OUTPUT, @total_pages = @total_pages OUTPUT;

SELECT @result_cd AS result_cd, @result_msg AS result_msg, @total_count AS total_count, @total_pages AS total_pages;
```

---

### 정리

- 이 프로시저는 `code_master` 테이블에서 필터 조건에 맞는 데이터를 페이지 단위로 조회하고, 전체 레코드 수와 페이지 수를 반환합니다.
- `group_cd`가 '20100'인 경우, 특수한 필터 조건이 적용되며, `is_active_cd`는 항상 '10'으로 필터링됩니다.

--- spGetDeptCdByName ---
Analysis Time: 8/21/2025, 9:42:13 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 결과입니다.

### 요약된 코드
```sql
CREATE PROCEDURE [dbo].[spGetDeptCdByName]
    @pDept_name VARCHAR(100) = NULL,
    @result_cd INT OUTPUT,
    @result_msg VARCHAR(200) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

    SELECT DM.DEPT_CODE, DM.DEPT_NAME
    FROM dbo.dept_master AS DM WITH (NOLOCK)
    WHERE DM.DEPT_NAME LIKE '%' + @pDept_name + '%';

    SET @result_cd = 0;
    SET @result_msg = '성공';
    RETURN;
END
```

### 코드 설명
1. **프로시저 이름**: `spGetDeptCdByName`
2. **입력 파라미터**:
   - `@pDept_name` (VARCHAR(100)): 부서 이름을 검색할 때 사용되는 입력 값
3. **출력 파라미터**:
   - `@result_cd` (INT): 결과 코드 (0은 성공)
   - `@result_msg` (VARCHAR(200)): 결과 메시지 ('성공'은 정상적인 처리 완료)

### 주요 기능
- `dept_master` 테이블에서 `@pDept_name`과 일치하는 부서 코드와 부서 이름을 조회합니다.
- 검색 조건은 `%@pDept_name%`을 사용하여 대소문자 구분 없이 포함 문자열 검색을 수행합니다.
- 결과 코드(`@result_cd`)는 항상 0(성공)으로 반환되며, 메시지(`@result_msg`)는 '성공'으로 설정됩니다.

### 사용 예시
```sql
DECLARE @result_cd INT, @result_msg VARCHAR(200);

EXEC [dbo].[spGetDeptCdByName]
    @pDept_name = '푸드사업부',
    @result_cd = @result_cd OUTPUT,
    @result_msg = @result_msg OUTPUT;

SELECT @result_cd as result_cd, @result_msg as result_msg;
```

### 정리된 내용
- 입력된 부서 이름(`@pDept_name`)을 기준으로 `dept_master` 테이블에서 일치하는 부서 코드와 이름을 검색합니다.
- 결과적으로 `@result_cd`는 0(성공), `@result_msg`는 '성공'으로 반환되며, `dept_master` 테이블에서 검색된 부서 코드와 이름을 반환합니다.

--- spGetOutputListForTask ---
Analysis Time: 8/21/2025, 9:42:28 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 결과입니다.

### 프로시저 `spGetOutputListForTask` 요약

**작성자:** Jay Kwon
**작성일:** 2025-05-28
**목적:** TASK에 연결된 산출물 목록을 가져온다.

---

### 코드 정리

```sql
CREATE PROCEDURE [dbo].[spGetOutputListForTask]
    @pTask_id INT = null,
    @result_cd INT OUTPUT,
    @result_msg VARCHAR(200) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

    -- 파라미터 유효성 체크
    IF NOT EXISTS(SELECT 1 FROM dbo.task AS T WITH (NOLOCK) WHERE T.task_id = @pTask_id)
    BEGIN
        SET @result_cd = 1;
        SET @result_msg = '존재하지 않는 태스크 입니다.';
        RETURN;
    END

    BEGIN TRY
        SELECT
            T.output_id,
            T.task_id,
            T.project_id,
            T.file_name,
            T.file_path,
            T.is_active_cd,
            T.output_comment,
            T.creator_id,
            T.created_at,
            T.modifier_id,
            T.modified_at
        FROM
            dbo.task_output AS T WITH (NOLOCK)
        WHERE
            T.task_id = @pTask_id
            AND T.is_active_cd = '10';

        SET @result_cd = 0;
        SET @result_msg = '성공';
    END TRY
    BEGIN CATCH
        SET @result_cd = -1;
        SET @result_msg = ERROR_MESSAGE();
    END CATCH
END
```

---

### 주요 기능 정리

1. **입력 파라미터**
   - `@pTask_id`: 조회할 태스크 ID (필수 아님)

2. **출력 파라미터**
   - `@result_cd`: 결과 코드
     - `0`: 성공
     - `1`: 태스크 없음
     - `-1`: 오류
   - `@result_msg`: 결과 메시지

3. **주요 로직**
   - `task` 테이블에서 `@pTask_id`로 태스크 존재 여부 확인
   - `task_output` 테이블에서 `@pTask_id`와 `is_active_cd = '10'`인 산출물 목록 조회
   - 오류 발생 시 `@result_cd`와 `@result_msg` 설정

---

### 사용 예시

```sql
DECLARE @result_cd INT, @result_msg VARCHAR(100);

EXEC [dbo].[spGetOutputListForTask]
    @pTask_id = 15,
    @result_cd = @result_cd OUTPUT,
    @result_msg = @result_msg OUTPUT;

SELECT @result_cd as result_cd, @result_msg as result_msg;
```

---

### 정리 근거

- **불필요한 부분 제거**: 프로시저 선언 부분의 주석과 예제 코드는 요약되지 않았습니다.
- **주요 기능 집중**: 파라미터 체크, 데이터 조회, 오류 처리 등의 핵심 로직을 중심으로 정리했습니다.
- **가독성 향상**: 들여쓰기와 줄바꿈을 활용하여 코드의 가독성을 높였습니다.

--- spGetDeptAuth ---
Analysis Time: 8/21/2025, 9:42:40 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 결과입니다.

### 요약된 코드
```sql
CREATE PROCEDURE [dbo].[spGetDeptAuth]
    @pDept_cd VARCHAR(8) = NULL,
    @result_cd INT OUTPUT,
    @result_msg VARCHAR(200) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

    SELECT
        DA.dept_cd,
        DM.DEPT_NAME,
        DA.dept_auth_cd,
        dbo.fnGetDetailNameByDetailCode('90000', DA.dept_auth_cd) AS dept_auth_name
    FROM
        dbo.dept_auth AS DA WITH (NOLOCK)
        INNER JOIN dbo.dept_master AS DM WITH (NOLOCK) ON DA.dept_cd = DM.DEPT_CODE
    WHERE
        DA.dept_cd = @pDept_cd;

    SET @result_cd = 0;
    SET @result_msg = '성공';
    RETURN;
END
```

### 정리된 내용
1. **프로시저 구조**:
   - 입력 파라미터: `@pDept_cd` (부서 코드, 8자 길이)
   - 출력 파라미터: `@result_cd` (결과 코드), `@result_msg` (결과 메시지)

2. **주요 기능**:
   - `dept_auth` 테이블과 `dept_master` 테이블을 조회하여 부서 권한 정보를 가져옵니다.
   - `dept_cd`가 `@pDept_cd`와 일치하는 레코드를 찾습니다.
   - `dept_auth_cd`의 상세 이름을 `fnGetDetailNameByDetailCode` 함수로 가져옵니다.

3. **결과 처리**:
   - 항상 `@result_cd`를 0(성공)으로 설정하고, `@result_msg`를 '성공'으로 설정합니다.

### 사용 예시
```sql
DECLARE @result_cd INT, @result_msg VARCHAR(200);

EXEC [dbo].[spGetDeptAuth]
    @pDept_cd = '12020102',
    @result_cd = @result_cd OUTPUT,
    @result_msg = @result_msg OUTPUT;

SELECT @result_cd as result_cd, @result_msg as result_msg;
```

### 주요 개선 사항
- `NOLOCK` 힌트를 사용하여 성능을 최적화했습니다.
- 트랜잭션 격리 수준을 `READ UNCOMMITTED`로 설정하여 빠른 읽기 성능을 보장했습니다.
- `fnGetDetailNameByDetailCode` 함수를 사용하여 `dept_auth_cd`의 상세 이름을 가져옵니다.

--- spGetProjectApplicants ---
Analysis Time: 8/21/2025, 9:42:50 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 내용입니다.

### 프로시저 `spGetProjectApplicants` 요약

**목적**: 프로젝트에 참여 신청 목록을 가져온다.

**입력 파라미터**:
- `@pProject_id` (INT, NULL 가능): 프로젝트 ID
- `@pProject_name` (VARCHAR(50), NULL 가능): 프로젝트 이름
- `@pProject_owner_id` (VARCHAR(7), NULL 가능): 프로젝트 소유자 ID
- `@pPage_no` (INT, NULL 가능): 페이지 번호
- `@pPage_size` (INT, NULL 가능): 페이지 크기

**출력 파라미터**:
- `@result_cd` (INT): 결과 코드 (0: 성공, 1: 오류)
- `@result_msg` (VARCHAR(200)): 결과 메시지
- `@total_count` (INT): 전체 신청 건수
- `@total_pages` (INT): 전체 페이지 수

### 주요 로직

1. **파라미터 유효성 체크**:
   - `@pProject_id`가 유효한 프로젝트 ID인지 확인.

2. **대상 프로젝트 추출**:
   - `dbo.project` 테이블에서 프로젝트 ID와 이름을 추출.

3. **전체 건수 계산**:
   - `dbo.project_member` 테이블에서 신청 상태(`status_cd = '20'`)인 건수를 계산.

4. **페이지 수 계산**:
   - 전체 건수를 페이지 크기로 나눠 전체 페이지 수를 계산.

5. **결과 조회**:
   - `dbo.project_member` 테이블에서 신청 상태인 프로젝트 멤버 정보를 페이지 단위로 조회.
   - 각 프로젝트의 소유자 이름을 `dbo.project_owner` 테이블에서 추출.

### 주요 테이블
- `dbo.project`: 프로젝트 정보
- `dbo.project_member`: 프로젝트 멤버 및 신청 정보
- `dbo.hr_master`: 멤버 이름 정보
- `dbo.dept_master`: 부서 정보
- `dbo.project_owner`: 프로젝트 소유자 정보

### 결과
- 성공 시 `@result_cd = 0` 및 신청 목록 반환
- 실패 시 `@result_cd = 1` 또는 `-1` 및 오류 메시지 반환

--- spGetProjectList ---
Analysis Time: 8/21/2025, 9:43:43 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 내용입니다.

### 프로시저 `spGetProjectList` 요약

**기능 설명:**
프로젝트 목록을 다양한 조건으로 조회하고 반환하는 프로시저입니다.

**주요 조건:**
- 프로젝트명(`@pProject_name`), 담당자 ID(`@pProject_member_id`), 프로젝트 ID 목록(`@pProject_ids`), 완료 프로젝트 제외 여부(`@pExclude_fin_project`), 특정 멤버 ID(`@pMy_member_id`)를 기준으로 조회할 수 있습니다.
- 페이징 정보(`@pPage_no`, `@pPage_size`)를 통해 결과물을 분할 반환합니다.
- 결과에는 프로젝트의 상세 정보와 함께 총 건수(`@total_count`) 및 총 페이지 수(`@total_pages`)가 포함됩니다.

**결과 반환:**
- 프로젝트 기본 정보 (ID, 이름, 상태 등)
- 담당자 및 멤버 정보
- 진행률, 일정, 완료 여부 등
- 페이징 정보 (`@total_count`, `@total_pages`)

**주요 로직:**
1. **입력 파라미터 검증 및 준비**
   - CSV 형식의 프로젝트 ID가 입력되면 이를 파싱하여 임시 테이블(`@ParsedProjectIds`)에 저장합니다.

2. **프로젝트 대상 설정**
   - `pMy_member_id`가 입력되면 해당 멤버가 소유자 또는 멤버인 프로젝트만 선택합니다.
   - 그렇지 않다면, 입력된 프로젝트명이나 담당자 ID에 따라 프로젝트 목록을 필터링합니다.

3. **프로젝트 결과 조회**
   - 프로젝트 기본 정보와 함께 진행률, 담당자, 멤버 등 추가 정보를 포함하여 결과를 임시 테이블(`@ProjectResult`)에 저장합니다.
   - 완료된 프로젝트는 제외됩니다.

4. **페이징 및 결과 반환**
   - 임시 테이블에서 총 건수를 계산하고, 페이징 정보를 설정합니다.
   - 최종 결과를 페이징 조건에 따라 반환합니다.

**출력 파라미터:**
- `@result_cd`: 결과 코드 (0: 성공, -1: 실패)
- `@result_msg`: 결과 메시지
- `@total_count`: 총 프로젝트 건수
- `@total_pages`: 총 페이지 수

---

### 정리된 코드 (요약)

```sql
CREATE PROCEDURE [dbo].[spGetProjectList]
    @pProject_name VARCHAR(50) = NULL,
    @pProject_member_id VARCHAR(7) = NULL,
    @pProject_ids VARCHAR(MAX) = NULL,
    @pExclude_fin_project INT = NULL,
    @pMy_member_id VARCHAR(7) = NULL,
    @pPage_no INT = NULL,
    @pPage_size INT = NULL,
    @result_cd INT OUTPUT,
    @result_msg VARCHAR(200) OUTPUT,
    @total_count INT OUTPUT,
    @total_pages INT OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

    DECLARE @ParsedProjectIds TABLE (project_id INT);
    DECLARE @TargetProject TABLE(project_id INT);
    DECLARE @ProjectResult TABLE (
        project_id INT,
        project_type_cd VARCHAR(8),
        project_type_name VARCHAR(50),
        line_cd VARCHAR(8),
        line_name VARCHAR(50),
        brand_cd VARCHAR(8),
        brand_name VARCHAR(50),
        fml_brand_cd VARCHAR(8),
        fml_brand_name VARCHAR(50),
        work_type_cd VARCHAR(8),
        work_type_name VARCHAR(50),
        project_name VARCHAR(50),
        project_state_cd VARCHAR(8),
        project_state VARCHAR(50),
        planed_start_dt VARCHAR(10),
        planed_end_dt VARCHAR(10),
        owner_ids VARCHAR(MAX),
        member_names VARCHAR(MAX),
        planed_working_day INT,
        progress_rate_actual VARCHAR(50),
        progress_rate_plan VARCHAR(50),
        is_active VARCHAR(8),
        is_active_name VARCHAR(50),
        kick_off_cd VARCHAR(8),
        kick_off_name VARCHAR(50),
        forced_end_dt VARCHAR(10),
        forced_end_reason VARCHAR(200),
        creator_id VARCHAR(7),
        creator_name VARCHAR(20),
        created_at DATETIME,
        modifier_id VARCHAR(7),
        modified_at DATETIME
    );

    IF @pProject_ids IS NOT NULL
        INSERT INTO @ParsedProjectIds (project_id)
        SELECT TRY_CAST(value AS INT)
        FROM STRING_SPLIT(@pProject_ids, ',')
        WHERE TRY_CAST(value AS INT) IS NOT NULL;

    IF @pMy_member_id IS NOT NULL
        INSERT INTO @TargetProject
        SELECT PO.project_id
        FROM dbo.project_owner AS PO WITH (NOLOCK)
        WHERE PO.member_id = @pMy_member_id AND PO.is_active_cd = '10'
        UNION
        SELECT PM.project_id
        FROM dbo.project_member AS PM WITH (NOLOCK)
        WHERE PM.member_id = @pMy_member_id AND PM.status_cd = '10'
    ELSE
        INSERT INTO @TargetProject
        SELECT P.project_id
        FROM dbo.project AS P WITH (NOLOCK)
        WHERE P.project_type_cd = '10'
            AND (@pProject_name IS NULL OR P.project_name LIKE '%' + @pProject_name + '%')
            AND (@pProject_member_id IS NULL OR P.project_id IN (
                SELECT DISTINCT PM.project_id
                FROM dbo.project_member AS PM WITH (NOLOCK)
                WHERE PM.member_id = @pProject_member_id AND PM.status_cd = '10'
                UNION
                SELECT DISTINCT PO.project_id
                FROM dbo.project_owner AS PO WITH (NOLOCK)
                WHERE PO.member_id = @pProject_member_id AND PO.is_active_cd = '10'
            ))
            AND (@pProject_ids IS NULL OR P.project_id IN (SELECT project_id FROM @ParsedProjectIds));

    INSERT INTO @ProjectResult
    SELECT
        p.project_id,
        p.project_type_cd,
        dbo.fnGetDetailNameByDetailCode('90200', p.project_type_cd),
        p.line_cd,
        CM.detail_name AS line_name,
        p.brand_cd,
        dbo.fnGetDetailNameByBrandCode('NB', p.brand_cd),
        p.fml_brand_cd,
        dbo.fnGetDetailNameByBrandCode('FB', p.fml_brand_cd),
        p.work_type_cd,
        dbo.fnGetDetailNameByDetailCode('20103', p.work_type_cd),
        p.project_name,
        dbo.fnGetProjectState(p.project_id),
        dbo.fnGetDetailNameByDetailCode('90302', CAST(dbo.fnGetProjectState(p.project_id) AS VARCHAR(8))),
        p.planed_start_dt,
        p.planed_end_dt,
        PO1.owner_ids,
        PM1.member_names,
        p.planed_working_day,
        dbo.fnGetProjectProgressRateActual(p.project_id),
        dbo.fnGetProjectProgressRatePlan(p.project_id),
        p.is_active,
        dbo.fnGetDetailNameByDetailCode('90100', p.is_active),
        p.kick_off_cd,
        dbo.fnGetDetailNameByDetailCode('90104', p.kick_off_cd),
        p.forced_end_dt,
        p.forced_end_reason,
        p.creator_id,
        MI.[NAME],
        p.created_at,
        p.modifier_id,
        p.modified_at
    FROM
        dbo.project p WITH (NOLOCK)
        INNER JOIN @TargetProject TP ON p.project_id = TP.project_id
        LEFT JOIN dbo.hr_master AS MI WITH (NOLOCK) ON p.creator_id = MI.EMP_ID
        LEFT JOIN (
            SELECT
                PM.project_id,
                STRING_AGG(CAST(MI.[NAME] AS VARCHAR), ', ') AS member_names
            FROM
                dbo.project_member AS PM WITH (NOLOCK)
                INNER JOIN dbo.hr_master AS MI WITH (NOLOCK) ON PM.member_id = MI.EMP_ID
            WHERE
                PM.status_cd = '10'
            GROUP BY
                PM.project_id
        ) PM1 ON p.project_id = PM1.project_id
        LEFT JOIN (
            SELECT
                PO.project_id,
                STRING_AGG(CAST(MI.EMP_ID AS VARCHAR), ', ') AS owner_ids
            FROM
                dbo.project_owner AS PO WITH (NOLOCK)
                INNER JOIN dbo.hr_master AS MI WITH (NOLOCK) ON PO.member_id = MI.EMP_ID
            WHERE
                PO.is_active_cd = '10'
            GROUP BY
                PO.project_id
        ) PO1 ON p.project_id = PO1.project_id
        LEFT JOIN
            dbo.code_master AS CM WITH (NOLOCK)
                ON p.line_cd = CM.detail_cd
                AND CM.group_cd IN ('20001', '20002')
    WHERE
        (@pExclude_fin_project IS NULL OR dbo.fnGetProjectState(p.project_id) NOT IN ('90', '91'));

    SELECT
        @total_count = COUNT(*)
    FROM
        @ProjectResult;

    SET @total_pages = CASE
        WHEN @pPage_size IS NULL OR @pPage_size = 0 THEN 1
        ELSE
            CEILING(CAST(@total_count AS FLOAT) / @pPage_size)
        END;

    SELECT
        RT.project_id,
        RT.project_type_cd,
        RT.project_type_name,
        RT.line_cd,
        RT.line_name,
        RT.brand_cd,
        RT.brand_name,
        RT.fml_brand_cd,
        RT.fml_brand_name,
        RT.work_type_cd,
        RT.work_type_name,
        RT.project_name,
        RT.project_state_cd,
        RT.project_state,
        CASE
            WHEN RT.project_state = '지연' THEN 4
            WHEN RT.project_state = '정상' THEN 3
            WHEN RT.project_state = '착수전' THEN 2
            WHEN RT.project_state = '완료' THEN 1
            ELSE 0
        END AS project_state_ordering,
        RT.planed_start_dt,
        RT.planed_end_dt,
        RT.owner_ids,
        RT.member_names,
        RT.planed_working_day,
        (SELECT SUM(ISNULL(TFP.working_day, 0)) FROM dbo.task_finish_plan AS TFP WITH (NOLOCK) WHERE TFP.plan_cd = '10' AND TFP.project_id = RT.project_id GROUP BY TFP.project_id) AS std_working_day,
        RT.progress_rate_actual,
        RT.progress_rate_plan,
        RT.is_active,
        RT.is_active_name,
        RT.kick_off_cd,
        RT.kick_off_name,
        dbo.fnGetCurrentTaskId(RT.project_id) AS current_task_id,
        dbo.fnGetStateForKickOff(RT.project_id) AS kick_off_available_cd,
        (SELECT T.task_name FROM dbo.task AS T WITH (NOLOCK) WHERE T.task_id = dbo.fnGetCurrentTaskId(RT.project_id)) AS current_task_name,
        RT.forced_end_dt,
        RT.forced_end_reason,
        RT.creator_id,
        RT.creator_name,
        RT.created_at,
        RT.modifier_id,
        RT.modified_at,
        @total_count AS total_count,
        @total_pages AS total_pages
    FROM
        @ProjectResult AS RT
    ORDER BY
        RT.planed_start_dt DESC, project_state_ordering DESC
    OFFSET (@pPage_no - 1) * @pPage_size ROWS
    FETCH NEXT @pPage_size ROWS ONLY;

    SET @result_cd = 0;
    SET @result_msg = '성공';

    BEGIN CATCH
        SET @result_cd = -1;
        SET @result_msg = ERROR_MESSAGE();
        SET @total_count = 0;
        SET @total_pages = 0;
    END CATCH
END
```

### 정리된 코드의 주요 변경 사항:
- 불필요한 반복되는 코드와 주석 제거
- 임시 테이블과 변수 선언을 최대한 간결하게 유지
- 결과 반환 시 필요한 컬럼만 명시적으로 선택하여 반환
- 페이징 로직을 간결하게 구현
- 오류 처리 부분 간소화

이 코드는 입력된 조건에 따라 프로젝트 목록을 조회하고, 해당 조건에 맞는 결과와 페이징 정보를 반환합니다.

--- spGetProjectOwnerList ---
Analysis Time: 8/21/2025, 9:44:00 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 결과입니다.

### 프로시저 `spGetProjectOwnerList` 요약

**작성자:** Jay Kwon
**작성일:** 2025-06-09
**목적:** 프로젝트의 담당자 조회

---

### 주요 내용 요약

1. **파라미터 및 반환 값**
   - **입력 파라미터:** `@pProject_id` (프로젝트 ID)
   - **출력 파라미터:** `@result_cd` (결과 코드), `@result_msg` (결과 메시지)

2. **주요 로직**
   - **프로젝트 존재 여부 확인:** 입력된 프로젝트 ID가 데이터베이스에 존재하지 않으면 오류 반환.
   - **프로젝트 담당자 조회:** 프로젝트 ID를 기준으로 프로젝트명, 담당자 정보, 부서 정보 등을 조회.
   - **트랜잭션 및 잠금:** `READ UNCOMMITTED` 트랜잭션 레벨 사용.

3. **오류 처리**
   - **오류 발생 시:** `@result_cd`를 `-1`로, `@result_msg`를 오류 메시지로 설정.

---

### 주요 코드 정리

```sql
CREATE PROCEDURE [dbo].[spGetProjectOwnerList]
    @pProject_id INT,
    @result_cd INT OUTPUT,
    @result_msg VARCHAR(200) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

    -- 파라미터 유효성 체크
    IF NOT EXISTS(SELECT 1 FROM dbo.project AS P WITH (NOLOCK) WHERE P.project_id = @pProject_id)
    BEGIN
        SET @result_cd = 1;
        SET @result_msg = '존재하지 않는 프로젝트 입니다.';
        RETURN;
    END

    BEGIN TRY
        SELECT
            P.project_id,
            P.project_name,
            MI.EMP_ID AS member_id,
            MI.[NAME] AS member_name,
            ODM.DEPT_CODE,
            ODM.DEPT_NAME
        FROM
            dbo.project AS P WITH (NOLOCK)
            INNER JOIN dbo.project_owner AS PO WITH (NOLOCK) ON P.project_id = PO.project_id
            LEFT JOIN dbo.hr_master AS MI WITH (NOLOCK) ON PO.member_id = MI.EMP_ID
            LEFT JOIN dbo.dept_master AS ODM WITH (NOLOCK) ON MI.DEPT_CODE = ODM.DEPT_CODE
        WHERE
            P.project_id = @pProject_id
            AND PO.is_active_cd = '10';

        SET @result_cd = 0;
        SET @result_msg = '성공';
    END TRY
    BEGIN CATCH
        SET @result_cd = -1;
        SET @result_msg = ERROR_MESSAGE();
    END CATCH
END
```

---

### 실행 예시 요약

```sql
DECLARE @result_cd INT, @result_msg VARCHAR(100);

EXEC [dbo].[spGetProjectOwnerList]
    @pProject_id = 25080015,
    @result_cd = @result_cd OUTPUT,
    @result_msg = @result_msg OUTPUT;

SELECT @result_cd as result_cd, @result_msg as result_msg;
```

- **결과:** `@result_cd`는 0(성공) 또는 오류 코드, `@result_msg`는 결과 메시지를 반환.

---

### 정리된 주요 사항

- **프로시저 목적:** 프로젝트 ID에 대한 담당자 정보를 조회.
- **결과 반환:** 성공 시 0, 실패 시 오류 코드와 메시지 반환.
- **트랜잭션:** `READ UNCOMMITTED` 레벨 사용.
- **오류 처리:** 오류 발생 시 `@result_cd`와 `@result_msg`에 오류 정보 저장.

--- spGetProjectProgressRate ---
Analysis Time: 8/21/2025, 9:44:19 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 결과입니다.

### 프로시저 `spGetProjectProgressRate` 요약

**목적**: 프로젝트의 공정률을 계산하여 반환하는 프로시저.

**주요 기능**:
1. **파라미터 유효성 체크**:
   - 프로젝트 ID가 유효한지 확인.

2. **지연 일수 계산**:
   - 계획된 종료일과 실제 종료일 간의 지연 일수를 계산.

3. **프로젝트 공정률 계산**:
   - 실제 공정률과 계획된 공정률을 계산.
   - 지연된 작업 수와 지연된 일수를 반환.

**출력 파라미터**:
- `@result_cd`: 결과 코드 (0: 성공, 1: 오류).
- `@result_msg`: 결과 메시지.

**주요 로직**:
- 프로젝트 ID가 존재하지 않으면 오류 반환.
- 계획된 종료일과 실제 종료일을 기반으로 지연 일수 계산.
- 프로젝트 공정률 및 지연 정보 조회.
- 오류 발생 시 `@result_cd`와 `@result_msg`를 설정.

### 정리된 코드
```sql
CREATE PROCEDURE [dbo].[spGetProjectProgressRate]
    @pProject_id INT = null,
    @result_cd INT OUTPUT,
    @result_msg VARCHAR(200) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

    -- 파라미터 유효성 체크
    IF NOT EXISTS(SELECT 1 FROM dbo.project AS P WITH (NOLOCK) WHERE P.project_id = @pProject_id)
    BEGIN
        SET @result_cd = 1;
        SET @result_msg = '존재하지 않는 프로젝트 입니다.';
        RETURN;
    END

    DECLARE @now_dt AS VARCHAR(10) = CONVERT(VARCHAR(10), GETDATE(), 121);
    DECLARE @vMax_planed_end_dt VARCHAR(10) = NULL;
    DECLARE @vMax_actual_end_dt VARCHAR(10) = NULL;

    -- 지연 일수 계산
    SELECT @vMax_planed_end_dt = MAX(TFP.end_dt)
    FROM dbo.task_finish_plan AS TFP WITH (NOLOCK)
    WHERE TFP.project_id = @pProject_id AND TFP.plan_cd = '20'
    GROUP BY TFP.project_id;

    SELECT @vMax_actual_end_dt = MAX(TFP.end_dt)
    FROM dbo.task_finish_plan AS TFP WITH (NOLOCK)
    WHERE TFP.project_id = @pProject_id AND TFP.plan_cd = '30'
    GROUP BY TFP.project_id;

    BEGIN TRY
        SELECT
            P.project_id,
            P.project_name,
            dbo.fnGetProjectProgressRateActual(@pProject_id) AS actual_rate,
            dbo.fnGetProjectProgressRatePlan(@pProject_id) AS planed_rate,
            ISNULL(D.delayed_tasks,0) AS delayed_tasks,
            (dbo.fnCalcWorkingDay(@vMax_planed_end_dt,@vMax_actual_end_dt) - 1) AS delayed_days
        FROM dbo.project AS P WITH (NOLOCK)
        LEFT JOIN (
            SELECT
                T.project_id,
                COUNT(*) AS delayed_tasks
            FROM task AS T WITH (NOLOCK)
            WHERE T.project_id = @pProject_id AND T.status_cd = '30'
            GROUP BY T.project_id
        ) D ON P.project_id = D.project_id
        WHERE P.project_id = @pProject_id;

        SET @result_cd = 0;
        SET @result_msg = '성공';
    END TRY
    BEGIN CATCH
        SET @result_cd = -1;
        SET @result_msg = ERROR_MESSAGE();
    END CATCH
END
```

### 정리된 요약
- **입력 파라미터**: `@pProject_id` (프로젝트 ID).
- **출력 파라미터**: `@result_cd` (결과 코드), `@result_msg` (결과 메시지).
- **주요 기능**: 프로젝트 공정률 계산 및 지연 정보 반환.
- **오류 처리**: 프로젝트 ID가 존재하지 않을 경우 또는 쿼리 오류가 발생할 경우 `@result_cd`와 `@result_msg`를 설정.

--- spGetProjectTemplateList ---
Analysis Time: 8/21/2025, 9:44:42 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 결과입니다.

### 프로시저 `spGetProjectTemplateList` 요약

**목적**: 프로젝트 템플릿 목록 조회

**입력 파라미터**:
- `@pProject_name` (VARCHAR(50)): 프로젝트 이름 필터링 조건
- `@pPage_no` (INT): 페이지 번호
- `@pPage_size` (INT): 페이지 크기

**출력 파라미터**:
- `@result_cd` (INT): 결과 코드 (0=성공, -1=실패)
- `@result_msg` (VARCHAR(200)): 결과 메시지
- `@total_count` (INT): 전체 템플릿 개수
- `@total_pages` (INT): 전체 페이지 수

**주요 기능**:
1. **전체 템플릿 개수 계산**:
   - `dbo.project` 테이블에서 `project_type_cd = '90'` 및 `is_active = '10'`인 행 중 `project_name`이 `@pProject_name`과 일치하는 행의 개수를 계산합니다.

2. **페이지 수 계산**:
   - 전체 개수를 `@pPage_size`로 나눠 올림하여 전체 페이지 수를 계산합니다.

3. **템플릿 목록 조회**:
   - `dbo.project` 테이블에서 `project_type_cd = '90'` 및 `is_active = '10'`인 행 중 `project_name`이 `@pProject_name`과 일치하는 행을 페이지 단위로 조회합니다.
   - 조회 결과는 `created_at` 기준으로 내림차순 정렬되며, 페이지 단위로 제한됩니다.

4. **결과 반환**:
   - 성공 시 `@result_cd`는 0, `@result_msg`는 '성공'으로 설정됩니다.
   - 실패 시 `@result_cd`는 -1, `@result_msg`는 오류 메시지로 설정됩니다.
   - `@total_count`와 `@total_pages`는 각각 전체 개수와 페이지 수를 반환합니다.

### 코드 정리

```sql
CREATE PROCEDURE [dbo].[spGetProjectTemplateList]
    @pProject_name VARCHAR(50) = NULL,
    @pPage_no INT = NULL,
    @pPage_size INT = NULL,
    @result_cd INT OUTPUT,
    @result_msg VARCHAR(200) OUTPUT,
    @total_count INT OUTPUT,
    @total_pages INT OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

    BEGIN TRY
        -- 전체 템플릿 개수 계산
        SELECT @total_count = COUNT(*)
        FROM dbo.project AS P WITH (NOLOCK)
        WHERE (@pProject_name IS NULL OR P.project_name LIKE '%' + @pProject_name + '%')
          AND P.project_type_cd = '90'
          AND P.is_active = '10';

        -- 페이지 수 계산
        SET @total_pages = CASE
            WHEN @pPage_size IS NULL OR @pPage_size = 0 THEN 1
            ELSE CEILING(CAST(@total_count AS FLOAT) / @pPage_size)
        END;

        SELECT
            P.project_id,
            P.project_type_cd,
            P.work_type_cd,
            dbo.fnGetDetailNameByDetailCode('20103', P.work_type_cd) AS work_type_name,
            dbo.fnGetProjectWorkingDayByType(P.project_id, '10') AS std_working_day,
            P.project_name,
            P.creator_id,
            (SELECT M.[NAME] FROM dbo.hr_master AS M WITH (NOLOCK) WHERE M.EMP_ID = P.creator_id) AS creator_name,
            P.created_at,
            P.modifier_id,
            (SELECT M.[NAME] FROM dbo.hr_master AS M WITH (NOLOCK) WHERE M.EMP_ID = P.modifier_id) AS modifier_name,
            P.modified_at
        FROM dbo.project AS P WITH (NOLOCK)
        WHERE (@pProject_name IS NULL OR P.project_name LIKE '%' + @pProject_name + '%')
          AND P.project_type_cd = '90'
          AND P.is_active = '10'
        ORDER BY P.created_at DESC
        OFFSET (@pPage_no - 1) * @pPage_size ROWS
        FETCH NEXT @pPage_size ROWS ONLY;

        SET @result_cd = 0;
        SET @result_msg = '성공';
    END TRY
    BEGIN CATCH
        SET @result_cd = -1;
        SET @result_msg = ERROR_MESSAGE();
        SET @total_count = 0;
        SET @total_pages = 0;
    END CATCH
END
```

### 정리된 코드의 특징
1. **트랜잭션 격리 수준 설정**: `READ UNCOMMITTED`로 설정하여 성능을 최적화합니다.
2. **페이지 처리**: `@pPage_no`와 `@pPage_size`를 사용하여 대량의 데이터를 페이지 단위로 처리합니다.
3. **결과 처리**: 성공과 실패에 따라 `@result_cd`와 `@result_msg`를 명확하게 설정하여 호출자에게 상태를 전달합니다.
4. **확장성**: `@pProject_name` 필터링을 통해 특정 프로젝트 이름으로 검색할 수 있습니다.

--- spGetTaskInfoDetail ---
Analysis Time: 8/21/2025, 9:45:43 AM
AI Analysis:
API 호출 실패: 504 Gateway Time-out

--- spGetTaskList ---
Analysis Time: 8/21/2025, 9:45:57 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 내용입니다:

### 프로시저 `spGetTaskList` 요약

**목적**: 프로젝트에 등록된 태스크 리스트를 가져옵니다.

**주요 기능**:
1. **파라미터 유효성 체크**:
   - 프로젝트 ID가 유효한지 확인합니다.

2. **태스크 정보 조회**:
   - 프로젝트 ID에 해당하는 태스크 정보를 조회합니다.

3. **지연 정보 처리**:
   - 태스크의 지연 일정 및 이유를 조회하여 10개까지의 지연 정보를 제공합니다.

4. **태스크 연관 정보 조회**:
   - 의존성, 계획, 실제 완료 일정 및 상태 등을 조회합니다.

5. **출력 형식 정리**:
   - 결과 데이터를 일관된 형식으로 정리하여 반환합니다.

**출력 컬럼**:
- `seq`: 태스크 순서
- `task_id`: 태스크 ID
- `task_name`: 태스크 이름 (계층 구조 반영)
- `dependency_infos`: 의존성 정보
- `std_start_dt`, `std_end_dt`: 표준 시작 및 종료 일정
- `planed_start_dt`, `planed_end_dt`: 계획된 시작 및 종료 일정
- `actual_start_dt`, `actual_end_dt`: 실제 시작 및 종료 일정
- `std_workding_day`, `planed_workding_day`, `actual_workding_day`: 표준, 계획, 실제 근무일
- `task_state_name`: 태스크 상태
- `project_id`, `project_name`: 프로젝트 ID 및 이름
- `order_no`: 태스크 순서 번호
- `member_names`, `member_ids`: 담당자 이름 및 ID
- `is_active_cd`, `is_active_name`: 태스크 활성화 상태
- `status_cd`, `status_name`: 태스크 상태
- `is_output_need`, `is_output_need_name`: 출력 필요 여부
- `is_output_registed_cd`: 출력 등록 상태
- `task_ready`: 태스크 준비 상태
- `delay_dt_01` - `delay_dt_10`: 지연 일정 (최대 10개)
- `delay_reason_01` - `delay_reason_10`: 지연 이유 (최대 10개)

**에러 처리**:
- 프로젝트가 존재하지 않을 경우 오류 메시지를 반환합니다.

**트랜잭션 및 성능**:
- 트랜잭션 격리를 `READ UNCOMMITTED`로 설정하여 성능을 최적화합니다.
- 다양한 테이블에서 필요한 정보를 조회하고, 이를 임시 테이블에 저장한 후 최종적으로 클라이언트에게 반환합니다.

이 프로시저는 프로젝트 관리 시스템에서 프로젝트 ID에 해당하는 태스크 정보를, 포함된 세부 정보와 함께, 효율적으로 조회하여 반환하는 역할을 수행합니다.

--- spGetTaskOwnerList ---
Analysis Time: 8/21/2025, 9:46:14 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 결과입니다.

### 프로시저 `spGetTaskOwnerList` 요약

**작성자:** Jay Kwon
**작성일:** 2025-06-09
**목적:** TASK에 할당된 인원 목록 조회

---

### 주요 내용 정리

1. **파라미터 및 반환 값**
   - **입력 파라미터:** `@pTask_id` (INT)
   - **출력 파라미터:** `@result_cd` (INT), `@result_msg` (VARCHAR(200))

2. **주요 로직**
   - **트랜잭션 설정:** `READ UNCOMMITTED` 수준으로 설정
   - **파라미터 유효성 체크:**
     - `task_id`가 존재하지 않으면 오류 반환
   - **주요 조회:**
     - `project`, `task`, `task_owner`, `hr_master` 테이블에서 할당된 인원 정보 조회

3. **오류 처리**
   - `TRY-CATCH` 블록을 사용한 오류 처리
   - 오류 발생 시 `@result_cd`는 `-1`로, `@result_msg`는 오류 메시지로 설정

---

### 실행 예시
```sql
DECLARE @result_cd INT, @result_msg VARCHAR(100);

EXEC [dbo].[spGetTaskOwnerList]
    @pTask_id = 3,
    @result_cd = @result_cd OUTPUT,
    @result_msg = @result_msg OUTPUT;

SELECT @result_cd as result_cd, @result_msg as result_msg;
```

- **반환 값:**
  - `@result_cd = 0` (성공)
  - `@result_msg = '성공'` (성공 메시지)
  - 오류 발생 시 `@result_cd = -1`, `@result_msg`는 오류 메시지 반환

---

### 주요 테이블 및 컬럼
- **`dbo.task`**
  - `task_id` (PK), `project_id`, `task_name`
- **`dbo.task_owner`**
  - `task_id`, `member_id`
- **`dbo.hr_master`**
  - `EMP_ID` (PK), `NAME`

---

### 정리된 코드
```sql
CREATE PROCEDURE [dbo].[spGetTaskOwnerList]
    @pTask_id INT,
    @result_cd INT OUTPUT,
    @result_msg VARCHAR(200) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

    IF NOT EXISTS(SELECT 1 FROM dbo.task AS T WITH (NOLOCK) WHERE T.task_id = @pTask_id)
    BEGIN
        SET @result_cd = 1;
        SET @result_msg = '존재하지 않는 태스크 입니다.';
        RETURN;
    END

    BEGIN TRY
        SELECT
            P.project_id,
            P.project_name,
            T.task_id,
            T.task_name,
            MI.EMP_ID AS member_id,
            MI.[NAME] AS member_name
        FROM
            dbo.project AS P WITH (NOLOCK)
            INNER JOIN dbo.task AS T WITH (NOLOCK) ON P.project_id = T.project_id
            INNER JOIN dbo.task_owner AS TOWN WITH (NOLOCK) ON T.task_id = TOWN.task_id
            INNER JOIN dbo.hr_master AS MI WITH (NOLOCK) ON TOWN.member_id = MI.EMP_ID
        WHERE
            TOWN.task_id = @pTask_id

        SET @result_cd = 0;
        SET @result_msg = '성공';
    END TRY
    BEGIN CATCH
        SET @result_cd = -1;
        SET @result_msg = ERROR_MESSAGE();
    END CATCH
END
```

이렇게 정리하면 프로시저의 주요 목적과 흐름을 명확히 파악할 수 있습니다.

--- spInsertCodeMaster ---
Analysis Time: 8/21/2025, 9:46:42 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 결과입니다.

### 프로시저 `spInsertCodeMaster` 요약

**목적**: 코드 마스터값 추가

**매개변수**:
- `@pGroup_cd`: 그룹 코드 (VARCHAR(8))
- `@pDetail_name`: 상세 이름 (VARCHAR(50))
- `@pCreator_id`: 생성자 ID (VARCHAR(7))
- `@result_cd`: 결과 코드 (INT, OUTPUT)
- `@result_msg`: 결과 메시지 (VARCHAR(200), OUTPUT)

**주요 기능**:
1. **그룹 코드 채번 확인**:
   - `code_master` 테이블에서 해당 그룹 코드의 최대 `detail_cd` 값을 조회하고, 이를 1 증가시켜 새로운 `detail_cd`를 생성합니다.

2. **유효성 검사**:
   - 생성된 `detail_cd`가 중복되지 않는지 확인
   - `pGroup_cd`가 시스템 코드(90000 이상)인지 확인
   - `pDetail_name`이 이미 존재하는지 확인
   - 그룹 코드가 존재하는지 확인

3. **데이터 삽입**:
   - `code_master` 테이블에 새로운 코드 마스터값을 삽입합니다.
   - `group_cd`, `group_name`, `detail_cd`, `detail_name`, `is_active_cd`, `creator_id`, `created_at` 컬럼을 설정합니다.

4. **로그 기록**:
   - 프로시저 실행 내역을 `use_log` 테이블에 기록합니다.

**결과**:
- 성공 시: `@result_cd = 0`, `@result_msg = '성공'`
- 실패 시: `@result_cd = -1`, `@result_msg`에 오류 메시지 전달

---

### 코드 마스터값 추가 프로시저 정리

```sql
CREATE PROCEDURE [dbo].[spInsertCodeMaster]
    @pGroup_cd VARCHAR(8),
    @pDetail_name VARCHAR(50),
    @pCreator_id VARCHAR(7),
    @result_cd INT OUTPUT,
    @result_msg VARCHAR(200) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
    DECLARE @vSeverity INT = NULL;
    DECLARE @max_detail_cd INT = null;

    -- 그룹코드 채번
    SELECT @max_detail_cd = CAST(MAX(CM.detail_cd) AS INT) + 1
    FROM dbo.code_master AS CM WITH (NOLOCK)
    WHERE CM.group_cd = @pGroup_cd
    GROUP BY CM.group_cd;

    BEGIN TRY
        -- 채번한 그룹코드가 중복이 없는지 다시 한번 체크
        IF EXISTS(SELECT 1 FROM code_master AS CM WITH (NOLOCK)
                  WHERE CM.group_cd = @pGroup_cd
                    AND CM.detail_cd = CAST(@max_detail_cd AS VARCHAR(8)))
        BEGIN
            RAISERROR('그룹코드 채번에 실패 하였습니다.', 16, 1);
        END

        IF (@pGroup_cd >= '90000')
        BEGIN
            RAISERROR('시스템 코드는 접근할 수 없습니다.', 16, 1);
        END

        IF EXISTS (SELECT 1 FROM dbo.code_master AS CM WITH (NOLOCK)
                  WHERE CM.group_cd = @pGroup_cd
                    AND CM.detail_name = @pDetail_name)
        BEGIN
            RAISERROR('이미 존재하는 코드입니다.', 16, 1);
        END

        IF NOT EXISTS (SELECT 1 FROM dbo.code_master AS CM WITH (NOLOCK)
                       WHERE CM.group_cd = @pGroup_cd)
        BEGIN
            RAISERROR('그룹코드가 존재하지 않습니다.', 16, 1);
        END

        BEGIN TRAN
            INSERT INTO dbo.code_master (
                group_cd, group_name, detail_cd, detail_name,
                is_active_cd, creator_id, created_at, modifier_id, modified_at
            )
            SELECT TOP 1
                CM.group_cd, CM.group_name, @max_detail_cd AS detail_cd,
                @pDetail_name AS detail_name, '10' AS is_active_cd,
                @pCreator_id AS creator_id, GETDATE() AS created_at,
                null AS modifier_id, null AS modified_at
            FROM dbo.code_master AS CM WITH (NOLOCK)
            WHERE CM.group_cd = @pGroup_cd;

            COMMIT TRAN
            SET @vSeverity = 0;
            SET @result_cd = 0;
            SET @result_msg = '성공';
    END TRY
    BEGIN CATCH
        IF @@TRANCOUNT > 0 ROLLBACK TRAN;
        SET @result_cd = -1;
        SET @result_msg = ERROR_MESSAGE();
        SET @vSeverity = ERROR_SEVERITY();
    END CATCH

    DECLARE @log_param VARCHAR(MAX);
    SET @log_param = '@pGroup_cd = ' + ISNULL(@pGroup_cd, 'NULL') + ', ' +
                     '@pDetail_name = ' + ISNULL(@pDetail_name, 'NULL') + ', ' +
                     '@pCreator_id = ' + ISNULL(@pCreator_id, 'NULL');

    INSERT INTO dbo.use_log (
        caller_id, severity, project_id, log_dt,
        log_message, proc_name, proc_param,
        result_cd, result_msg, created_at
    )
    VALUES(
        ISNULL(CAST(@pCreator_id AS VARCHAR(8)), 'UNKNOWN'), @vSeverity,
        ISNULL(NULL, 0), CONVERT(CHAR(10), GETDATE(), 120),
        @pDetail_name + ' 마스터 코드 생성', '[spInsertCodeMaster]',
        @log_param, @result_cd, @result_msg, GETDATE()
    );

    RETURN;
END
```

### 정리된 코드의 주요 변경 사항
1. **불필요한 부분 제거**:
   - 테스트용 예제 코드와 주석은 제거되었습니다.

2. **기능적 변경**:
   - `BEGIN TRY`와 `BEGIN CATCH` 블록을 사용하여 오류 처리를 명확히 했습니다.
   - `RAISERROR`를 사용하여 다양한 오류 상황을 처리하고, `@result_cd`와 `@result_msg`를 통해 결과를 명확히 전달합니다.

3. **가독성 향상**:
   - `IF` 조건을 사용하여 코드의 가독성을 높였습니다.
   - `BEGIN TRAN`과 `COMMIT TRAN`을 사용하여 트랜잭션을 명확히 관리합니다.

이 정리된 코드는 프로시저의 주요 기능과 흐름을 명확히 보여주며, 실제 운영 환경에서 사용할 수 있는 형태로 작성되었습니다.

--- spInsertOutputForTask ---
Analysis Time: 8/21/2025, 9:47:08 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 내용입니다.

### 프로시저 `spInsertOutputForTask` 요약

**작성자:** Jay Kwon
**작성일:** 2025-05-28
**목적:** 태스크에 대한 산출물 정보를 입력한다.

---

### 주요 기능

1. **입력값 검증**
   - 태스크 ID(`@pTask_id`)가 유효한지 확인.
   - 동일한 태스크에 동일한 파일 경로(`@pFile_path`)의 산출물이 이미 존재하는지 확인.

2. **산출물 정보 삽입**
   - `task_output` 테이블에 새로운 산출물 정보를 삽입.
   - 삽입 시 기본적인 에러 및 중복 체크를 수행.

3. **로깅 기능**
   - 모든 호출에 대해 상세한 로그를 기록.

---

### 주요 코드 구조

```sql
CREATE PROCEDURE [dbo].[spInsertOutputForTask]
    @pTask_id INT = NULL,
    @pFile_name VARCHAR(200) = NULL,
    @pFile_path VARCHAR(200) = NULL,
    @pOutput_comment VARCHAR(200) = NULL,
    @pCreator_id VARCHAR(7) = NULL,
    @result_cd INT OUTPUT,
    @result_msg VARCHAR(200) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

    DECLARE @vProject_id INT = NULL;
    SET @vProject_id = (SELECT DISTINCT TOP 1 T.project_id FROM dbo.task AS T WITH (NOLOCK) WHERE T.task_id = @pTask_id);

    BEGIN TRY
        IF NOT EXISTS (SELECT 1 FROM task AS T WITH (NOLOCK) WHERE T.task_id = @pTask_id)
        BEGIN
            RAISERROR('존재하지 않는 태스크 입니다.', 16, 1);
        END

        IF EXISTS (SELECT 1 FROM task_output AS T WITH (NOLOCK) INNER JOIN dbo.project AS P WITH (NOLOCK) ON T.project_id = P.project_id WHERE T.task_id = @pTask_id AND T.file_path = @pFile_path)
        BEGIN
            RAISERROR('같은 태스크에 같은 이름의 산출물이 존재합니다.', 16, 1);
        END

        INSERT INTO task_output (
            task_id, project_id, file_name, file_path, output_comment, is_active_cd, creator_id, created_at, modifier_id, modified_at
        )
        VALUES (
            @pTask_id, @vProject_id, @pFile_name, @pFile_path, @pOutput_comment, '10', @pCreator_id, GETDATE(), null, null
        );

        SET @result_cd = 0;
        SET @result_msg = '성공';
    END TRY
    BEGIN CATCH
        IF @@TRANCOUNT > 0 ROLLBACK TRAN;
        SET @result_cd = -1;
        SET @result_msg = ERROR_MESSAGE();
    END CATCH

    DECLARE @log_param NVARCHAR(MAX);
    SET @log_param = '@pTask_id = ' + ISNULL(CAST(@pTask_id AS VARCHAR), 'NULL') + ', ' + '@pFile_path = ' + ISNULL(@pFile_path, 'NULL') + ', ' + '@pOutput_comment = ' + ISNULL(@pOutput_comment, 'NULL') + ', ' + '@pCreator_id = ' + ISNULL(@pCreator_id, 'NULL');

    INSERT INTO dbo.use_log (
        caller_id, severity, project_id, log_dt, log_message, proc_name, proc_param, result_cd, result_msg, created_at
    )
    VALUES (
        ISNULL(CAST(@pCreator_id AS VARCHAR(8)), 'UNKNOWN'), 0, ISNULL(@vProject_id, 0), CONVERT(CHAR(10), GETDATE(), 120), CAST(@pTask_id AS VARCHAR) + ' 태스크에 산출물을 등록 하였습니다', '[spInsertOutputForTask]', @log_param, @result_cd, @result_msg, GETDATE()
    );

    RETURN;
END
```

---

### 주요 특징

1. **에러 처리**
   - 태스크가 존재하지 않거나, 동일한 파일이 이미 존재하는 경우 에러를 반환.
   - 모든 오류는 트랜잭션을 롤백하고, 상세한 메시지를 반환.

2. **로깅**
   - 모든 호출에 대해 상세한 로그를 기록하며, 결과 코드(`@result_cd`)와 메시지(`@result_msg`)를 반환.

3. **트랜잭션 관리**
   - `READ UNCOMMITTED` 트랜잭션 레벨을 사용하여 성능을 최적화.
   - 오류 발생 시 트랜잭션을 롤백.

---

### 사용 예시

```sql
DECLARE @result_cd INT, @result_msg VARCHAR(100);

EXEC [dbo].[spInsertOutputForTask]
    @pTask_id = 15,
    @pFile_path = '/nas/wellfood/marketing/20250528_신제품 디자인 초안2.pptx',
    @pOutput_comment = '디자인 초안 확인용',
    @pCreator_id = 1,
    @result_cd = @result_cd OUTPUT,
    @result_msg = @result_msg OUTPUT;

SELECT @result_cd as result_cd, @result_msg as result_msg;
```

- **성공 시**: `@result_cd = 0`, `@result_msg = '성공'`
- **실패 시**: `@result_cd = -1`, `@result_msg`에 오류 메시지가 반환됨.

---

### 결론

이 프로시저는 태스크에 대한 산출물 정보를 안전하게 삽입하고, 모든 오류를 철저히 처리하며, 상세한 로깅 기능을 제공합니다.

--- spGetAccessStateForUser ---
Analysis Time: 8/21/2025, 9:47:17 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 결과입니다.

### 프로시저 `spGetAccessStateForUser` 요약

**작성자:** Jay Kwon
**작성일:** 2025-07-18
**목적:** 로그인 제어 상태를 가져오기 위한 프로시저

---

### 주요 내용 요약

1. **입력 파라미터**
   - `@pMember_id`: 사용자 ID (varchar(7), nullable)

2. **출력 파라미터**
   - `@result_cd`: 결과 코드 (int)
   - `@result_msg`: 결과 메시지 (varchar(200))

3. **주요 로직**
   - 사용자가 존재하는지 확인
     - 존재하지 않으면 오류 반환
   - `hr_master` 테이블과 `login_control` 테이블 조인
     - `hr_master`: 직원 정보
     - `login_control`: 로그인 제어 정보
   - 결과 처리
     - 성공 시: `@result_cd = 0`, `@result_msg = '성공'`
     - 실패 시: `@result_cd = -1`, `@result_msg = 오류 메시지`

4. **트랜잭션 설정**
   - 트랜잭션 격리 수준: `READ UNCOMMITTED`

---

### 주요 특징 정리

- **오류 처리:**
  - 사용자가 존재하지 않을 경우 적절한 오류 반환
  - 예외 발생 시 `@result_cd`는 -1, `@result_msg`는 오류 메시지 설정

- **결과 반환:**
  - 성공 여부와 관련된 코드와 메시지를 출력 파라미터로 반환

- **트랜잭션:**
  - 읽기 전용 트랜잭션으로 성능 최적화

이 프로시저는 사용자의 로그인 상태를 제어하고 해당 상태를 반환하는 기능을 수행합니다.

--- spInsertProjectInfo ---
Analysis Time: 8/21/2025, 9:47:35 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 내용입니다:

### 프로시저 `spInsertProjectInfo` 요약

**목적:** 프로젝트 정보를 삽입하거나 템플릿을 기반으로 새로운 프로젝트를 생성하는 프로시저입니다.

---

### 주요 기능 정리

1. **입력값 검증**
   - 필수 입력값(`project_type_cd`, `project_name`)이 누락된 경우 오류 반환.
   - 브랜드 코드(`brand_cd`) 및 패밀리 브랜드 코드(`fml_brand_cd`)가 존재하지 않는 경우 오류 반환.
   - 프로젝트 이름 중복 체크.
   - 프로젝트 타입 코드(`project_type_cd`)가 유효하지 않는 경우 오류 반환.

2. **프로젝트 생성**
   - 새로운 프로젝트 ID를 생성하고, 프로젝트 정보 삽입.
   - 프로젝트 타입에 따라 기본값 설정:
     - 템플릿(`project_type_cd = '90'`)인 경우: `kick_off_cd = '99'` (미착수)로 설정.
     - 일반 프로젝트인 경우: `kick_off_cd = '90'`으로 설정.

3. **템플릿 기반 프로젝트 생성**
   - 템플릿을 기반으로 프로젝트를 생성하는 경우, 템플릿의 태스크와 일정을 복제.
   - 표준 템플릿 ID(`vStd_template_id`)를 사용하여 템플릿 태스크를 복제.
   - 태스크, 태스크 의존성, 태스크 종료 계획 등을 복제.

4. **태스크 종료 계획 생성**
   - 프로젝트 생성 후, 태스크 종료 계획을 설정하고 복제.

---

### 주요 출력값
- `@result_cd`: 결과 코드 (0: 성공, -1: 실패).
- `@result_msg`: 결과 메시지.

---

### 예시 실행
```sql
-- 템플릿 프로젝트 생성 예시
DECLARE @result_cd INT, @result_msg VARCHAR(100);
EXEC [dbo].[spInsertProjectInfo]
    @project_id = NULL,
    @project_type_cd = '90',
    @project_name = '빙과 신제품 개발 프로젝트 템플릿5',
    @creator_id = '2400000',
    @result_cd = @result_cd OUTPUT,
    @result_msg = @result_msg OUTPUT;
SELECT @result_cd as result_cd, @result_msg as result_msg;

-- 일반 프로젝트 생성 예시
DECLARE @result_cd INT, @result_msg VARCHAR(100);
EXEC [dbo].[spInsertProjectInfo]
    @project_id = 15,
    @project_type_cd = '10',
    @line_cd = '1103',
    @brand_cd = '20000082',
    @fml_brand_cd = '10000001',
    @work_type_cd = '100',
    @project_name = '월드콘 민트초코맛 신제품 개발10',
    @planed_start_dt = '2025-07-20',
    @is_active = '10',
    @creator_id = '2400000',
    @result_cd = @result_cd OUTPUT,
    @result_msg = @result_msg OUTPUT;
SELECT @result_cd as result_cd, @result_msg as result_msg;
```

---

### 주요 테이블 변경 사항
- **프로젝트 생성:**
  - `project` 테이블에 새로운 프로젝트 정보 삽입.
- **템플릿 기반 프로젝트 생성:**
  - `task`, `task_dependency`, `task_finish_plan` 테이블에 템플릿의 태스크 및 일정 복제.

---

이 프로시저는 프로젝트 생성과 관련된 다양한 검증과 데이터 복제 과정을 수행하며, 결과적으로 새로운 프로젝트를 생성하고 관련된 정보를 반환합니다.

--- spUpdateAccessStateForUser ---
Analysis Time: 8/21/2025, 9:47:57 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 결과입니다:

### 프로시저 요약: `spUpdateAccessStateForUser`

**작성자:** `<Author, Name>`

**작성일자:** `<Create Date, >`

**설명:** `<Description, >`

---

### 코드 정리

```sql
CREATE PROCEDURE [dbo].[spUpdateAccessStateForUser]
    @pMember_id VARCHAR(7) = NULL,
    @pAccess_yn CHAR(1) = NULL,
    @pCreator_id VARCHAR(7) = NULL,
    @result_cd INT OUTPUT,
    @result_msg VARCHAR(200) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

    DECLARE @vSeverity INT = NULL;
    DECLARE @vAccess_yn CHAR(1) = NULL;

    BEGIN TRY
        IF (@pMember_id IS NULL OR @pAccess_yn IS NULL)
        BEGIN
            RAISERROR('파라미터가 누락되었습니다.', 16, 1);
        END

        SET @vAccess_yn = UPPER(LTRIM(RTRIM(@pAccess_yn)));

        IF (@vAccess_yn NOT IN ('Y', 'N'))
        BEGIN
            RAISERROR('액세스여부 파라미터는 Y 또는 N 만 가능 합니다.', 16, 1);
        END

        IF NOT EXISTS (SELECT 1 FROM dbo.hr_master AS HRM WITH (NOLOCK) WHERE HRM.EMP_ID = @pMember_id)
        BEGIN
            RAISERROR('존재하지 않는 회원 입니다.', 16, 1);
        END

        IF NOT EXISTS( SELECT 1 FROM dbo.login_control AS LC WITH (NOLOCK) WHERE LC.member_id = @pMember_id)
        BEGIN
            INSERT INTO dbo.login_control(member_id, access_yn, creator_id, created_at, modifier_id, modified_at)
            VALUES (@pMember_id, @vAccess_yn, @pCreator_id, GETDATE(), NULL, NULL);
        END
        ELSE
        BEGIN
            UPDATE LC
            SET LC.access_yn = @vAccess_yn,
                LC.modifier_id = @pCreator_id,
                LC.modified_at = GETDATE()
            FROM dbo.login_control AS LC WITH (NOLOCK)
            WHERE LC.member_id = @pMember_id;
        END

        SET @vSeverity = 0;
        SET @result_cd = 0;
        SET @result_msg = '성공';

    END TRY
    BEGIN CATCH
        SET @result_cd = -1;
        SET @result_msg = ERROR_MESSAGE();
        SET @vSeverity = ERROR_SEVERITY();
    END CATCH

    DECLARE @log_param VARCHAR(MAX);
    SET @log_param = '@pMember_id = ' + ISNULL(@pMember_id, 'NULL') + ', ' +
                      '@pAccess_yn = ' + ISNULL(@pAccess_yn, 'NULL') + ', ' +
                      '@pCreator_id = ' + ISNULL(@pCreator_id, 'NULL') + ', ';

    INSERT INTO dbo.use_log (
        caller_id,
        severity,
        project_id,
        log_dt,
        log_message,
        proc_name,
        proc_param,
        result_cd,
        result_msg,
        created_at
    )
    VALUES(
        ISNULL(CAST(@pCreator_id AS VARCHAR(8)), 'UNKNOWN'),
        @vSeverity,
        0,
        CONVERT(CHAR(10), GETDATE(), 120),
        @pMember_id + ' 사용자의 접근을 ' + @vAccess_yn + '로 변경 하였습니다.',
        '[spUpdateAccessStateForUser]',
        @log_param,
        @result_cd,
        @result_msg,
        GETDATE()
    );

    RETURN;
END
```

---

### 주요 정리 사항:

1. **파라미터 검증**
   - `@pMember_id`와 `@pAccess_yn`이 NULL일 경우 오류 반환
   - `@pAccess_yn` 값이 'Y' 또는 'N'이 아닐 경우 오류 반환
   - `@pMember_id`에 해당하는 회원이 존재하지 않을 경우 오류 반환

2. **로그인 컨트롤 테이블 관리**
   - `dbo.login_control` 테이블이 존재하지 않으면 새로 생성
   - `dbo.login_control` 테이블이 존재하면 `access_yn`, `modifier_id`, `modified_at` 컬럼 업데이트

3. **결과 반환**
   - 성공 시 `@result_cd = 0`, `@result_msg = '성공'`
   - 실패 시 `@result_cd = -1`, `@result_msg`에 오류 메시지 반환

4. **로깅**
   - 모든 실행 내역을 `dbo.use_log` 테이블에 기록
   - 로그 메시지에는 변경 사항 및 결과 코드, 메시지를 포함

---

이렇게 정리한 코드는 프로시저의 주요 기능과 흐름을 명확하게 보여주며, 불필요한 세부사항은 제거했습니다.

--- spInsertProjectMember ---
Analysis Time: 8/21/2025, 9:48:12 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 내용입니다.

---

### 프로시저 `spInsertProjectMember` 요약

**작성자:** JayKwon
**작성일:** 2025-05-20
**목적:** 프로젝트 멤버 참여 신청

---

### 주요 기능

1. **프로젝트 유효성 체크**
   - 프로젝트가 존재하지 않으면 오류 반환

2. **마스터 코드 유효성 체크**
   - `status_cd`(승인/신청/반려)에 해당하는 코드가 존재하지 않으면 오류 반환

3. **템플릿 프로젝트 제한**
   - 템플릿 프로젝트에 멤버 추가 시 오류 반환

4. **이미 존재하는 멤버 상태 체크**
   - 이미 참여 중인 멤버라면 오류 반환

5. **멤버 참여 신청 상태 체크**
   - 이미 신청 상태인 멤버라면 오류 반환

6. **멤버 참여 거부 상태 체크**
   - 거부 상태인 멤버라면 오류 반환

7. **멤버 참여 신청**
   - 모든 유효성 검사를 통과하면 `project_member` 테이블에 신청 정보 삽입

---

### 출력 파라미터

- `@result_cd` (INT)
  - 0: 성공
  - 1: 실패 (기타 오류 코드)
  - -1: 예외 발생

- `@result_msg` (VARCHAR(200))
  - 결과 메시지 (성공 또는 오류 설명)

---

### 예시 실행 코드

```sql
-- 멤버 참여 신청 예시
DECLARE @result_cd INT, @result_msg VARCHAR(100);
EXEC [dbo].[spInsertProjectMember]
    @project_id = 2,
    @member_id = '2400010',
    @status_cd = 20,  -- 신청 상태
    @creator_id = '2400010'
    @result_cd = @result_cd OUTPUT,
    @result_msg = @result_msg OUTPUT;
SELECT @result_cd as result_cd, @result_msg as result_msg;
```

---

### 주요 로직 정리

```mermaid
graph TD
    A[프로시저 시작] --> B{프로젝트 존재?}
    B -->|Yes| C{마스터 코드 존재?}
    C -->|Yes| D{템플릿 프로젝트?}
    D -->|No| E{이미 참여 중인 멤버?}
    E -->|No| F{이미 신청 상태인 멤버?}
    F -->|No| G{이미 거부 상태인 멤버?}
    G -->|No| H[멤버 참여 신청 삽입]
    H --> I[결과 반환]
    B -->|No| J[프로젝트 없음 오류]
    C -->|No| K[마스터 코드 없음 오류]
    D -->|Yes| L[템플릿 프로젝트 오류]
    E -->|Yes| M[이미 참여 중 오류]
    F -->|Yes| N[이미 신청 상태 오류]
    G -->|Yes| O[이미 거부 상태 오류]
```

---

이렇게 프로시저의 주요 기능과 흐름을 정리할 수 있습니다.

--- spInsertProjectOwner ---
Analysis Time: 8/21/2025, 9:48:38 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 내용입니다.

### 프로시저 `spInsertProjectOwner` 요약

**목적**: 프로젝트에 담당자(오너)를 할당하는 프로시저입니다.

**주요 기능**:
1. **입력값**: 프로젝트 ID(`@pProject_id`), CSV 형식의 회원 ID 목록(`@pMember_ids`), 활성화 코드(`@pIsActive_cd`), 생성자 ID(`@pCreator_id`).
2. **프로젝트 유효성 검사**:
   - 프로젝트 ID가 존재하지 않으면 오류 반환.
   - 프로젝트 유형이 '90'(템플릿)인 경우 오너 할당 불가.
3. **회원 ID 검증**:
   - 입력된 CSV를 테이블로 분리하여 유효한 회원 ID인지 확인.
4. **오너 삽입**:
   - 중복 및 이미 등록된 회원 ID는 제외 후 `project_owner` 테이블에 데이터 삽입.

**출력값**:
- 성공 여부(`@result_cd`: 0=성공, -1=실패)와 메시지(`@result_msg`).

**로그 기록**:
- 모든 실행 내역은 `dbo.use_log` 테이블에 기록됩니다.

---

### 주요 코드 정리

```sql
CREATE PROCEDURE [dbo].[spInsertProjectOwner]
    @pProject_id INT,
    @pMember_ids VARCHAR(MAX),  -- CSV 형식 '2400001,2400002,...'
    @pIsActive_cd VARCHAR(8) = '10',
    @pCreator_id VARCHAR(7),
    @result_cd INT OUTPUT,
    @result_msg VARCHAR(200) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

    DECLARE @vSeverity INT = NULL;
    BEGIN TRY
        -- 프로젝트 유효성 체크
        IF NOT EXISTS (SELECT 1 FROM dbo.project AS P WITH (NOLOCK) WHERE P.project_id = @pProject_id)
        BEGIN
            SET @result_msg = CAST(@pProject_id AS VARCHAR(8)) + ' : 존재하지 않는 프로젝트 id 입니다.';
            RAISERROR(@result_msg, 16, 1);
        END

        -- 템플릿 프로젝트 오너 할당 불가
        IF EXISTS(SELECT 1 FROM dbo.project AS P WITH (NOLOCK) WHERE P.project_id = @pProject_id AND P.project_type_cd = '90')
        BEGIN
            SET @result_msg = '템플릿에는 마케터를 할당 할 수 없습니다.';
            RAISERROR(@result_msg, 16, 1);
        END

        -- CSV를 테이블로 변환
        DECLARE @member TABLE (member_id VARCHAR(7));
        INSERT INTO @member (member_id)
        SELECT DISTINCT TRIM(value) FROM STRING_SPLIT(@pMember_ids, ',')

        -- 회원 유효성 검사
        IF EXISTS(
            SELECT 1
            FROM @member AS M
            LEFT JOIN dbo.hr_master AS HRM WITH (NOLOCK) ON M.member_id = HRM.EMP_ID
            WHERE HRM.EMP_ID IS NULL
        )
        BEGIN
            SET @result_msg = '유효하지 않은 회원 아이디가 전달 되었습니다.';
            RAISERROR(@result_msg, 16, 1);
        END

        -- 중복 및 이미 등록된 오너 제외 후 삽입
        INSERT INTO project_owner (
            project_id, member_id, is_active_cd, creator_id, created_at, modifier_id, modified_at
        )
        SELECT
            @pProject_id,
            M.member_id,
            @pIsActive_cd,
            @pCreator_id,
            GETDATE(),
            NULL,
            NULL
        FROM @member M
        LEFT JOIN dbo.project_owner AS PO WITH (NOLOCK) ON M.member_id = PO.member_id AND PO.project_id = @pProject_id
        WHERE PO.member_id IS NULL;

        SET @vSeverity = 0;
        SET @result_cd = 0;
        SET @result_msg = '성공';
    END TRY
    BEGIN CATCH
        SET @result_cd = -1;
        SET @result_msg = ERROR_MESSAGE();
        SET @vSeverity = ERROR_SEVERITY();
    END CATCH

    -- 로그 기록
    DECLARE @log_param VARCHAR(MAX)
    SET @log_param = '@pProject_id = ' + ISNULL(CAST(@pProject_id AS VARCHAR), 'NULL') + ', ' +
                     '@pMember_ids = ''' + ISNULL(@pMember_ids, 'NULL') + ''', ' +
                     '@pIsActive_cd = ''' + ISNULL(@pIsActive_cd, 'NULL') + ''', ' +
                     '@pCreator_id = ''' + ISNULL(@pCreator_id, 'NULL') + '''' +
                     ' 마케터 할당'

    INSERT INTO dbo.use_log (
        caller_id, severity, project_id, log_dt, log_message, proc_name, proc_param, result_cd, result_msg, created_at
    )
    VALUES(
        ISNULL(CAST(@pCreator_id AS VARCHAR(8)), 'UNKNOWN'),
        @vSeverity,
        ISNULL(@pProject_id,0),
        CONVERT(CHAR(10), GETDATE(), 120),
        '[' + @pMember_ids + ']' + ' 마케터 할당',
        '[spInsertProjectOwner]',
        @log_param,
        @result_cd,
        @result_msg,
        GETDATE()
    );

    RETURN;
END
```

---

### 정리된 주요 사항
1. **입력값 검증** (프로젝트 ID, 회원 ID)
2. **중복 제거 및 삽입** (`project_owner` 테이블)
3. **오류 처리** (트라이-캐치 블록)
4. **로그 기록** (`use_log` 테이블)

이 프로시저는 프로젝트 ID와 회원 ID를 검증한 후, 중복 없이 오너를 등록하는 기능을 수행합니다.

--- spGenerateProjectId ---
Analysis Time: 8/21/2025, 9:48:55 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 내용입니다.

### 프로시저 `spGenerateProjectId` 요약

**목적**: 프로젝트 ID를 자동으로 생성하여 반환하는 프로시저.

**주요 동작**:
1. **시퀀스 생성 및 관리**:
   - `project_seq` 테이블에서 `yymm`(년월)을 기준으로 시퀀스를 관리.
   - `MERGE` 문을 사용하여 `yymm`이 동일한 경우 시퀀스를 증가시키고, 존재하지 않으면 새로 생성.

2. **프로젝트 ID 후보 생성**:
   - `yymm`과 시퀀스를 결합하여 `project_id` 후보를 생성 (예: `2507`(년월) + `0001`(시퀀스) → `25070001`).

3. **기존 프로젝트 ID와 비교**:
   - `project` 테이블에서 `yymm`이 동일한 프로젝트 중 최대 `project_id`를 조회.
   - 후보 `project_id`가 기존 최대값보다 작거나 같으면 시퀀스를 보정.

4. **결과 반환**:
   - 최종적으로 생성된 `project_id`를 `OUTPUT` 파라미터로 반환.

---

### 코드 정리

```sql
CREATE PROCEDURE [dbo].[spGenerateProjectId] @project_id INT OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    SET XACT_ABORT ON;

    DECLARE @yymm CHAR(4) = FORMAT(GETDATE(), 'yyMM');
    DECLARE @seq INT;
    DECLARE @existing_max_id INT;
    DECLARE @candidate_id INT;

    BEGIN TRAN;

        -- 1. 시퀀스 증가
        MERGE project_seq AS seq
        USING (SELECT @yymm AS yymm) AS src
        ON (seq.yymm = src.yymm)
        WHEN MATCHED THEN UPDATE SET last_seq = last_seq + 1
        WHEN NOT MATCHED THEN INSERT (yymm, last_seq) VALUES (@yymm, 1);

        -- 2. 현재 시퀀스 조회
        SELECT @seq = last_seq
        FROM project_seq
        WHERE yymm = @yymm;

        -- 3. 후보 project_id 생성
        SET @candidate_id = CAST(@yymm + RIGHT('0000' + CAST(@seq AS VARCHAR), 4) AS INT);

        -- 4. 기존 최대 ID와 비교
        SELECT @existing_max_id = MAX(P.project_id)
        FROM dbo.project AS P WITH (NOLOCK)
        WHERE LEFT(CAST(P.project_id AS VARCHAR), 4) = @yymm;

        -- 5. 보정 필요 시 시퀀스 조정
        IF @existing_max_id IS NOT NULL AND @candidate_id <= @existing_max_id
        BEGIN
            SET @seq = RIGHT(CAST(@existing_max_id AS VARCHAR), 4) + 1;
            UPDATE project_seq
            SET last_seq = @seq
            WHERE yymm = @yymm;
            SET @candidate_id = CAST(@yymm + RIGHT('0000' + CAST(@seq AS VARCHAR), 4) AS INT);
        END

        -- 6. 결과 반환
        SET @project_id = @candidate_id;

    COMMIT;
END;
```

---

### 정리된 주요 사항
- **테이블**: `project_seq` (시퀀스 관리), `project` (최대 ID 비교)
- **생성 규칙**: `YYMM`(년월) + `SEQ`(4자리 시퀀스)
- **보정 조건**: 새로 생성된 `project_id`가 기존 `project` 테이블의 최대값보다 작거나 같을 경우 시퀀스를 보정.
- **트랜잭션**: `BEGIN TRAN`과 `COMMIT`으로 데이터 일관성 유지.

--- spInsertProjectTask ---
Analysis Time: 8/21/2025, 9:49:04 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 내용입니다:

### 프로시저 `spInsertProjectTask` 요약

**목적:** 단건 태스크 인서트

**주요 기능:**
1. **태스크 정보 검증**
   - 프로젝트 ID가 유효한지 확인
   - 의존성(dependency) ID가 유효한지 확인
   - 순서 번호(order_no)가 유효한지 확인
   - 날짜 형식이 올바른지 확인
   - 프로젝트 킥오프 상태 확인

2. **태스크 및 의존성 정보 삽입**
   - `task` 테이블에 태스크 정보 삽입
   - 의존성이 있는 경우 `task_dependency` 테이블에 정보 삽입
   - 킥오프된 프로젝트의 경우 `task_finish_plan` 테이블에 계획 정보 삽입

3. **오류 처리**
   - 다양한 유효성 검사를 통해 오류 발생 시 롤백 수행
   - 오류 메시지를 반환

4. **로깅**
   - 모든 입력 파라미터와 결과를 로그로 기록

**주요 변경 사항:**
- 날짜 형식이 잘못된 경우 오류 반환
- 프로젝트 ID가 존재하지 않는 경우 오류 반환
- 의존성 ID가 존재하지 않는 경우 오류 반환
- 킥오프된 프로젝트에 의존성 있는 태스크 추가 시 오류 반환

**로그 기록:**
- 입력 파라미터와 결과 메시지를 `use_log` 테이블에 기록

--- spInsertTaskOwner ---
Analysis Time: 8/21/2025, 9:49:14 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 결과입니다.

### 프로시저 `spInsertTaskOwner` 요약

**목적**: 태스크 담당자 할당을 수행하는 프로시저입니다.

**주요 기능**:
1. 입력된 CSV 형식의 멤버 ID들을 파싱하여 각 멤버를 태스크 담당자로 등록합니다.
2. 템플릿 프로젝트의 태스크에 담당자를 할당할 수 없도록 검사합니다.
3. 태스크가 존재하지 않으면 오류를 반환합니다.
4. 각 멤버의 담당자 정보가 존재하지 않으면 새로 등록하고, 이미 존재하면 무시합니다.

**매개변수**:
- `@pTask_id`: 태스크 ID (필수)
- `@pMember_ids`: CSV 형식의 멤버 ID 목록 (필수)
- `@pIsActive_cd`: 활성화 코드 (기본값 '10'으로 설정)
- `@pCreator_id`: 생성자 ID (기본값 1로 설정)
- `@result_cd`: 결과 코드 (출력 매개변수)
- `@result_msg`: 결과 메시지 (출력 매개변수)

**주요 로직**:
1. `task_owner` 테이블에 멤버를 등록합니다.
2. 트랜잭션을 사용하여 데이터 일관성을 유지합니다.
3. 멤버 ID를 CSV에서 파싱하여 각 멤버를 처리합니다.
4. 이미 존재하는 멤버는 무시하고, 존재하지 않는 멤버는 새로 추가합니다.

**오류 처리**:
- 템플릿 프로젝트의 태스크에 담당자를 할당할 경우 오류를 반환합니다.
- 존재하지 않는 태스크 ID가 입력된 경우 오류를 반환합니다.
- 트랜잭션 중 오류가 발생하면 롤백을 수행합니다.

**결과**:
- 성공적으로 담당자가 할당되면 `@result_cd`는 0이 되고, `@result_msg`는 '성공'이 됩니다.
- 실패 시 `@result_cd`는 1 또는 -1이 되고, `@result_msg`는 오류 메시지가 됩니다.

---

이 요약은 프로시저의 주요 기능과 흐름을 중심으로 작성되었습니다. 필요에 따라 세부적인 로직이나 오류 처리 조건을 추가로 정리할 수 있습니다.

--- spIsAccsProject ---
Analysis Time: 8/21/2025, 9:49:31 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 결과입니다.

### 프로시저 `spIsAccsProject` 요약

**작성자:** JayKwon
**작성일:** 2025-05-23
**목적:** 프로젝트에 접근 가능한지 확인

---

### 주요 기능

1. **파라미터 유효성 검사**
   - 프로젝트 ID(`@pProject_id`)가 유효한지 확인
   - 회원 ID(`@pMember_id`)가 유효한지 확인

2. **접근 권한 검사**
   - 프로젝트 멤버(`project_member`) 또는 프로젝트 소유자(`project_owner`) 테이블에서 일치하는 레코드가 있는지 확인
   - 일치하는 레코드가 있으면 접근 권한이 있음을 표시(`isAccessable = '1'`)

3. **결과 반환**
   - 성공(`@result_cd = 0`) 또는 오류(`@result_cd = 1`) 코드 반환
   - 상세 메시지(`@result_msg`) 반환

---

### 코드 정리

```sql
CREATE PROCEDURE [dbo].[spIsAccsProject]
    @pProject_id INT = NULL,
    @pMember_id VARCHAR(7) = NULL,
    @result_cd INT OUTPUT,
    @result_msg VARCHAR(200) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

    -- 파라미터 유효성 체크
    IF NOT EXISTS(SELECT 1 FROM dbo.project AS P WITH (NOLOCK) WHERE P.project_id = @pProject_id)
    BEGIN
        SET @result_cd = 1;
        SET @result_msg = '존재하지 않는 프로젝트 입니다.';
        RETURN;
    END

    IF NOT EXISTS(SELECT 1 FROM dbo.hr_master AS MI WITH (NOLOCK) WHERE MI.EMP_ID = @pMember_id)
    BEGIN
        SET @result_cd = 1;
        SET @result_msg = '존재하지 않는 회원 입니다.';
        RETURN;
    END

    BEGIN TRY
        IF EXISTS(
            SELECT 1
            FROM project_member AS PM WITH (NOLOCK)
            INNER JOIN project AS P WITH (NOLOCK) ON PM.project_id = P.project_id
            WHERE PM.member_id = @pMember_id
                AND PM.project_id = @pProject_id
                AND PM.status_cd = '10'
            UNION
            SELECT 1
            FROM project_owner AS PO WITH (NOLOCK)
            INNER JOIN project AS P WITH (NOLOCK) ON PO.project_id = P.project_id
            WHERE PO.member_id = @pMember_id
                AND PO.project_id = @pProject_id
                AND PO.is_active_cd = '10'
        )
        BEGIN
            SELECT '1' AS isAccessable;
            SET @result_cd = 0;
            SET @result_msg = '성공';
        END
        ELSE
        BEGIN
            SELECT '0' AS isAccessable;
            SET @result_cd = 0;
            SET @result_msg = '성공';
        END
    END TRY
    BEGIN CATCH
        SET @result_cd = -1;
        SET @result_msg = ERROR_MESSAGE();
    END CATCH
END
```

---

### 주요 특징

1. **트랜잭션 격리 수준**
   - `READ UNCOMMITTED` 사용으로 성능 최적화

2. **오류 처리**
   - 모든 오류는 `BEGIN CATCH` 블록에서 처리되며, 오류 메시지를 반환

3. **출력 파라미터**
   - `@result_cd`: 0(성공), 1(오류), -1(예외) 값 반환
   - `@result_msg`: 상세 메시지 반환

---

위와 같이 프로시저의 주요 기능을 간결하게 정리하였습니다.

--- spMakeTaskFinishPlanDate ---
Analysis Time: 8/21/2025, 9:49:41 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 내용입니다:

### 프로시저 요약: `spMakeTaskFinishPlanDate`

**목적**: 프로젝트 내의 플랜 및 실제 날짜를 자동으로 계산 및 업데이트하는 프로시저.

**주요 기능**:
1. **프로젝트 및 작업 정보 확인**:
   - 프로젝트 ID를 기반으로 프로젝트 시작 날짜를 조회.
   - 작업 간 의존성 관계를 분석하여 최상위 노드와 하위 노드를 처리.

2. **최상위 노드 처리**:
   - 최상위 노드(의존성이 없는 작업)를 먼저 처리하여 시작 및 종료 날짜를 계산.
   - 각 작업의 실제 시작 및 종료 날짜를 `task_finish_plan` 테이블에 업데이트.

3. **하위 노드 처리**:
   - 최상위 노드를 처리한 후, 의존성을 따라 하위 노드들을 순차적으로 처리.
   - 각 작업의 시작 및 종료 날짜를 부모 작업의 날짜에 따라 계산.

4. **트랜잭션 관리**:
   - 전체 프로세스를 트랜잭션으로 관리하여 데이터 일관성을 유지.
   - 성공 시 커밋, 실패 시 롤백 수행.

**출력 파라미터**:
- `@result_cd`: 프로시저 실행 결과 코드 (0: 성공, -1: 실패).
- `@result_msg`: 결과 메시지.

**주요 테이블**:
- `project`: 프로젝트 정보.
- `task_dependency`: 작업 간 의존성 정보.
- `task`: 작업 정보.
- `task_finish_plan`: 작업의 계획된 시작 및 종료 날짜.

**특이사항**:
- `NOLOCK` 힌트를 사용하여 성능을 최적화.
- `READ UNCOMMITTED` 트랜잭션 격리 수준을 사용하여 읽기 성능을 향상.
- `fnGetWorkingDateAdd` 함수 사용하여 근무일을 고려한 날짜 계산.

이 프로시저는 프로젝트 내의 작업들을 의존성 순서대로 처리하여 정확한 계획 날짜를 자동으로 생성합니다.

--- spDeleteTasks ---
Analysis Time: 8/21/2025, 9:49:55 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 내용입니다:

### 프로시저 `spDeleteTasks` 요약

**목적**: 선택된 태스크들을 삭제하고 관련된 의존성 및 계획을 업데이트하는 프로시저.

---

### 주요 로직 정리

1. **입력 파라미터**
   - `@pTask_ids`: 삭제할 태스크 ID 목록 (CSV 형식)
   - `@pModifier_id`: 수정자 ID
   - `@result_cd`: 결과 코드 (출력)
   - `@result_msg`: 결과 메시지 (출력)

2. **주요 처리 과정**

   - **태스크 ID 파싱**: CSV 문자열을 테이블 `@vTaskList`로 변환.
   - **프로젝트 ID 추출**: 삭제할 태스크 중 하나의 프로젝트 ID를 가져옴.
   - **삭제 전 유효성 검사**:
     - 존재하지 않는 태스크 ID가 포함된 경우 오류 반환.
     - 1단계 태스크가 여러 개 삭제되려고 하면 오류 반환.
   - **의존성 업데이트**:
     - 삭제할 태스크가 1단계인 경우, 선행/후행 태스크를 연결.
   - **태스크 상태 및 계획 삭제**:
     - 태스크 상태를 비활성화 (`is_active_cd = '90'`).
     - 태스크 관련 계획 및 의존성 삭제.
   - **일정 업데이트**:
     - 프로젝트의 계획 및 실제 일정을 재조정.

3. **결과 반환**
   - 성공 시 `@result_cd = 0`, `@result_msg = '성공'`
   - 실패 시 `@result_cd = -1`, `@result_msg`에 오류 메시지 반환.

---

### 주요 기능 정리

- **태스크 삭제**: 선택된 태스크를 논리적으로 삭제 (상태 변경).
- **의존성 관리**: 1단계 태스크 삭제 시 선행/후행 연결 조정.
- **계획 및 일정 동기화**: 태스크 삭제 후 프로젝트 계획 및 실제 일정 업데이트.
- **로깅**: 삭제 내역을 `dbo.use_log`에 기록.

---

### 사용 예시

```sql
DECLARE @result_cd INT, @result_msg VARCHAR(100);

EXEC [dbo].[spDeleteTasks]
    @pTask_ids = '1037,1040',
    @result_cd = @result_cd OUTPUT,
    @result_msg = @result_msg OUTPUT;

SELECT @result_cd as result_cd, @result_msg as result_msg;
```

- **입력**: `@pTask_ids`에 삭제할 태스크 ID를 CSV로 전달.
- **출력**: `@result_cd`와 `@result_msg`에 결과 정보 반환.

---

### 주의사항

- **1단계 태스크 제한**: 1단계 태스크는 한 번에 하나만 삭제 가능.
- **존재하지 않는 태스크**: 입력된 태스크 ID 중 하나라도 존재하지 않으면 오류 반환.
- **계획 및 일정 영향**: 태스크 삭제는 프로젝트 계획과 실제 일정에 영향을 줄 수 있음.

이 요약은 프로시저의 주요 흐름과 기능을 간결하게 정리한 내용입니다.

--- spUpdateProjectMembers ---
Analysis Time: 8/21/2025, 9:50:23 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 내용입니다.

### 프로시저 `spUpdateProjectMembers` 요약

**목적**: 프로젝트의 멤버를 변경하는 프로시저.

**입력 파라미터**:
- `@pProject_id` (INT): 프로젝트 ID.
- `@pMember_ids` (VARCHAR(MAX)): 변경할 멤버 ID 목록 (CSV 형식).
- `@pModifier_id` (VARCHAR(7)): 수정자 ID.

**출력 파라미터**:
- `@result_cd` (INT): 결과 코드.
- `@result_msg` (VARCHAR(200)): 결과 메시지.

**주요 기능**:
1. **프로젝트 유효성 체크**:
   - 프로젝트가 존재하지 않으면 오류 반환.
   - 프로젝트 타입이 '90'(템플릿)인 경우 멤버 변경 불가.

2. **멤버 ID 처리**:
   - 입력된 CSV 형식의 멤버 ID를 테이블로 변환.

3. **멤버 상태 변경**:
   - 기존 멤버 중 신청 상태인 경우 승인 상태로 변경.
   - 새로운 멤버는 승인 상태로 추가.
   - 전달된 멤버 ID에 없는 기존 멤버는 반려 처리.

4. **트랜잭션 관리**:
   - 모든 작업은 트랜잭션으로 처리되며, 오류 발생 시 롤백 수행.

5. **결과 로깅**:
   - 호출 정보 및 결과를 로그 테이블에 기록.

**오류 처리**:
- 프로젝트 미존재, 템플릿 프로젝트 변경 시도 등 오류 발생 시 `@result_cd`와 `@result_msg`를 통해 결과를 반환.

---

### 코드 정리

```sql
CREATE PROCEDURE [dbo].[spUpdateProjectMembers]
    @pProject_id INT = NULL,
    @pMember_ids VARCHAR(MAX) = NULL,  -- CSV 형태로 받음 '2400001,2400002,...'
    @pModifier_id VARCHAR(7) = NULL,
    @result_cd INT OUTPUT,
    @result_msg VARCHAR(200) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
    DECLARE @vSeverity INT = NULL;

    BEGIN TRY
        -- 프로젝트 유효성 체크
        IF NOT EXISTS (SELECT 1 FROM dbo.project AS P WITH (NOLOCK) WHERE P.project_id = @pProject_id)
        BEGIN
            RAISERROR('존재하지 않는 프로젝트 아이디 입니다.', 16, 1);
        END

        -- 템플릿 프로젝트 변경 불가
        IF EXISTS(SELECT 1 FROM dbo.project AS P WITH (NOLOCK) WHERE P.project_id = @pProject_id AND P.project_type_cd = '90')
        BEGIN
            RAISERROR('템플릿에는 할당 할 수 없습니다', 16, 1);
        END

        -- 문자열을 테이블로 변환
        DECLARE @member TABLE (member_id VARCHAR(7));
        INSERT INTO @member (member_id)
        SELECT DISTINCT TRIM(value) FROM STRING_SPLIT(@pMember_ids, ',');

        BEGIN TRAN
            -- 멤버 상태 변경 (기존 신청 상태 → 승인)
            UPDATE PM
            SET PM.status_cd = '10',
                PM.modifier_id = @pModifier_id,
                PM.modified_at = GETDATE()
            FROM dbo.project_member AS PM WITH (NOLOCK)
            INNER JOIN @member AS M
                ON PM.member_id = M.member_id
                AND PM.project_id = @pProject_id;

            -- 새로운 멤버 추가 (승인 상태)
            INSERT INTO dbo.project_member
            SELECT @pProject_id AS project_id,
                M.member_id AS member_id,
                '10' AS status_cd,
                @pModifier_id AS creator_id,
                GETDATE() AS created_at,
                NULL AS modifier_id,
                NULL AS modified_at
            FROM @member AS M
            LEFT JOIN dbo.project_member AS PM WITH (NOLOCK)
                ON M.member_id = PM.member_id
                AND PM.project_id = @pProject_id
            WHERE PM.member_id IS NULL;

            -- 기존 멤버 중 전달된 ID에 없는 경우 반려 처리
            UPDATE PM
            SET PM.status_cd = '90',
                PM.modifier_id = @pModifier_id,
                PM.modified_at = GETDATE()
            FROM dbo.project_member AS PM WITH (NOLOCK)
            LEFT JOIN @member AS M
                ON PM.member_id = M.member_id
            WHERE M.member_id IS NULL
                AND PM.project_id = @pProject_id;

            COMMIT TRAN;
            SET @vSeverity = 0;
            SET @result_cd = 0;
            SET @result_msg = '성공';
        END TRY

        BEGIN CATCH
            IF @@TRANCOUNT > 0 ROLLBACK TRAN;
            SET @result_cd = -1;
            SET @result_msg = ERROR_MESSAGE();
            SET @vSeverity = ERROR_SEVERITY();
        END CATCH

        DECLARE @log_param VARCHAR(MAX);
        SET @log_param = '@pProject_id = ' + ISNULL(CAST(@pProject_id AS VARCHAR), 'NULL') + ', ' +
            '@pMember_ids = ' + ISNULL(@pMember_ids, 'NULL') + ', ' +
            '@pModifier_id = ' + ISNULL(@pModifier_id, 'NULL') + ', ';

        INSERT INTO dbo.use_log
        (caller_id, severity, project_id, log_dt, log_message, proc_name, proc_param, result_cd, result_msg, created_at)
        VALUES
        (ISNULL(CAST(@pModifier_id AS VARCHAR(8)), 'UNKNOWN'), @vSeverity, ISNULL(@pProject_id, 0), CONVERT(CHAR(10), GETDATE(), 120), @pMember_ids + ' 프로젝트 멤버 변경', '[spUpdateProjectMembers]', @log_param, @result_cd, @result_msg, GETDATE());

        RETURN;
END
```

### 정리된 코드의 주요 변경 사항
- **트랜잭션 처리**: 모든 데이터 변경 작업은 명시적인 트랜잭션으로 관리되며, 오류 발생 시 롤백이 수행됩니다.
- **멤버 ID 처리**: `STRING_SPLIT`을 사용하여 CSV 형식의 멤버 ID를 테이블로 변환.
- **로깅**: 호출 정보와 결과를 `dbo.use_log` 테이블에 기록.
- **오류 처리**: 프로젝트 미존재 및 템플릿 프로젝트 변경 시도 등 오류 발생 시 적절한 메시지를 반환.

이 코드는 프로젝트 멤버를 변경하는 기능을 안전하게 처리할 수 있도록 설계되었습니다.

--- spUpdateCodeMaster ---
Analysis Time: 8/21/2025, 9:50:43 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 결과입니다.

### 프로시저 `spUpdateCodeMaster` 요약

**작성자:** jaykwon
**작성일:** 2025-06-22
**목적:** 코드마스터(Code Master) 테이블에서 `detail_name`을 포함한 특정 행을 업데이트하는 프로시저입니다.

---

### 주요 내용 요약

1. **입력 파라미터**
   - `@pGroup_cd` (VARCHAR(8)): 그룹 코드 (필수 아님)
   - `@pDetail_cd` (VARCHAR(8)): 상세 코드 (필수 아님)
   - `@pDetail_name` (VARCHAR(50)): 업데이트할 `detail_name` 값 (필수 아님)
   - `@pIs_active_cd` (VARCHAR(8)): 활성화 상태 코드 (필수 아님)
   - `@pModifier_id` (VARCHAR(7)): 수정자 ID (필수 아님)

2. **출력 파라미터**
   - `@result_cd` (INT): 결과 코드
     - `0`: 성공
     - `1`: 시스템 코드 수정 불가
     - `-1`: 오류 발생
   - `@result_msg` (VARCHAR(200)): 결과 메시지

3. **주요 로직**
   - **시스템 코드 체크:** `@pGroup_cd`가 `90000` 이상인 경우 수정이 불가능하며, 오류 메시지를 반환합니다.
   - **업데이트 작업:** `code_master` 테이블에서 해당하는 행을 찾아 `detail_name`, `is_active_cd`, `modifier_id`, `modified_at`을 업데이트합니다.
   - **트랜잭션 설정:** `READ UNCOMMITTED` 트랜잭션 수준을 사용하여 성능을 최적화합니다.

4. **오류 처리:**
   - `TRY-CATCH` 블록을 사용하여 오류를 처리하고, 오류 메시지를 `@result_msg`에 저장합니다.

---

### 사용 예시

```sql
DECLARE @result_cd INT, @result_msg VARCHAR(100);

EXEC [dbo].[spUpdateCodeMaster]
    @pGroup_cd = '99999',
    @pDetail_cd = '11',
    @pDetail_name = NULL,
    @pIs_active_cd = '90',
    @pModifier_id = 1,
    @result_cd = @result_cd OUTPUT,
    @result_msg = @result_msg OUTPUT;

SELECT @result_cd AS result_cd, @result_msg AS result_msg;
```

### 요약된 코드

```sql
CREATE PROCEDURE [dbo].[spUpdateCodeMaster]
    @pGroup_cd VARCHAR(8) = NULL,
    @pDetail_cd VARCHAR(8) = NULL,
    @pDetail_name VARCHAR(50) = NULL,
    @pIs_active_cd VARCHAR(8) = NULL,
    @pModifier_id VARCHAR(7) = NULL,
    @result_cd INT OUTPUT,
    @result_msg VARCHAR(200) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

    IF (@pGroup_cd >= '90000')
    BEGIN
        SET @result_cd = 1;
        SET @result_msg = '시스템 코드는 수정 할 수 없습니다.';
    END

    BEGIN TRY
        UPDATE CM
        SET CM.detail_name = ISNULL(@pDetail_name, CM.detail_cd),
            CM.is_active_cd = ISNULL(@pIs_active_cd, CM.is_active_cd),
            CM.modifier_id = @pModifier_id,
            CM.modified_at = GETDATE()
        FROM dbo.code_master AS CM WITH (NOLOCK)
        WHERE CM.group_cd = @pGroup_cd
            AND CM.detail_cd = @pDetail_cd;

        SET @result_cd = 0;
        SET @result_msg = '성공';
    END TRY
    BEGIN CATCH
        SET @result_cd = -1;
        SET @result_msg = ERROR_MESSAGE();
    END CATCH
END
```

이 프로시저는 `code_master` 테이블에서 특정 조건에 따라 데이터를 업데이트하며, 시스템 코드에 대한 무효한 수정 시 오류 메시지를 반환합니다.

--- spUpdateProjectOwners ---
Analysis Time: 8/21/2025, 9:50:59 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 내용입니다.

### 프로시저 `spUpdateProjectOwners` 요약

**작성자:** Jay Kwon
**작성일:** 2025-07-22
**목적:** 프로젝트의 마케터(owner)를 변경하거나 업데이트하는 작업

---

### 주요 기능

1. **프로젝트 유효성 체크**
   - 프로젝트 ID가 존재하지 않으면 오류 반환
   - 프로젝트 유형이 '90'(템플릿)인 경우 마케터 할당 불가

2. **마케터 ID 처리**
   - CSV 형식의 마케터 ID 목록을 테이블로 변환
   - 중복된 마케터 ID는 제거

3. **마케터 할당/변경 작업**
   - 기존 마케터가 신청된 상태라면 승인 상태로 변경
   - 새로운 마케터는 승인 상태로 추가
   - 전달된 목록에 없는 마케터는 비활성화

4. **트랜잭션 및 오류 처리**
   - 작업 전 트랜잭션 시작
   - 오류 발생 시 롤백 수행
   - 결과 코드(`@result_cd`)와 메시지(`@result_msg`) 반환

5. **로그 기록**
   - 호출자 ID, 심각도, 프로젝트 ID, 로그 메시지, 결과 코드 등을 로그 테이블에 기록

---

### 주요 로직 흐름

```mermaid
graph TD
    A[프로시저 시작] --> B{프로젝트 존재 여부}
    B -->|존재| C{프로젝트 유형 확인}
    C -->|일반 프로젝트| D[마케터 처리]
    C -->|템플릿 프로젝트| E[오류 반환]
    D --> F[기존 마케터 승인 처리]
    D --> G[새로운 마케터 추가]
    D --> H[비활성화 처리]
    F --> I[트랜잭션 커밋]
    I --> J[결과 반환]
```

---

### 실행 예시

```sql
DECLARE @result_cd INT, @result_msg VARCHAR(100);

EXEC [dbo].[spUpdateProjectOwners]
    @pProject_id = 25070103,
    @pMember_ids = '2400001, 2400002',
    @pModifier_id = 2400002,
    @result_cd = @result_cd OUTPUT,
    @result_msg = @result_msg OUTPUT;

SELECT @result_cd as result_cd, @result_msg as result_msg;
```

- **입력 파라미터:**
  - `@pProject_id`: 프로젝트 ID
  - `@pMember_ids`: CSV 형식의 마케터 ID 목록
  - `@pModifier_id`: 변경자 ID

- **출력 파라미터:**
  - `@result_cd`: 결과 코드 (0: 성공, -1: 실패)
  - `@result_msg`: 결과 메시지

---

### 주요 변경 사항
- **프로젝트 유형 제한**: 템플릿 프로젝트에 마케터 할당 불가
- **마케터 중복 제거**: CSV에서 중복된 마케터 ID 제거
- **상태 관리**: 기존 마케터는 승인 상태로 유지, 새로운 마케터는 추가, 제외된 마케터는 비활성화
- **트랜잭션 안전성**: 작업 실패 시 자동 롤백 수행

이 프로시저는 프로젝트의 마케터를 안전하게 변경할 수 있도록 설계되었습니다.

--- spUpdateForcedFinishForProject ---
Analysis Time: 8/21/2025, 9:51:16 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 결과입니다.

### 📌 프로시저명: `spUpdateForcedFinishForProject`

### 📌 목적: 프로젝트 강제 종료 처리

### 📌 주요 로직 요약:

1. **입력 파라미터**
   - `@pProject_id` (프로젝트 ID)
   - `@pForced_end_reason` (강제 종료 사유)
   - `@pExclude_statistics` (통계 제외 여부: 1로 설정 시 통계 제외)
   - `@pModifier_id` (수정자 ID)

2. **프로젝트 정보 업데이트**
   - `project` 테이블에서 해당 프로젝트 ID를 찾아 강제 종료 정보를 업데이트
   - 업데이트 내용:
     - `forced_end_dt`: 현재 날짜 (`YYYY-MM-DD` 형식)
     - `forced_end_reason`: 입력된 강제 종료 사유
     - `project_type_cd`: 통계 제외 옵션이 설정된 경우 '20'으로 설정 (테스트 프로젝트)
     - `modifier_id`: 수정자 ID
     - `modified_at`: 현재 시간

3. **결과 반환**
   - 성공 시: `@result_cd = 0`, `@result_msg = '성공'`
   - 실패 시: `@result_cd = -1`, `@result_msg =` 오류 메시지

### 📌 주요 특징:
- 트랜잭션 격리 수준을 `READ UNCOMMITTED`로 설정
- `NOLOCK`을 사용하여 성능 최적화
- 입력 파라미터 중 `@pExclude_statistics`가 1로 설정되면 통계 제외 처리

### 📌 사용 예시:
```sql
DECLARE @result_cd INT, @result_msg VARCHAR(100);

EXEC [dbo].[spUpdateForcedFinishForProject]
    @pProject_id = 2,
    @pForced_end_reason = '조기 종료 요청에 따라 강제 종료 처리',
    @pModifier_id = 1,
    @result_cd = @result_cd OUTPUT,
    @result_msg = @result_msg OUTPUT;

SELECT @result_cd AS result_cd, @result_msg AS result_msg;
```

### 📌 정리된 코드:
```sql
CREATE PROCEDURE [dbo].[spUpdateForcedFinishForProject]
    @pProject_id INT = NULL,
    @pForced_end_reason VARCHAR(200) = NULL,
    @pExclude_statistics INT = NULL,
    @pModifier_id VARCHAR(7) = NULL,
    @result_cd INT OUTPUT,
    @result_msg VARCHAR(200) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
    DECLARE @vProject_type_cd VARCHAR(8) = NULL;

    BEGIN TRY
        IF (@pExclude_statistics = 1)
        BEGIN
            SET @vProject_type_cd = '20';
        END

        UPDATE P
        SET
            P.forced_end_dt = CONVERT(VARCHAR(10), GETDATE(), 120),
            P.forced_end_reason = @pForced_end_reason,
            P.project_type_cd = ISNULL(@vProject_type_cd, P.project_type_cd),
            P.modifier_id = @pModifier_id,
            P.modified_at = GETDATE()
        FROM
            dbo.project AS P
            WITH (NOLOCK)
        WHERE
            P.project_id = @pProject_id;

        SET @result_cd = 0;
        SET @result_msg = '성공';
    END TRY
    BEGIN CATCH
        SET @result_cd = -1;
        SET @result_msg = ERROR_MESSAGE();
    END CATCH
END
```

### ✅ 요약 정리:
- 프로젝트 강제 종료 정보를 업데이트하고 통계 제외 옵션을 처리하는 프로시저
- 성공 또는 실패 결과를 `@result_cd`와 `@result_msg`로 반환

--- spGetDelayedTaskList ---
Analysis Time: 8/21/2025, 9:51:35 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 결과입니다.

### 프로시저 `spGetDelayedTaskList` 요약

**작성자:** Jay Kwon
**작성일:** 2025-07-24
**목적:** 태스크 지연 리스트 조회

---

### 주요 로직

1. **입력 파라미터**
   - `@pCreator_id` (VARCHAR(7)): 사용자 ID (선택적)

2. **출력 파라미터**
   - `@result_cd` (INT): 결과 코드
   - `@result_msg` (VARCHAR(200)): 결과 메시지

3. **주요 작업**
   - 현재 날짜를 `@vNow_dt`에 저장
   - 프로젝트, 태스크, 착수 계획, 실제 착수 일정 등을 조회
   - 지연된 태스크 리스트를 반환
   - 오류 발생 시 롤백 수행
   - 로그 기록 삽입

4. **조회 조건**
   - 프로젝트 유형(`project_type_cd`)은 '10'
   - 프로젝트 상태(`is_active`)는 '10'
   - 착수 계획(`plan_cd`)은 '20'
   - 실제 착수 일정(`TFA.end_dt`)이 현재 날짜보다 미래인 경우
   - 프로젝트 착수(`kick_off_cd`)는 '10'

---

### 주요 테이블 및 컬럼

- **프로젝트 정보**
  - `dbo.project` (P)
  - 컬럼: `project_id`, `project_name`, `project_type_cd`, `kick_off_cd`, `is_active`, `forced_end_dt`

- **태스크 정보**
  - `dbo.task` (T)
  - 컬럼: `task_id`, `task_name`

- **태스크 착수 계획**
  - `dbo.task_finish_plan` (TFA)
  - 컬럼: `task_id`, `project_id`, `plan_cd`, `end_dt`

- **태스크 착수 계획(예정)**
  - `dbo.task_finish_plan` (TFP)
  - 컬럼: `task_id`, `project_id`, `plan_cd`, `start_dt`, `end_dt`

- **태스크 담당자**
  - `dbo.task_owner` (TOWN)
  - 컬럼: `task_id`, `member_id`, `is_active_cd`

- **프로젝트 담당자**
  - `dbo.project_owner` (PO)
  - 컬럼: `project_id`, `member_id`, `is_active_cd`

- **HR 정보**
  - `dbo.hr_master` (HM1, HM2)
  - 컬럼: `EMP_ID`, `MOIN_EMAIL`, `DEPT_CODE`, `JOB_DUTY`

---

### 주요 기능 정리

- **지연된 태스크 리스트 반환**
  - 프로젝트 및 태스크 정보, 계획 일정, 실제 일정, 지연 일수 등을 계산하여 반환
- **오류 처리**
  - 오류 발생 시 `@result_cd`는 -1, `@result_msg`는 오류 메시지를 반환
- **로그 기록**
  - 호출 정보, 결과 코드, 결과 메시지를 `dbo.use_log` 테이블에 기록

---

### 실행 예시

```sql
DECLARE @result_cd INT, @result_msg VARCHAR(100);

EXEC [dbo].[spGetDelayedTaskList]
    @pCreator_id = '2400001'
  , @result_cd = @result_cd OUTPUT
  , @result_msg = @result_msg OUTPUT;

SELECT @result_cd as result_cd, @result_msg as result_msg;
```

- **입력:** `@pCreator_id` (사용자 ID)
- **출력:** `@result_cd` (0: 성공, -1: 실패), `@result_msg` (결과 메시지)

---

### 요약 정리

- **주요 목적:** 지연된 태스크 리스트를 반환
- **주요 작업:** 프로젝트 및 태스크 정보 조회, 계획 및 실제 일정 비교, 오류 처리, 로그 기록
- **출력 결과:** 지연된 태스크 리스트 및 결과 정보 반환

이렇게 정리할 수 있습니다.

--- spUpdateProjectApplicantsStatus ---
Analysis Time: 8/21/2025, 9:51:46 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 내용입니다.

### 프로시저 `spUpdateProjectApplicantsStatus` 요약

**작성자:** JayKwon
**작성일:** 2025-05-23
**목적:** 프로젝트에 참여 상태를 업데이트 한다.

---

### 주요 내용 정리

1. **파라미터**
   - `@pProject_id` (INT): 프로젝트 ID
   - `@pMember_id` (VARCHAR(7)): 회원 ID
   - `@pStatus_cd` (VARCHAR(8)): 상태 코드 (master 10:승인, 20:신청, 90:반려)
   - `@result_cd` (INT, OUTPUT): 결과 코드
   - `@result_msg` (VARCHAR(200), OUTPUT): 결과 메시지

2. **주요 로직**
   - **파라미터 유효성 체크**:
     - 프로젝트 ID가 존재하지 않으면 오류 반환
     - 회원 ID가 존재하지 않으면 오류 반환

3. **상태 업데이트**:
   - `project_member` 테이블에서 해당 프로젝트와 회원의 상태를 `@pStatus_cd`로 업데이트
   - 성공 시 `@result_cd = 0`, `@result_msg = '성공'` 설정
   - 실패 시 `@result_cd = -1`, `@result_msg = ERROR_MESSAGE()` 설정

---

### 예시 실행 코드
```sql
DECLARE @result_cd INT,
        @result_msg VARCHAR(100);

EXEC [spUpdateProjectApplicantsStatus]
    @pProject_id = 25080009,
    @pMember_id = '2400001',
    @pStatus_cd = '10',
    @result_cd = @result_cd OUTPUT,
    @result_msg = @result_msg OUTPUT;

SELECT @result_cd as result_cd,
       @result_msg as result_msg;
```

---

### 주요 특징
- **트랜잭션 격리 수준:** `READ UNCOMMITTED` 사용
- **에러 처리:** `TRY-CATCH` 블록으로 오류 관리
- **결과 반환:** `@result_cd`와 `@result_msg`를 통해 결과 전달

--- spGetDelayedStartTaskList ---
Analysis Time: 8/21/2025, 9:52:11 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 내용입니다.

### 프로시저 요약: `spGetDelayedStartTaskList`

**목적**: 프로젝트 내 계획된 태스크 중 착수가 지연된 목록을 반환.

**입력 파라미터**:
- `@pCreator_id` (VARCHAR): 사용자 ID (필수 아님).

**출력 파라미터**:
- `@result_cd` (INT): 결과 코드 (0: 성공, -1: 실패).
- `@result_msg` (VARCHAR): 결과 메시지.

---

### 주요 로직

1. **트랜잭션 설정**:
   - 트랜잭션 격리 수준을 `READ UNCOMMITTED`로 설정.
   - `@vNow_dt`에 현재 날짜를 할당.

2. **착수 지연된 태스크 조회**:
   - `task`, `project`, `task_finish_plan` 테이블에서 계획 시작일(`start_dt`)이 현재 날짜보다 이전이면서 태스크 상태가 대기 중인 경우를 조회.
   - `task_owner` 및 `project_owner` 정보를 포함하여 결과 반환.

3. **결과 처리**:
   - 성공 시 `@result_cd`를 0으로, 실패 시 -1로 설정.
   - 오류 발생 시 트랜잭션 롤백 수행.

4. **로그 기록**:
   - 호출 정보, 결과 코드, 메시지 등을 `use_log` 테이블에 기록.

---

### 정리된 코드

```sql
CREATE PROCEDURE [dbo].[spGetDelayedStartTaskList]
    @pCreator_id VARCHAR(7) = NULL,
    @result_cd INT OUTPUT,
    @result_msg VARCHAR(200) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
    DECLARE @vSeverity INT = NULL;
    DECLARE @vNow_dt VARCHAR(10) = NULL;
    SET @vNow_dt = CONVERT(VARCHAR(10), GETDATE(), 121);

    BEGIN TRY
        SELECT T.project_id,
               P.project_name,
               T.task_id,
               T.task_name,
               TFP.start_dt,
               TFP.end_dt,
               dbo.fnCalcWorkingDay(TFP.start_dt, CONVERT(VARCHAR(10), GETDATE(),121)) AS working_day_diff,
               TOWNM.task_owner_ids,
               TOWNM.task_owner_mails,
               PO1.project_owner_ids,
               PO1.project_owner_mails
        FROM dbo.task AS T WITH (NOLOCK)
            INNER JOIN dbo.project AS P WITH (NOLOCK) ON T.project_id = P.project_id
            INNER JOIN dbo.task_finish_plan AS TFP WITH (NOLOCK) ON T.task_id = TFP.task_id
            LEFT JOIN (
                SELECT TOWN.task_id,
                       STRING_AGG(CAST(MI.EMP_ID AS VARCHAR), ', ') AS task_owner_ids,
                       STRING_AGG(CAST(MI.MOIN_EMAIL AS VARCHAR), ', ') AS task_owner_mails
                FROM dbo.task_owner AS TOWN WITH (NOLOCK)
                    INNER JOIN dbo.hr_master AS MI WITH (NOLOCK) ON TOWN.member_id = MI.EMP_ID
                WHERE TOWN.is_active_cd = '10'
                GROUP BY TOWN.task_id
            ) TOWNM ON T.task_id = TOWNM.task_id
            LEFT JOIN (
                SELECT PO.project_id,
                       STRING_AGG(CAST(MI.EMP_ID AS VARCHAR), ', ') AS project_owner_ids,
                       STRING_AGG(CAST(MI.MOIN_EMAIL AS VARCHAR), ', ') AS project_owner_mails
                FROM dbo.project_owner AS PO WITH (NOLOCK)
                    INNER JOIN dbo.hr_master AS MI WITH (NOLOCK) ON PO.member_id = MI.EMP_ID
                WHERE PO.is_active_cd = '10'
                GROUP BY PO.project_id
            ) PO1 ON p.project_id = PO1.project_id
        WHERE TFP.plan_cd = '20'
            AND T.status_cd = '10'
            AND TFP.start_dt < @vNow_dt
            AND T.is_active_cd = '10'
            AND P.forced_end_dt IS NULL
            AND P.project_type_cd = '10';

        SET @vSeverity = 0;
        SET @result_cd = 0;
        SET @result_msg = '성공';
    END TRY
    BEGIN CATCH
        IF @@TRANCOUNT > 0 ROLLBACK TRAN;
        SET @result_cd = -1;
        SET @result_msg = ERROR_MESSAGE();
        SET @vSeverity = ERROR_SEVERITY();
    END CATCH

    DECLARE @log_param VARCHAR(MAX);
    SET @log_param = '@pCreator_id = ' + ISNULL(@pCreator_id, 'NULL');
    INSERT INTO dbo.use_log (
        caller_id,
        severity,
        project_id,
        log_dt,
        log_message,
        proc_name,
        proc_param,
        result_cd,
        result_msg,
        created_at
    )
    VALUES (
        ISNULL(@pCreator_id, 'UNKNOWN'),
        @vSeverity,
        ISNULL(NULL, 0),
        CONVERT(CHAR(10), GETDATE(), 120),
        '태스크 착수 지연 리스트',
        '[spGetDelayedStartTaskList]',
        @log_param,
        @result_cd,
        @result_msg,
        GETDATE()
    );

    RETURN;
END
```

---

### 주요 변경 사항
- 불필요한 `DECLARE` 및 중복된 코드 제거.
- `BEGIN CATCH` 블록에서 오류 처리 로직 간소화.
- `INSERT` 문의 컬럼 순서 및 값을 직관적으로 정리.
- 불필요한 주석 및 실행 예제 제거.

이렇게 정리된 프로시저는 동일한 기능을 유지하면서도 가독성과 유지보수성을 높였습니다.

--- spUpdateTask ---
Analysis Time: 8/21/2025, 9:52:20 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 내용입니다:

### 프로시저 `spUpdateTask` 요약

**목적**: 태스크 업데이트 처리

**주요 기능**:
1. **태스크 정보 수정**
   - `task_name`, `status_cd`, `is_output_need`, `modifier_id`, `modified_at` 컬럼 업데이트
   - `task_id`가 필수이며, 완료된 태스크(`status_cd = '90'`)는 수정 불가

2. **태스크 담당자 관리**
   - `pMember_ids` 파라미터로 전달된 CSV 문자열을 파싱하여 담당자 목록 업데이트
   - 담당자 정보 검증 후, 신규 담당자는 삽입, 기존 담당자는 활성화 상태(`is_active_cd`)를 조정

3. **워킹데이 관리**
   - 프로젝트 유형(`project_type_cd`)이 '90'인 경우만 `std_workding_day` 수정 가능

4. **오류 처리**
   - 다양한 오류 조건에 대한 검증 로직 포함 (예: 존재하지 않는 회원, 완료된 태스크 수정 불가 등)

5. **로깅**
   - 호출 정보, 수정 내용, 결과 메시지를 `use_log` 테이블에 기록

**출력 파라미터**:
- `@result_cd`: 결과 코드 (0: 성공, -1: 실패)
- `@result_msg`: 결과 메시지

**주요 로직 흐름**:
1. 입력 파라미터 검증
2. 태스크 및 담당자 정보 업데이트
3. 워킹데이 수정 (프로젝트 유형에 따라)
4. 오류 발생 시 롤백
5. 로깅 및 결과 반환

이 요약은 프로시저의 주요 기능과 흐름을 중심으로 작성되었습니다. 상세한 조건문과 오류 처리, 로깅 관련 내용은 생략되었습니다.

--- spUpdateTaskPlanDate ---
Analysis Time: 8/21/2025, 9:53:22 AM
AI Analysis:
API 호출 실패: 504 Gateway Time-out

--- spUpdateTaskState ---
Analysis Time: 8/21/2025, 9:54:02 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 내용입니다.

### 프로시저 요약: `[dbo].[spUpdateTaskState]`

#### 주요 기능
- **태스크 상태 업데이트** (착수, 완료 등)
- **상태 코드 검증**
- **디펜던시(의존성) 관계 검사**
- **태스크 일정 관리 (시작일, 종료일, 워킹데이 계산 등)**
- **부모-자식 태스크 간 일정 동기화**

---

### 주요 코드 정리

```sql
CREATE PROCEDURE [dbo].[spUpdateTaskState]
    @pTask_id INT = NULL,
    @pState_cd VARCHAR(8) = NULL,
    @pModifier_id VARCHAR(7) = NULL,
    @result_cd INT OUTPUT,
    @result_msg VARCHAR(200) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

    DECLARE @vProject_id INT = NULL;
    DECLARE @vParent_end_dt VARCHAR(10) = NULL;
    DECLARE @vChild_end_dt VARCHAR(10) = NULL;
    DECLARE @vParent_task_id INT = NULL;

    -- 프로젝트 아이디 획득
    SELECT @vProject_id = MAX(T.project_id)
    FROM dbo.task AS T WITH (NOLOCK)
    WHERE T.task_id = @pTask_id
    GROUP BY T.project_id;

    -- 상태 코드 검증
    IF NOT EXISTS(
        SELECT 1
        FROM dbo.code_master AS CM WITH (NOLOCK)
        WHERE CM.group_cd = '90300' AND CM.detail_cd = @pState_cd
    )
    BEGIN
        SET @result_cd = 1;
        SET @result_msg = '존재하지 않는 상태 코드 입니다.';
        RETURN;
    END;

    -- 완료 처리 하려는데 디펜던시 관계의 오류
    IF (@pState_cd = '90')
    BEGIN
        -- 하위 태스크 완료 여부 검사
        IF EXISTS(
            SELECT 1
            FROM dbo.task_dependency AS TD WITH (NOLOCK)
            INNER JOIN dbo.task AS T WITH (NOLOCK) ON TD.task_id = T.task_id
            WHERE TD.dependency_id = @pTask_id AND TD.dependency_cd = '10' AND T.status_cd != '90'
        )
        BEGIN
            SET @result_cd = 1;
            SET @result_msg = '하위 태스크가 모두 완료 처리 되어야 상위 태스크를 완료 할 수 있습니다.';
            RETURN;
        END

        -- 선행 태스크 완료 여부 검사
        IF EXISTS(
            SELECT *
            FROM dbo.task_dependency AS TD WITH (NOLOCK)
            INNER JOIN dbo.task AS T WITH (NOLOCK) ON TD.dependency_id = T.task_id
            WHERE TD.task_id = @pTask_id AND TD.dependency_cd = '20' AND T.status_cd != '90'
        )
        BEGIN
            SET @result_cd = 1;
            SET @result_msg = '선행 태스크가 완료 되어야 후행 태스크를 완료 처리 할 수 있습니다.';
            RETURN;
        END
    END;

    BEGIN TRY
        BEGIN TRAN

            -- 착수일때
            IF (@pState_cd = '20')
            BEGIN
                DECLARE @vToday VARCHAR(10) = NULL;
                SET @vToday = CONVERT(VARCHAR(10), GETDATE(), 120);

                IF EXISTS(
                    SELECT 1
                    FROM dbo.task AS T WITH (NOLOCK)
                    WHERE T.task_id = @pTask_id AND T.status_cd = '90'
                )
                BEGIN
                    ROLLBACK TRAN;
                    SET @result_cd = 1;
                    SET @result_msg = '이미 완료 한 태스크 입니다. 착수 상태로 변경할 수 없습니다.';
                    RETURN;
                END

                -- task_finish_plan에 실제 시작 일자(30)을 오늘 날짜로 업데이트
                UPDATE TFP
                SET TFP.start_dt = @vToday,
                    TFP.end_dt = dbo.fnGetWorkingDateAdd(@vToday, TFP.working_day),
                    TFP.modifier_id = @pModifier_id,
                    TFP.modified_at = GETDATE()
                FROM dbo.task_finish_plan AS TFP WITH (NOLOCK)
                WHERE TFP.task_id = @pTask_id AND TFP.plan_cd = '30';

                -- task의 상태를 착수로 업데이트 (20)
                UPDATE T
                SET T.status_cd = '20',
                    T.modifier_id = @pModifier_id,
                    T.modified_at = GETDATE()
                FROM dbo.task AS T WITH (NOLOCK)
                WHERE T.task_id = @pTask_id;
            END

            -- 완료 일때
            ELSE IF (@pState_cd = '90')
            BEGIN
                -- task_finish_plan에 실제 완료 일자(30)을 오늘 날짜로 업데이트
                UPDATE TFP
                SET TFP.end_dt = CONVERT(VARCHAR(10), GETDATE(), 120),
                    TFP.working_day = dbo.fnCalcWorkingDay(TFP.start_dt, CONVERT(VARCHAR(10), GETDATE(), 120)),
                    TFP.modifier_id = @pModifier_id,
                    TFP.modified_at = GETDATE()
                FROM dbo.task_finish_plan AS TFP WITH (NOLOCK)
                WHERE TFP.task_id = @pTask_id AND TFP.plan_cd = '30';

                -- task의 상태를 완료로 업데이트 (90)
                UPDATE T
                SET T.status_cd = '90',
                    T.modifier_id = @pModifier_id,
                    T.modified_at = GETDATE()
                FROM dbo.task AS T WITH (NOLOCK)
                WHERE T.task_id = @pTask_id;

                -- 부모 태스크 일정 점검
                IF EXISTS(
                    SELECT 1
                    FROM dbo.task_dependency AS TD WITH (NOLOCK)
                    WHERE TD.task_id = @pTask_id AND TD.dependency_cd = '10'
                )
                BEGIN
                    -- 부모 종료일 획득
                    SELECT @vParent_end_dt = TFP.end_dt,
                           @vParent_task_id = TFP.task_id
                    FROM dbo.task_dependency AS TD WITH (NOLOCK)
                    INNER JOIN dbo.task_finish_plan AS TFP WITH (NOLOCK) ON TD.dependency_id = TFP.task_id
                    WHERE TD.task_id = @pTask_id AND TD.dependency_cd = '10' AND TFP.plan_cd = '30';

                    -- 자식 종료일 획득
                    SELECT @vChild_end_dt = TFP.end_dt
                    FROM dbo.task_finish_plan AS TFP WITH (NOLOCK)
                    WHERE TFP.task_id = @pTask_id AND TFP.plan_cd = '30';

                    -- 부모 종료일이 자식 종료일보다 작으면 확장
                    IF (@vParent_end_dt < @vChild_end_dt)
                    BEGIN
                        UPDATE TFP
                        SET TFP.end_dt = @vChild_end_dt
                        FROM dbo.task_finish_plan AS TFP WITH (NOLOCK)
                        WHERE TFP.task_id = @vParent_task_id AND TFP.plan_cd = '30';
                    END
                END
            END
            ELSE
            BEGIN
                ROLLBACK TRAN;
                SET @result_cd = 1;
                SET @result_msg = '처리할 수 없는 상태 코드.';
                RETURN;
            END

            COMMIT TRAN

            DECLARE @vResult_cd INT, @vResult_msg VARCHAR(100);

            -- 태스크 일정 쉬프팅 (계획일)
            EXEC [dbo].[spUpdateDateByShifting]
                @pProject_id = @vProject_id,
                @pTask_id = @pTask_id,
                @pPlan_cd = '30',
                @result_cd = @vResult_cd OUTPUT,
                @result_msg = @vResult_msg OUTPUT;

            IF (@vResult_cd = -1)
            BEGIN
                RAISERROR('태스크 (계획)일정 쉬프팅 오류 발생 [spUpdateTaskPlanDate]', 16, 1);
            END

            SET @result_cd = 0;
            SET @result_msg = '성공';
        END TRY
        BEGIN CATCH
            ROLLBACK TRAN;
            SET @result_cd = -1;
            SET @result_msg = ERROR_MESSAGE();
        END CATCH
END
```

---

### 정리된 주요 기능 설명

1. **태스크 상태 관리**
   - 태스크의 착수(`20`) 및 완료(`90`) 상태 변경 처리
   - 상태 코드가 유효한지 검증
   - 하위/선행 태스크의 상태를 검사하여 의존성 준수 여부 확인

2. **일정 관리**
   - `task_finish_plan` 테이블에서의 시작일(`start_dt`)과 종료일(`end_dt`) 업데이트
   - 워킹데이 계산 및 업데이트
   - 부모-자식 태스크 간 종료일 동기화

3. **오류 처리**
   - 하위 태스크가 완료되지 않은 경우 완료 불가
   - 선행 태스크가 완료되지 않은 경우 후행 태스크 완료 불가
   - 태스크 상태가 잘못된 경우 오류 반환

---

이렇게 정리된 코드는 주요 기능과 흐름을 명확하게 보여주며, 불필요한 세부사항은 생략되었습니다.

--- spUpdateProjectKickOff ---
Analysis Time: 8/21/2025, 9:54:14 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 결과입니다.

### 프로시저 `spUpdateProjectKickOff` 요약

**작성자:** jay kwon
**작성일:** 2025-06-16
**목적:** 프로젝트 킥오프(착수) 절차 수행

---

### 주요 로직 정리

1. **입력 파라미터**
   - `@pProject_id` (프로젝트 ID)
   - `@pProject_owner_id` (프로젝트 소유자 ID)

2. **출력 파라미터**
   - `@result_cd` (결과 코드)
   - `@result_msg` (결과 메시지)

3. **핵심 처리 절차**
   - **프로젝트 소유자 검증**
     - `project_owner` 테이블에서 `@pProject_owner_id`가 `@pProject_id`의 소유자인지 확인
     - 소유자가 아니면 오류 반환

   - **킥오프 가능 상태 검증**
     - `fnGetStateForKickOff` 함수로 킥오프 가능 상태 확인
     - 상태가 적절하지 않으면 오류 반환

   - **킥오프(착수) 처리**
     - `task_finish_plan` 테이블에서 계획 일정을 실제 일정으로 변경
     - 프로젝트 정보 업데이트:
       - `kick_off_cd`를 '10'(착수)으로 설정
       - `planed_end_dt` 및 `planed_working_day` 계산 및 설정
       - 수정자 정보(`modifier_id`, `modified_at`) 업데이트

4. **트랜잭션 관리**
   - 트랜잭션 격리 수준 `READ UNCOMMITTED` 사용
   - `BEGIN TRAN`, `COMMIT TRAN`, `ROLLBACK TRAN`으로 트랜잭션 관리

5. **오류 처리**
   - `TRY-CATCH` 블록으로 오류 처리
   - 오류 발생 시 `@result_cd`와 `@result_msg`에 오류 정보 저장

---

### 주요 기능 정리

- **프로젝트 착수 절차**를 수행하며, 착수 조건을 충족하지 않으면 오류를 반환합니다.
- 착수 성공 시 프로젝트 상태를 '착수'로 변경하고, 관련된 일정 및 작업 정보를 업데이트합니다.

--- spUpdateTaskActualDate ---
Analysis Time: 8/21/2025, 9:54:44 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 내용입니다.

---

### 프로시저 `spUpdateTaskActualDate` 요약

**목적**: 전체 1뎁스의 실제 일정 재계산

**주요 기능**:
1. **워킹데이 보정 (시작 전)**
   - `task_finish_plan` 테이블에서 `project_id`와 `plan_cd`를 조건으로 `working_day`를 계산하여 업데이트

2. **루트 태스크 처리**
   - `task_dependency`와 `task_finish_plan` 테이블을 조회하여 최상위 루트 태스크를 찾음
   - 재귀적으로 각 태스크의 시작일과 종료일을 계산하여 `task_finish_plan` 테이블 업데이트

3. **워킹데이 보정 (완료 후)**
   - `task_finish_plan` 테이블에서 `project_id`와 `plan_cd`를 조건으로 `working_day`를 재계산하여 업데이트

**출력 파라미터**:
- `@result_cd`: 프로시저 실행 결과 코드 (0: 성공, -1: 실패)
- `@result_msg`: 실행 결과 메시지

---

### 코드 정리

```sql
CREATE PROCEDURE [dbo].[spUpdateTaskActualDate]
    @pProject_id INT = NULL,
    @result_cd INT OUTPUT,
    @result_msg VARCHAR(200) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

    BEGIN TRY
        BEGIN TRAN

            -- 워킹데이 보정 (시작전)
            UPDATE TFP
            SET TFP.working_day = dbo.fnCalcWorkingDay(TFP.start_dt, TFP.end_dt)
            FROM dbo.task_finish_plan AS TFP
            WITH (NOLOCK)
            WHERE TFP.project_id = @pProject_id
            AND TFP.plan_cd = '30';

            DECLARE @vRootTask TABLE (
                task_id INT,
                end_dt VARCHAR(10),
                processed INT
            );

            -- 루트 태스크 삽입
            INSERT INTO @vRootTask
            SELECT TD1.dependency_id AS task_id,
                TFP.end_dt,
                0 AS processed
            FROM task_dependency AS TD1
            LEFT JOIN task_dependency AS TD2
                ON TD1.dependency_id = TD2.task_id
                AND TD2.dependency_cd = '20'
            INNER JOIN dbo.task_finish_plan AS TFP
                ON TD1.task_id = TFP.task_id
                AND TFP.plan_cd = '30'
            WHERE TD1.project_id = @pProject_id
                AND TD1.dependency_cd = '20'
                AND TD2.task_id IS NULL;

            -- 루프 시작
            DECLARE @vOuterTaskID INT = NULL;
            SELECT @vOuterTaskID = T.task_id
            FROM @vRootTask AS T
            WHERE T.processed = 0;

            WHILE (@vOuterTaskID IS NOT NULL)
            BEGIN
                -- 재귀 CTE
                WITH DependencyChain AS (
                    -- 시작점
                    SELECT TD.task_id,
                        TD.dependency_id,
                        TD.dependency_cd,
                        dbo.fnGetWorkingDateAdd(TFP1.end_dt, 1) AS new_start_dt,
                        dbo.fnGetWorkingDateAdd(TFP1.end_dt, TFP2.working_day) AS new_end_dt,
                        1 AS level
                    FROM dbo.task_dependency AS TD
                    WITH (NOLOCK)
                    INNER JOIN dbo.task_finish_plan AS TFP1
                        WITH (NOLOCK)
                        ON TD.dependency_id = TFP1.task_id
                        AND TFP1.plan_cd = '30'
                    INNER JOIN dbo.task_finish_plan AS TFP2
                        WITH (NOLOCK)
                        ON TD.task_id = TFP2.task_id
                        AND TFP2.plan_cd = '30'
                    WHERE TD.dependency_cd = '20'
                        AND TD.dependency_id = @vOuterTaskID
                    UNION ALL
                    -- 재귀 부분
                    SELECT TDNext.task_id,
                        TDNext.dependency_id,
                        TDNext.dependency_cd,
                        dbo.fnGetWorkingDateAdd(DC.new_end_dt, 1) AS new_start_dt,
                        dbo.fnGetWorkingDateAdd(DC.new_end_dt, TFP2.working_day) AS new_end_dt,
                        DC.level + 1
                    FROM dbo.task_dependency TDNext
                    INNER JOIN DependencyChain DC
                        ON TDNext.dependency_id = DC.task_id
                    INNER JOIN dbo.task_finish_plan AS TFP2
                        WITH (NOLOCK)
                        ON TDNext.task_id = TFP2.task_id
                        AND TFP2.plan_cd = '30'
                    WHERE TDNext.dependency_cd = '20'
                )

                UPDATE TFP
                SET TFP.start_dt = DC.new_start_dt,
                    TFP.end_dt = DC.new_end_dt
                FROM dbo.task_finish_plan AS TFP
                WITH (NOLOCK)
                INNER JOIN DependencyChain AS DC
                    ON TFP.task_id = DC.task_id
                    AND TFP.plan_cd = '30';

                -- 루트 처리 완료
                UPDATE T
                SET T.processed = 1
                FROM @vRootTask AS T
                WHERE T.task_id = @vOuterTaskID;

                -- 다음 루트 task_id 가져오기
                SET @vOuterTaskID = NULL;
                SELECT @vOuterTaskID = T.task_id
                FROM @vRootTask AS T
                WHERE T.processed = 0;
            END

            -- 워킹데이 보정 (완료후)
            UPDATE TFP
            SET TFP.working_day = dbo.fnCalcWorkingDay(TFP.start_dt, TFP.end_dt)
            FROM dbo.task_finish_plan AS TFP
            WITH (NOLOCK)
            WHERE TFP.project_id = @pProject_id
            AND TFP.plan_cd = '30';

            COMMIT TRAN
            SET @result_cd = 0;
            SET @result_msg = '성공';

        END TRY
        BEGIN CATCH
            ROLLBACK TRAN
            SET @result_cd = -1;
            SET @result_msg = ERROR_MESSAGE();
        END CATCH
END
```

---

### 정리된 코드의 주요 변경 사항
1. **불필요한 부분 제거**
   - 테스트용 `EXEC` 문과 `SELECT` 문 제거
   - 불필요한 주석 제거

2. **기능적 변경 없음**
   - 프로시저의 핵심 로직과 기능은 그대로 유지

3. **가독성 개선**
   - 들여쓰기와 줄바꿈을 활용하여 코드 구조를 명확히 함
   - `BEGIN`과 `END` 블록을 적절히 배치하여 코드 범위를 명확히 표시

---

위 정리된 코드는 프로시저의 핵심 기능을 간결하게 표현한 내용으로, 실제 실행 시에는 입력 파라미터와 출력 파라미터를 적절히 처리해야 합니다.

--- spGetCodeMasterForBrand ---
Analysis Time: 8/21/2025, 9:54:58 AM
AI Analysis:
아래는 요청하신 프로시저 코드를 최대한 요약하고 정리한 결과입니다.

### 요약된 코드
```sql
CREATE PROCEDURE [dbo].[spGetCodeMasterForBrand]
    @pBrand_type VARCHAR(8) = NULL,
    @result_cd INT OUTPUT,
    @result_msg VARCHAR(200) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

    IF @pBrand_type = 'NB'
    BEGIN
        SELECT NB.BRANDCODE AS brand_cd, NB.BRANDNAME AS brand_name
        FROM dbo.IF_SAP_NPD_BRAND AS NB WITH (NOLOCK)
        WHERE NB.BRANDTYPE = '200'
        ORDER BY NB.BRANDNAME ASC;

        SET @result_cd = 0;
        SET @result_msg = '성공';
        RETURN;
    END
    ELSE IF @pBrand_type = 'FB'
    BEGIN
        SELECT FB.BRANDCODE AS brand_cd, FB.BRANDNAME AS brand_name
        FROM dbo.IF_SAP_NPD_BRAND AS FB WITH (NOLOCK)
        WHERE FB.BRANDTYPE = '100'
        ORDER BY FB.BRANDNAME ASC;

        SET @result_cd = 0;
        SET @result_msg = '성공';
        RETURN;
    END
    ELSE
    BEGIN
        SET @result_cd = 1;
        SET @result_msg = '정의되지 않은 브랜드 타입';
        RETURN;
    END

    SET @result_cd = 0;
    SET @result_msg = '성공';
END
```

### 정리된 내용
1. 프로시저의 주요 기능:
   - SAP 기준의 일반('NB') 또는 패밀리('FB') 브랜드 코드를 가져옵니다.
   - 각 브랜드 타입에 따라 다른 테이블에서 데이터를 조회합니다.

2. 주요 로직:
   - 입력된 `@pBrand_type` 값을 확인하여 'NB' 또는 'FB'인 경우 해당하는 브랜드 정보를 조회합니다.
   - 조회된 브랜드 정보는 `BRANDCODE`와 `BRANDNAME`을 반환합니다.
   - 정상적인 처리 완료 시 `@result_cd`는 0, `@result_msg`는 '성공'으로 설정됩니다.
   - 잘못된 브랜드 타입이 입력된 경우 `@result_cd`는 1, `@result_msg`는 오류 메시지로 설정됩니다.

3. 성능 및 안정성 개선 사항:
   - `NOCOUNT`를 설정하여 불필요한 행 수 반환을 방지합니다.
   - `READ UNCOMMITTED` 트랜잭션 격리 수준을 사용하여 성능을 최적화합니다.
   - `TRY-CATCH` 블록을 사용하여 오류를 처리하고, 오류 발생 시 `@result_cd`와 `@result_msg`를 적절히 설정합니다.

이렇게 요약된 코드는 프로시저의 핵심 기능을 유지하면서도 가독성과 유지보수성을 높였습니다.
