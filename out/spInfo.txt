=== Stored Procedure Information ===
Generated at: 8/20/2025, 1:32:34 PM
Total procedures: 70

--- Procedure 1 ---
ProcedureName: spBatchTransferHolidayInfo
ProcedureDefinition:
-- =============================================
-- Author:		Jay Kwon
-- Create date: 2025-08-06
-- Description:	뷰를 참조하여 로컬 디비의 휴일 데이터를 동기화 한다 (10년치)
-- 8/12 IS팀 요청에 의해 아웃풋 파람 제거

/* 실행예제
EXEC [dbo].[spBatchTransferHolidayInfo]
*/
-- =============================================
CREATE PROCEDURE [dbo].[spBatchTransferHolidayInfo]
AS
BEGIN
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	DECLARE @result_cd		        INT = NULL;
	DECLARE @result_msg		        VARCHAR(200) = NULL;
	DECLARE @vSeverity				INT = NULL;

    DECLARE @target_holiday  TABLE(
        formated_dt     VARCHAR(10) PRIMARY KEY,
        holiday_nm      VARCHAR(20)
    );

    BEGIN TRY

		BEGIN TRAN;

            TRUNCATE TABLE dbo.calendar;

            -- 11년치 주말 데이터 재생성
            DECLARE @date DATE = '2024-01-01';
            WHILE @date <= '2034-12-31'
            BEGIN
                DECLARE @description NVARCHAR(20) = NULL;

                -- 요일 기반 주말 처리
                IF DATENAME(WEEKDAY, @date) IN ('Saturday', '토요일')
                    SET @description = '토요일';
                ELSE IF DATENAME(WEEKDAY, @date) IN ('Sunday', '일요일')
                    SET @description = '일요일';

                -- INSERT
                INSERT INTO dbo.calendar (
                    target_dt,
                    date_description,
                    creator_id,
                    created_at,
                    modifier_id,
                    modified_at
                )
                VALUES (
                    @date,
                    @description,
                    'system',
                    GETDATE(),
                    NULL,
                    NULL
                );

                SET @date = DATEADD(DAY, 1, @date); 
            END;

            INSERT INTO @target_holiday
            SELECT 
                CONVERT(VARCHAR(10), CONVERT(DATE, HC.HOLIDAY_DATE), 120)   AS formated_dt,
                TRIM(HC.HOLIDAY_NAME)                                       AS holiday_nm
            FROM dbo.VW_NPD_HolidayCalendar AS HC WITH (NOLOCK)            

            UPDATE C SET
                C.date_description = TH.holiday_nm,
                C.creator_id = 'synced'                
            FROM dbo.calendar AS C WITH (NOLOCK)
                INNER JOIN @target_holiday AS TH
                ON C.target_dt = TH.formated_dt

		COMMIT TRAN;

		SET @vSeverity = 0;
		SET @result_cd = 0;
		SET @result_msg = '성공';

	END TRY

	BEGIN CATCH
		IF @@TRANCOUNT > 0
			ROLLBACK TRAN;
          
		SET @result_cd = -1;
		SET @result_msg = ERROR_MESSAGE();
		SET @vSeverity = ERROR_SEVERITY();
	END CATCH
    
	DECLARE @log_param VARCHAR(MAX);

	INSERT INTO dbo.use_log (caller_id, severity, project_id, log_dt, log_message, proc_name, proc_param, result_cd, result_msg, created_at)
	VALUES(ISNULL(CAST('system' AS VARCHAR(8)), 'UNKNOWN'), @vSeverity, ISNULL(NULL, 0), CONVERT(CHAR(10), GETDATE(), 120), '휴일 데이터 동기화', '[spTransferHolidayInfo]', NULL, @result_cd, @result_msg, GETDATE());


	RETURN;
END


--- Procedure 2 ---
ProcedureName: spBatchTransferDeptMaster
ProcedureDefinition:
-- =============================================
-- Author:		Jay Kwon
-- Create date: 2025-08-06
-- Description:	부서 정보를 동기화 한다. (00:10 수행)
/* 실행예제
EXEC [dbo].[spTransferDeptMaster]
*/
-- =============================================
CREATE PROCEDURE [dbo].[spBatchTransferDeptMaster]

AS
BEGIN
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	DECLARE @result_cd		        INT = NULL;
	DECLARE @result_msg		        VARCHAR(200) = NULL;
	DECLARE @vSeverity				INT = NULL;

    BEGIN TRY

		BEGIN TRAN;

		TRUNCATE TABLE dbo.dept_master;

		INSERT INTO dbo.dept_master
		SELECT
			DM.DEPT_CODE,
			DM.DEPT_NAME,
			DM.PARENT_DEPT_CODE,
			'system'	AS creator_id,
			GETDATE()	AS created_at
		FROM dbo.VW_NPD_orgDeptMaster AS DM WITH (NOLOCK)

		
		COMMIT TRAN;

		SET @vSeverity = 0;
		SET @result_cd = 0;
		SET @result_msg = '성공';

	END TRY

	BEGIN CATCH
		IF @@TRANCOUNT > 0
			ROLLBACK TRAN;

		SET @result_cd = -1;
		SET @result_msg = ERROR_MESSAGE();
		SET @vSeverity = ERROR_SEVERITY();
	END CATCH

	DECLARE @log_param VARCHAR(MAX);

	SET @log_param = NULL;
				   

	INSERT INTO dbo.use_log (caller_id, severity, project_id, log_dt, log_message, proc_name, proc_param, result_cd, result_msg, created_at)
	VALUES(ISNULL(CAST('system' AS VARCHAR(8)), 'UNKNOWN'), @vSeverity, ISNULL(NULL, 0), CONVERT(CHAR(10), GETDATE(), 120), '부서정보 동기화', '[spTransferDeptMaster]', @log_param, @result_cd, @result_msg, GETDATE());


	RETURN;
END


--- Procedure 3 ---
ProcedureName: spBatchTransferHreMaster
ProcedureDefinition:
-- =============================================
-- Author:		Jay Kwon
-- Create date: 2025-08-06
-- Description:	회원 정보를 동기화 한다. (뷰 --> 로컬), 00:20 수행
-- 8/12 IS팀 요청에 의해 아웃풋 파람 제거
/* 실행예제
EXEC [dbo].[TransferHreMaster]
*/
-- =============================================
CREATE PROCEDURE [dbo].[spBatchTransferHreMaster]
AS
BEGIN
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	DECLARE @result_cd		INT = NULL;
	DECLARE @result_msg		VARCHAR(200) = NULL;

	DECLARE @vSeverity				INT = NULL;
	DECLARE @target_hrm TABLE(
		[EMP_ID]			[varchar](7) PRIMARY KEY,
		[NAME]				[varchar](20),
		[MOIN_ID]			[varchar](50),
		[MOIN_EMAIL]		[varchar](100),
		[DEPT_CODE]			[varchar](8),
		[JOB_CODE]			[varchar](4),
		[JOB_GRADE_NM]		[varchar](20),
		[JOB_DUTY]			[varchar](4),
		[JOB_DUTY_NM]		[varchar](20),
		[STATE_CD]			[varchar](8)	
	);

    BEGIN TRY
		BEGIN TRAN;
			-- 퇴사자 보관
			INSERT INTO @target_hrm
			SELECT
				HM.EMP_ID,
				HM.[NAME],
				HM.MOIN_ID,
				HM.MOIN_EMAIL,
				HM.DEPT_CODE,
				HM.JOB_CODE,
				HM.JOB_GRADE_NM,
				HM.JOB_DUTY,
				HM.JOB_DUTY_NM,
				'90'				AS STATE_CD								
			FROM dbo.hr_master AS HM WITH (NOLOCK)
				LEFT JOIN dbo.VW_NPD_hreMaster AS OHM WITH (NOLOCK)
				ON HM.EMP_ID = OHM.EMP_ID
			WHERE OHM.EMP_ID IS NULL
			UNION
			SELECT
				OHM.EMP_ID,
				OHM.[NAME],
				OHM.MOIN_ID,
				OHM.MOIN_EMAIL,
				OHM.DEPT_CODE,
				OHM.JOB_CODE,
				OHM.JOB_GRADE_NM,
				OHM.JOB_DUTY,
				OHM.JOB_DUTY_NM,
				'10'				AS STATE_CD		
			FROM dbo.VW_NPD_hreMaster AS OHM WITH (NOLOCK)
				
			TRUNCATE TABLE dbo.hr_master;

			INSERT INTO dbo.hr_master
			SELECT 
				TH.EMP_ID,
				TH.[NAME],				
				TH.MOIN_ID,			
				TH.MOIN_EMAIL,
				TH.DEPT_CODE,
				TH.JOB_CODE,		
				TH.JOB_GRADE_NM,
				TH.JOB_DUTY,
				TH.JOB_DUTY_NM,
				TH.STATE_CD,
				'system'	AS creator_id,
				GETDATE()	AS created_at
			FROM @target_hrm AS TH
			ORDER BY TH.EMP_ID ASC;

		COMMIT TRAN;

		SET @vSeverity = 0;
		SET @result_cd = 0;
		SET @result_msg = '성공';

	END TRY

	BEGIN CATCH
		IF @@TRANCOUNT > 0
			ROLLBACK TRAN;

		SET @result_cd = -1;
		SET @result_msg = ERROR_MESSAGE();
		SET @vSeverity = ERROR_SEVERITY();
	END CATCH

	DECLARE @log_param VARCHAR(MAX);

	SET @log_param = NULL;
				   

	INSERT INTO dbo.use_log (caller_id, severity, project_id, log_dt, log_message, proc_name, proc_param, result_cd, result_msg, created_at)
	VALUES(ISNULL(CAST('system' AS VARCHAR(8)), 'UNKNOWN'), @vSeverity, ISNULL(NULL, 0), CONVERT(CHAR(10), GETDATE(), 120), '회원 정보 동기화', '[TransferHreMaster]', @log_param, NULL, @result_msg, GETDATE());


	RETURN;
END


--- Procedure 4 ---
ProcedureName: spInsertProjectMemberByTemplate
ProcedureDefinition:
-- =============================================
-- Author:		JayKwon
-- Create date: 2025-05-23
-- Description:	담당자 일괄 인서트
-- SAMPLE EXECUTION
/*
DECLARE @tvp dbo.project_applicant_template,@result_cd INT, @result_msg VARCHAR(100);
INSERT INTO @tvp(
					project_id,
					member_id,
					creator_id)
VALUES
(2, '2400000',             '2400000'),
(2, '2400001',             '2400000'),
(2, '2400002',             '2400000'),
(2, '2400003',             '2400000'),
(2, '2400004',             '2400000'),
(2, '2400005',             '2400000'),
(2, '2400006',             '2400000'),
(2, '2400007',             '2400000'),
(2, '2400008',             '2400000'),
(2, '2400009',             '2400000')

exec [dbo].[spInsertProjectMemberByTemplate] @task_template = @tvp , @result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT;;
SELECT @result_cd as result_cd, @result_msg as result_msg;

-- =============================================
*/
CREATE PROCEDURE [dbo].[spInsertProjectMemberByTemplate]
	@task_template dbo.project_applicant_template READONLY,
    @result_cd			INT OUTPUT,
    @result_msg			VARCHAR(200) OUTPUT
AS
BEGIN
	
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	BEGIN TRY
		BEGIN TRAN

		INSERT INTO dbo.project_member(
			project_id,
			member_id,
			status_cd,
			creator_id,
			created_at,
			modifier_id,
			modified_at)
		SELECT
			TT.project_id	AS project_id,
			TT.member_id	AS member_id,
			'10'			AS status_cd,	-- 90102 10:승인, 20:신청, 90:반려
			TT.creator_id	AS creator_id,
			GETDATE()		AS created_at,
			null			AS modifier_id,
			null			AS modified_at
		FROM @task_template AS TT
			LEFT JOIN project_member AS PM WITH (NOLOCK)
			ON TT.project_id = PM.project_id
			AND TT.member_id = PM.member_id
		WHERE PM.member_id IS NULL			-- 신청한 기록이 있는 사람이 있으면 제외하고 꼽아준다.

		COMMIT TRAN

		SET @result_cd = 0;
		SET @result_msg = '성공';

	END TRY
	BEGIN CATCH
		ROLLBACK TRAN

		SET @result_cd = -1;
		SET @result_msg = ERROR_MESSAGE();
	END CATCH

END


--- Procedure 5 ---
ProcedureName: spInsertProjectTaskTemplate
ProcedureDefinition:
-- =============================================
-- Author:		JayKwon
-- Create date: 2025-05-22
-- Description:	템플릿 태스크 인서트
-- SAMPLE EXECUTION
/*
mst (90301, 태스크관계) : 10 하위, 20 후행, 30 개별

DECLARE @tvp dbo.task_template, @result_cd INT, @result_msg VARCHAR(100);

INSERT INTO @tvp(
                                        task_name,
                                        project_id,
                                        dependency_order_no,
                                        dependency_cd,
                                        order_no,
                                        std_working_day,
                                        status_cd,
                                        is_active_cd,
                                        is_output_need,
                                        creator_id,
                                        modifier_id)
VALUES
--  task_name           pjt_id      dep_id			  dep_cd      ord        work_d        stt_cd        act         output       cre			modi
('도입보고',			'3',        null,			  null,        1,        5,            '10',        '10',        '10',        '2400000',	null),
('상세페이지제작',		'3',        1,                '10',        2,        3,            '10',        '10',        '10',        '2400000',	null),
('표시사항',			'3',        1,                '20',        3,        7,            '10',        '10',        '10',        '2400000',	null),
('선행원자재발주',		'3',        3,                '10',        4,        5,            '10',        '10',        '10',        '2400000',	null),
('표시문안',			'3',        3,                '20',        5,        5,            '10',        '10',        '10',        '2400000',	null),
('디자인확정',			'3',        5,                '20',        6,        10,           '10',        '10',        '10',        '2400000',	null),
('체인등록',			'3',        6,                '10',        7,        5,            '10',        '10',        '10',        '2400000',	null),
('영업프로모션',		'3',        6,                '10',        8,        5,            '10',        '10',        '10',        '2400000',	null),
('원부자제발주+입고',	'3',        6,                '20',        9,        12,           '10',        '10',        '10',        '2400000',	null),
('원자재발주',			'3',        9,                '10',        10,       5,            '10',        '10',        '10',        '2400000',	null),
('포장재발주',			'3',        10,               '20',        11,       5,            '10',        '10',        '10',        '2400000',	null),
('BOX데이터출고',		'3',        11,               '20',        12,       5,            '10',        '10',        '10',        '2400000',	null);

exec [dbo].[spInsertProjectTaskTemplate] @task_template = @tvp , @result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT;
SELECT @result_cd as result_cd, @result_msg as result_msg;

-- =============================================
*/
CREATE PROCEDURE [dbo].[spInsertProjectTaskTemplate]
	@task_template dbo.task_template READONLY,
    @result_cd			INT OUTPUT,
    @result_msg			VARCHAR(200) OUTPUT
AS
BEGIN
	
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
	
		
	DECLARE @creator_id			VARCHAR(7) = NULL;
	DECLARE @project_id			INT = NULL;
	DECLARE @project_type_cd	VARCHAR(8) = NULL;
	DECLARE @vSeverity			INT = NULL;

	SELECT
		@creator_id = MAX(creator_id),
		@project_id = MAX(project_id)
	FROM @task_template

	SELECT
		@project_type_cd = project_type_cd
	FROM project AS P WITH (NOLOCK)
	WHERE P.project_id = @project_id


	-- 없는 프로젝트에 대해 요청하면 오류 처리
	IF NOT EXISTS(SELECT 1 FROM dbo.project AS P WITH (NOLOCK) WHERE P.project_id = @project_id)
	BEGIN		
		RAISERROR('존재하지 않는 프로젝트 입니다.', 11, 1);			
	END

	-- 요청은 한개의 프로젝트 아이디에 대해서만 처리 할 수 있다.
	IF (SELECT COUNT(DISTINCT T.project_id) FROM @task_template AS T) > 1
	BEGIN
		RAISERROR('한개의 프로젝트 아이디에 대해서만 처리 가능 합니다.', 11, 1);			
	END


	BEGIN TRY
		BEGIN TRAN

		INSERT INTO dbo.task(		
			task_name,
			project_id,
			order_no,
			status_cd,
			is_active_cd,
			is_output_need,
			creator_id,
			created_at,
			modifier_id,
			modified_at)
		SELECT
			TVP.task_name,
			TVP.project_id,
			TVP.order_no,
			TVP.status_cd,
			TVP.is_active_cd,
			TVP.is_output_need,
			TVP.creator_id,
			GETDATE() AS created_at,
			TVP.modifier_id,
			null AS modified_at
		FROM @task_template AS TVP
		ORDER BY TVP.order_no ASC;

		INSERT INTO dbo.task_dependency(
			task_id,
			project_id,
			dependency_id,
			dependency_cd,
			creator_id,
			created_at,
			modifier_id,
			modified_at
			)
		SELECT
			M.task_id			AS task_id,
			M.project_id		AS project_id,
			TK.task_id			AS dependency_id,
			M.dependency_cd		AS dependency_cd,
			M.creator_id		AS creator_id,
			GETDATE()			AS created_at,
			null				AS modifier_id,
			null				AS modified_at
		FROM (  SELECT
					T.task_id,
					A.project_id,
					A.dependency_order_no,
					A.dependency_cd,
					A.creator_id
				FROM @task_template AS A
					INNER JOIN dbo.task AS T WITH (NOLOCK)
					ON A.order_no = T.order_no
					AND A.project_id = T.project_id
				WHERE A.dependency_order_no IS NOT NULL ) M
			INNER JOIN dbo.task AS TK WITH (NOLOCK)
			ON M.dependency_order_no = TK.order_no
			AND M.project_id = TK.project_id;

		-- 태스크 피니시 플랜 생성

		DECLARE @min_order_no	INT = null;
	
		-- 1번 TASK 찾기
		SELECT
			@min_order_no = MIN(T.order_no)
		FROM task AS T
		WHERE T.project_id = (SELECT MAX(project_id) from @task_template)

		--   plan_cd           varchar(8) // master ref : 10 표준, 20 계획, 30 실제, 40 지연
		DECLARE @task_finish_plan TABLE (
			project_id        INT NOT NULL,
			task_id           INT NOT NULL,
			plan_cd           VARCHAR(8),
			start_dt          VARCHAR(10),
			end_dt            VARCHAR(10),
			working_day       INT,
			delay_reason      VARCHAR(200),
			processed		  INT
		);

		INSERT INTO @task_finish_plan(	
			project_id,
			task_id,
			plan_cd,
			start_dt,
			end_dt,
			working_day,
			delay_reason,
			processed
		)
		SELECT
			P.project_id			AS project_id,
			T.task_id				AS task_id,
			'10'					AS plan_cd,
			P.planed_start_dt		AS start_dt,
			dbo.fnGetWorkingDateAdd(P.planed_start_dt, TT.std_working_day) AS end_dt,
			TT.std_working_day		AS working_day,
			null					AS delay_reason,
			0						AS processed
		FROM task AS T
			INNER JOIN project AS P
			ON T.project_id = P.project_id
			INNER JOIN @task_template AS TT
			ON T.task_name = TT.task_name
			AND T.order_no = TT.order_no
			AND T.project_id = TT.project_id
		WHERE T.order_no = @min_order_no

		DECLARE @task_id	INT = null;
		DECLARE @start_dt   VARCHAR(10);
		DECLARE @end_dt		VARCHAR(10);


		WHILE EXISTS(SELECT 1 FROM @task_finish_plan WHERE processed = 0)
		BEGIN
	
			SELECT
				TOP 1 
				@task_id = TFP.task_id,
				@start_dt = TFP.start_dt,
				@end_dt = end_dt
			FROM @task_finish_plan AS TFP
			WHERE TFP.processed = 0;
	
			-- 처리할 태스크 아이디 뽑고
			-- 그 아이디를 선행으로 보는 태스크들 처리
			INSERT INTO @task_finish_plan(	
				project_id,
				task_id,
				plan_cd,
				start_dt,
				end_dt,
				working_day,
				delay_reason,
				processed
			)
			SELECT 
				T.project_id,
				T.task_id,
				'10'					AS plan_cd,
				CASE WHEN TD.dependency_cd = '10' THEN @start_dt
					 WHEN TD.dependency_cd = '20' THEN @end_dt
					 ELSE NULL
				END AS start_dt,
				CASE WHEN TD.dependency_cd = '10' THEN @end_dt
					 WHEN TD.dependency_cd = '20' THEN dbo.fnGetWorkingDateAdd(@end_dt, TT.std_working_day)
					 ELSE NULL
				END AS end_dt,
				TT.std_working_day,
				null AS delay_reason,
				0 AS processed
			FROM task_dependency AS TD WITH (NOLOCK)
				INNER JOIN task AS T WITH (NOLOCK)
				ON TD.task_id = T.task_id
				INNER JOIN @task_template AS TT
				ON T.project_id = TT.project_id
				AND T.order_no = TT.order_no
			WHERE TD.dependency_id = @task_id;

			--태스크 관계	10	하위
			--태스크 관계	20	후행

			UPDATE @task_finish_plan SET
				processed = 1
			WHERE task_id = @task_id
	
		END


		INSERT INTO dbo.task_finish_plan (		
			project_id,
			task_id,
			plan_cd,
			start_dt,
			end_dt,
			working_day,
			delay_reason,
			creator_id,
			created_at,
			modifier_id,
			modified_at
		)
		SELECT
			B.project_id,
			B.task_id,
			'10' AS plan_cd,
			CASE WHEN @project_type_cd = '90' THEN NULL ELSE A.start_dt END,	-- 템플릿은 표준 시작일자를 넣지 않아도 된다.
			CASE WHEN @project_type_cd = '90' THEN NULL ELSE A.end_dt END,		-- 템플릿은 표준 종료일자를 넣지 않아도 된다.	
			A.working_day,
			null AS delay_reason,
			@creator_id,
			GETDATE(),
			null,
			null
		FROM @task_finish_plan AS A 
			INNER JOIN task AS B
			ON A.project_id = B.project_id
			AND A.task_id = B.task_id

	
		COMMIT TRAN

		-- 성공 메시지
		SET @vSeverity = 0;
		SET @result_cd = 0;
		SET @result_msg = '성공';

	END TRY
	
	BEGIN CATCH
		IF @@TRANCOUNT > 0
			ROLLBACK TRAN;

		-- 실패
		SET @result_cd = -1;
		SET @vSeverity = ERROR_SEVERITY();
		SET @result_msg = ERROR_MESSAGE();

	END CATCH

	DECLARE @tvp_json VARCHAR(MAX);
	DECLARE @log_param VARCHAR(MAX);

	SELECT @tvp_json = (
		SELECT * FROM @task_template FOR JSON AUTO
	);
	SET @log_param = ISNULL(@tvp_json, '[]');

	INSERT INTO dbo.use_log (caller_id, severity, project_id, log_dt, log_message, proc_name, proc_param, result_cd, result_msg, created_at)
	VALUES(ISNULL(CAST(@creator_id AS VARCHAR(8)), 'UNKNOWN'), @vSeverity, ISNULL(@project_id, 0), CONVERT(CHAR(10), GETDATE(), 120), '태스크 일괄 생성.', '[spInsertProjectTaskTemplate]', @log_param, @result_cd, @result_msg, GETDATE());

	RETURN;
END




--- Procedure 6 ---
ProcedureName: spUpdateDateByShifting
ProcedureDefinition:
-- =============================================
-- Author:		Jay Kwon
-- Create date: 2025-08-06
-- Description:	일정 변경이 발생 됫을때, 일자 보정을 한다.
/* 실행예제
DECLARE @result_cd INT, @result_msg VARCHAR(100);
EXEC [dbo].[spUpdateDateByShifting] @pProject_id = 25080062, @pTask_id = NULL, @pPlan_cd = '20' , @result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT;
SELECT @result_cd as result_cd, @result_msg as result_msg;
*/
-- =============================================
CREATE PROCEDURE [dbo].[spUpdateDateByShifting]
	@pProject_id		INT = NULL,
	@pTask_id			INT = NULL,
	@pPlan_cd			VARCHAR(7) = NULL,
    @result_cd			INT				OUTPUT,
    @result_msg			VARCHAR(200)	OUTPUT
AS
BEGIN
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	DECLARE @vSeverity				INT = NULL;

	DECLARE @vProcess_task_id	INT = NULL;
	DECLARE @vParent_task_id	INT = NULL;
	DECLARE @vStart_dt			VARCHAR(10) = NULL;
	DECLARE @vEnd_dt			VARCHAR(10) = NULL;

	DECLARE @vNext_task_id INT = NULL;
	DECLARE @vNext_end_dt VARCHAR(10) = NULL;

	-- 특정 테스크에 대한 변경이 아니면 전체 보정
	IF (@pTask_id IS NULL)
	BEGIN
		SELECT @vProcess_task_id = dbo.fnGetTopTaskId(@pProject_id);
	END
	ELSE
	BEGIN
		SELECT
			@vParent_task_id = TD.dependency_id
		FROM dbo.task_dependency AS TD WITH (NOLOCK)
		WHERE TD.dependency_cd = '10'
		AND TD.task_id = @pTask_id

		IF (@vParent_task_id IS NOT NULL)
		BEGIN
			SET @vProcess_task_id = @vParent_task_id;
		END
		ELSE
		BEGIN
			SET @vProcess_task_id = @pTask_id;
		END
	END

    BEGIN TRY


		--IF (condition)
		--BEGIN
		--	RAISERROR('error message', 16, 1);
		--END

		BEGIN TRAN;


		SELECT
			@vStart_dt = TFP.start_dt,
			@vEnd_dt = dbo.fnGetWorkingDateAdd(TFP.start_dt, TFP.working_day)
		FROM dbo.task_finish_plan AS TFP WITH (NOLOCK)
		WHERE TFP.task_id = @vProcess_task_id
		AND TFP.plan_cd = @pPlan_cd

		WHILE (@vProcess_task_id IS NOT NULL)
		BEGIN	

			-- 2뎁스 업데이트 처리
			UPDATE TFP SET
				TFP.start_dt = @vStart_dt, -- 하위의 시작일은 부모와 동일하게 처리
				TFP.end_dt = dbo.fnGetWorkingDateAdd(@vStart_dt, TFP.working_day),
				TFP.modifier_id = 'system',
				TFP.modified_at = GETDATE()
			FROM dbo.task_finish_plan AS TFP WITH (NOLOCK)
				INNER JOIN dbo.task_dependency AS TD WITH (NOLOCK)
				ON TFP.task_id = TD.task_id
			WHERE TD.dependency_cd = '10'
			AND TD.dependency_id = @vProcess_task_id;

			-- 1뎁스(자신) 업데이트 처리
			UPDATE TFP SET
				TFP.start_dt = @vStart_dt,
				TFP.end_dt = @vEnd_dt,
				TFP.modifier_id = 'system',
				TFP.modified_at = GETDATE()
			FROM dbo.task_finish_plan AS TFP WITH (NOLOCK)
				INNER JOIN dbo.task AS T WITH (NOLOCK)
				ON TFP.task_id = TFP.task_id
			WHERE TFP.task_id = @vProcess_task_id
			AND TFP.plan_cd = @pPlan_cd
			AND T.is_active_cd = '10';




			SET @vNext_task_id = NULL;
			SET @vNext_end_dt = NULL;
			SET @vStart_dt = dbo.fnGetWorkingDateAdd(@vEnd_dt,2);	
	
	
			-- 다음 처리 태스크 셋업
			SELECT		
				@vNext_task_id = TD.task_id,
				@vNext_end_dt = dbo.fnGetWorkingDateAdd(@vStart_dt, TFP.working_day)
			FROM dbo.task_dependency AS TD WITH (NOLOCK)
				INNER JOIN dbo.task_finish_plan AS TFP WITH (NOLOCK)
				ON TD.task_id = TFP.task_id
			WHERE TD.dependency_cd = '20'
			AND TD.dependency_id = @vProcess_task_id
			AND TFP.plan_cd = @pPlan_cd;

			-- 실제 처리 변수로 교체
			SET @vProcess_task_id = @vNext_task_id;
			SET @vEnd_dt = @vNext_end_dt;
		END

		COMMIT TRAN;

		SET @vSeverity = 0;
		SET @result_cd = 0;
		SET @result_msg = '성공';

	END TRY

	BEGIN CATCH
		IF @@TRANCOUNT > 0
			ROLLBACK TRAN;

		SET @result_cd = -1;
		SET @result_msg = ERROR_MESSAGE();
		SET @vSeverity = ERROR_SEVERITY();
	END CATCH

	DECLARE @log_param VARCHAR(MAX);

	SET @log_param = '@pProject_id = ' + ISNULL(CAST(@pProject_id AS VARCHAR), 'NULL') + ', '
				   + '@pPlan_cd = ' + ISNULL(@pPlan_cd, 'NULL') + ', ';
				   

	INSERT INTO dbo.use_log (caller_id, severity, project_id, log_dt, log_message, proc_name, proc_param, result_cd, result_msg, created_at)
	VALUES(ISNULL(CAST('system' AS VARCHAR(8)), 'UNKNOWN'), @vSeverity, ISNULL(NULL, 0), CONVERT(CHAR(10), GETDATE(), 120), '일정 보정 처리', '[spUpdateDateByShifting]', @log_param, @result_cd, @result_msg, GETDATE());


	RETURN;
END


--- Procedure 7 ---
ProcedureName: spGetMemberId
ProcedureDefinition:

-- =============================================
-- Author:		jaykwon
-- Create date: 2025-06-27
-- Description:	로그인 시 MOIN_ID를 던지면 member_id를 리턴한다. (+ 로깅)
/*
DECLARE @result_cd INT, @result_msg VARCHAR(100);
EXEC [dbo].[spGetMemberId] @pMOIN_ID = 'jaykwon5156', @result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT;
SELECT @result_cd as result_cd, @result_msg as result_msg;
*/
-- =============================================
CREATE PROCEDURE [dbo].[spGetMemberId]
	@pMOIN_ID		VARCHAR(50)		= NULL,
	@result_cd		INT				OUTPUT,
    @result_msg		VARCHAR(200)	OUTPUT
AS
BEGIN
	
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
	
	DECLARE @vMember_id			VARCHAR(8) = NULL;
	DECLARE @vDept_auth_cd		VARCHAR(8) = NULL;
	DECLARE @vDept_auth_name	VARCHAR(50) = NULL;

	BEGIN TRY
		SELECT
			@vMember_id = VHR.EMP_ID,
			@vDept_auth_cd = ISNULL(DA.dept_auth_cd,'90'),
			@vDept_auth_name = dbo.fnGetDetailNameByDetailCode('90000',ISNULL(DA.dept_auth_cd,'90'))
		FROM dbo.hr_master AS VHR WITH (NOLOCK)
			LEFT JOIN dbo.dept_auth AS DA WITH (NOLOCK)
			ON VHR.DEPT_CODE = DA.dept_cd
		WHERE VHR.MOIN_ID = @pMOIN_ID;

		IF (@vMember_id IS NULL)
		BEGIN			
			RAISERROR('존재하지 않는 회원 입니다.', 11, 1);			
		END

		SELECT @vMember_id			AS member_id, @vDept_auth_cd		AS dept_auth_cd, @vDept_auth_name	AS dept_auth_name;
		
		SET @result_cd = 0;
		SET @result_msg = '성공';
	END TRY
	BEGIN CATCH
		SET @result_cd = -1;
		SET @result_msg = ERROR_MESSAGE();
	END CATCH

	RETURN;
END


--- Procedure 8 ---
ProcedureName: spBatchUseLogCleansing
ProcedureDefinition:
-- =============================================
-- Author:		Jay Kwon
-- Create date: 2025-08-07
-- Description:	use_log 삭제 처리
/* 실행예제
DECLARE @result_cd INT, @result_msg VARCHAR(100);
EXEC [dbo].[spBatchUseLogCleansing] @pPeriod_day = 2 , @result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT;
SELECT @result_cd as result_cd, @result_msg as result_msg;
*/
-- =============================================
CREATE PROCEDURE [dbo].[spBatchUseLogCleansing]
	@pPeriod_day		INT = NULL,	-- 데이터 유지 기간(일)
    @result_cd			INT				OUTPUT,
    @result_msg			VARCHAR(200)	OUTPUT
AS
BEGIN
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	DECLARE @vSeverity				INT = NULL;
	DECLARE @vMin_dt				VARCHAR(10) = NULL;
	DECLARE @vRow_cnt				INT = 1;
	DECLARE @vBatch_size			INT = 10000; -- 10000개 씩 삭제
	DECLARE @vProcessed_Rows		INT = 0;

    BEGIN TRY
		IF (@pPeriod_day IS NULL)
		BEGIN
			RAISERROR('데이터 보관 기간은 필수 값 입니다.', 16, 1);
		END
					
		SET @vMin_dt = CONVERT(VARCHAR(10), DATEADD(d, @pPeriod_day * -1, GETDATE()), 121)
		
		-- 로그 삭제는 트랜잭션 컨트롤 없이 한다
		
		WHILE (@vRow_cnt > 0)
		BEGIN
			DELETE TOP (@vBatch_size)
			FROM dbo.use_log
			WHERE log_dt < @vMin_dt;

			SET @vRow_cnt = @@ROWCOUNT;
			SET @vProcessed_Rows += @vRow_cnt;

			WAITFOR DELAY '00:00:01'; -- 부하를 완화 하기 위해 1초 쉬고 시행

		END


		SET @vSeverity = 0;
		SET @result_cd = 0;
		SET @result_msg = '성공';

	END TRY

	BEGIN CATCH
		SET @result_cd = -1;
		SET @result_msg = ERROR_MESSAGE();
		SET @vSeverity = ERROR_SEVERITY();
	END CATCH

	DECLARE @log_param VARCHAR(MAX);

	SET @log_param = '@pPeriod_day = ' + ISNULL(CAST(@pPeriod_day AS VARCHAR), 'NULL');
				   

	INSERT INTO dbo.use_log (caller_id, severity, project_id, log_dt, log_message, proc_name, proc_param, result_cd, result_msg, created_at)
	VALUES(ISNULL(CAST('system' AS VARCHAR(8)), 'UNKNOWN'), @vSeverity, ISNULL(NULL, 0), CONVERT(CHAR(10), GETDATE(), 120), CAST(@vProcessed_Rows AS VARCHAR) + '건 use_log 삭제', '[spBatchUseLogCleansing]', @log_param, @result_cd, @result_msg, GETDATE());


	RETURN;
END


--- Procedure 9 ---
ProcedureName: spGetHolidayInfo
ProcedureDefinition:
-- =============================================
-- Author:		Jay Kwon
-- Create date: 2025-08-07
-- Description:	휴일 정보를 가져온다.
/* 실행예제
DECLARE @result_cd INT, @result_msg VARCHAR(100);
EXEC [dbo].[spGetHolidayInfo] @pYear = 2025,  @pMonth = 8 , @result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT;
SELECT @result_cd as result_cd, @result_msg as result_msg;
*/
-- =============================================
CREATE PROCEDURE [dbo].[spGetHolidayInfo]
	@pYear				INT = NULL,
	@pMonth				INT = NULL,
    @result_cd			INT				OUTPUT,
    @result_msg			VARCHAR(200)	OUTPUT
AS
BEGIN
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	DECLARE @vSeverity		INT = NULL;
	DECLARE @vTargetYear	INT = NULL;

	DECLARE @vStartDate		VARCHAR(10) = NULL;
	DECLARE @vEndDate		VARCHAR(10) = NULL;

	DECLARE @vMin_dt		VARCHAR(10) = NULL;
	DECLARE @vMax_dt		VARCHAR(10) = NULL;

    BEGIN TRY
		
		SELECT
			@vMin_dt = MIN(C.target_dt),
			@vMax_dt = MAX(C.target_dt)
		FROM dbo.calendar AS C WITH (NOLOCK)

		IF @pMonth IS NULL OR @pMonth < 1 OR @pMonth > 12
		BEGIN
			RAISERROR('요청 월(@pMonth)은 1~12 사이의 값이어야 합니다.', 16, 1);
		END

		IF (@pYear IS NULL OR @pMonth IS NULL)
		BEGIN
			RAISERROR('요청 년/월은 필수 파라미터 입니다.', 16, 1);
		END

		-- @pYear가 NULL이면 현재 연도로 대체
		SET @vTargetYear = ISNULL(@pYear, YEAR(GETDATE()));

		SET @vStartDate = CONVERT(VARCHAR(10), DATEFROMPARTS(@vTargetYear, @pMonth, 1), 121);
		SET @vEndDate = CONVERT(VARCHAR(10), DATEADD(DAY, -1, DATEADD(MONTH, 1, DATEFROMPARTS(@vTargetYear, @pMonth, 1))), 121);

		IF (@vStartDate < @vMin_dt OR @vEndDate > @vMax_dt)
		BEGIN
			RAISERROR('조회 가능한 범위를 벗어났습니다. 추가적으로 캘린더 데이터를 등록 해야 합니다.', 16, 1);
		END

		SELECT
			C.target_dt,
			C.date_description
		FROM dbo.calendar AS C WITH (NOLOCK)
		WHERE C.target_dt BETWEEN @vStartDate AND @vEndDate
		AND C.date_description IS NOT NULL;

		SET @vSeverity = 0;
		SET @result_cd = 0;
		SET @result_msg = '성공';

	END TRY

	BEGIN CATCH

		SET @result_cd = -1;
		SET @result_msg = ERROR_MESSAGE();
		SET @vSeverity = ERROR_SEVERITY();
	END CATCH

	RETURN;
END


--- Procedure 10 ---
ProcedureName: spGetDeptHierarchy
ProcedureDefinition:

-- =============================================
-- Author:		JayKwon
-- Create date: 2025-07-01
-- Description:	조직도 조회
/*
-- 전체 조회
DECLARE @result_project_id INT, @result_cd INT, @result_msg VARCHAR(100);
EXEC [dbo].[spGetDeptHierarchy] @pDept_name = NULL, @pDept_cd = NULL, @result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT;
SELECT @result_cd as result_cd, @result_msg as result_msg;

-- 특정 부서 조회
DECLARE @result_project_id INT, @result_cd INT, @result_msg VARCHAR(100);
EXEC [dbo].[spGetDeptHierarchy] @pDept_name = '푸드사업부', @pDept_cd = NULL, @result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT;
SELECT @result_cd as result_cd, @result_msg as result_msg;
*/
-- =============================================
CREATE PROCEDURE [dbo].[spGetDeptHierarchy]
	@pDept_name	    VARCHAR(100)	= NULL,
	@pDept_cd		VARCHAR(8)		= NULL,
    @result_cd		INT				OUTPUT,
    @result_msg		VARCHAR(200)	OUTPUT
AS
BEGIN
	
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

    DECLARE @vDept_cd   VARCHAR(8) = NULL;

    IF (@pDept_name IS NOT NULL)
    BEGIN
        SELECT TOP 1 @vDept_cd = DM.DEPT_CODE
        FROM  dbo.dept_master AS DM WITH (NOLOCK)
        WHERE DM.DEPT_NAME LIKE '%' + @pDept_name + '%'
    END;

    IF (@pDept_cd IS NOT NULL)
    BEGIN
        SET @vDept_cd = @pDept_cd;
    END;

    WITH OrgHierarchy AS (
        -- 루트 조건: 조건 없을 때만 루트에서 시작
        SELECT 
            DEPT_CODE,
            DEPT_NAME,
            PARENT_DEPT_CODE
        FROM dbo.dept_master AS DM WITH (NOLOCK)
        WHERE 
            (@vDept_cd IS NULL AND (ISNULL(PARENT_DEPT_CODE, '') = '' OR PARENT_DEPT_CODE = 'NULL'))
            OR (DM.DEPT_CODE = @vDept_cd)

        UNION ALL
        
        -- 하위 조직 재귀 탐색
        SELECT 
            D.DEPT_CODE,
            D.DEPT_NAME,
            D.PARENT_DEPT_CODE
        FROM dbo.dept_master AS D
            INNER JOIN OrgHierarchy OH
            ON D.PARENT_DEPT_CODE = OH.DEPT_CODE
    )

    SELECT
        D.DEPT_CODE,
        D.DEPT_NAME,
        D.PARENT_DEPT_CODE
    FROM OrgHierarchy AS D
    ORDER BY DEPT_CODE;


	SET @result_cd = 0;
	SET @result_msg = '성공';   
END


--- Procedure 11 ---
ProcedureName: spGetDeptMember
ProcedureDefinition:


-- =============================================
-- Author:		JayKwon
-- Create date: 2025-07-01
-- Description:	조직에 속한 인원 조회
/*
DECLARE @result_project_id INT, @result_cd INT, @result_msg VARCHAR(100);
EXEC [dbo].[spGetDeptMember] @pDept_cd = '13010101', @result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT;
SELECT @result_cd as result_cd, @result_msg as result_msg;
*/
-- =============================================
CREATE PROCEDURE [dbo].[spGetDeptMember]
	@pDept_cd		VARCHAR(8)		= NULL,
    @result_cd		INT				OUTPUT,
    @result_msg		VARCHAR(200)	OUTPUT
AS
BEGIN
	
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
	
	IF (@pDept_cd IS NULL)
	BEGIN
		SET @result_cd = 1;
		SET @result_msg = '조회 정보가 누락되었습니다.';  
		RETURN;
	END
	
	IF NOT EXISTS(SELECT 1 FROM dbo.dept_master AS ODM WITH (NOLOCK) WHERE ODM.DEPT_CODE = @pDept_cd)
	BEGIN
		SET @result_cd = 1;
		SET @result_msg = '존재하지 않는 부서코드 입니다.';  
		RETURN;
	END

	IF (@pDept_cd IS NULL)
	BEGIN
		SELECT
			HRM.EMP_ID,
			HRM.[NAME],
			HRM.MOIN_ID,
			HRM.MOIN_EMAIL,
			HRM.JOB_CODE,
			HRM.JOB_GRADE_NM,
			HRM.DEPT_CODE,
			DM.DEPT_NAME
		FROM dbo.hr_master AS HRM WITH (NOLOCK)
			INNER JOIN dbo.dept_master AS DM WITH (NOLOCK)
			ON HRM.DEPT_CODE = DM.DEPT_CODE
	END
	ELSE
	BEGIN
		SELECT
			HRM.EMP_ID,
			HRM.[NAME],
			HRM.MOIN_ID,
			HRM.MOIN_EMAIL,
			HRM.JOB_CODE,
			HRM.JOB_GRADE_NM,
			HRM.DEPT_CODE,
			DM.DEPT_NAME
		FROM dbo.hr_master AS HRM WITH (NOLOCK)
			INNER JOIN dbo.dept_master AS DM WITH (NOLOCK)
			ON HRM.DEPT_CODE = DM.DEPT_CODE
		WHERE HRM.DEPT_CODE = @pDept_cd
	END

	SET @result_cd = 0;
	SET @result_msg = '성공';   
	RETURN;
END


--- Procedure 12 ---
ProcedureName: spGetCodeMasterForLine
ProcedureDefinition:
-- =============================================
-- Author:		Jay Kwon
-- Create date: 2025-08-11
-- Description:	라인코드 검색
/*

DECLARE @result_cd INT, @result_msg VARCHAR(100), @total_count INT, @total_pages INT;
EXEC [dbo].[spGetCodeMasterForLine] @pPage_no = 1, @pPage_size= 20, @result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT, @total_count = @total_count OUTPUT, @total_pages = @total_pages OUTPUT;
SELECT @result_cd AS result_cd, @result_msg AS result_msg, @total_count AS total_count, @total_pages AS total_pages;

*/

-- =============================================
CREATE PROCEDURE [dbo].[spGetCodeMasterForLine]
	@pGroup_cd			VARCHAR(8)		= NULL,
	@pPage_no			INT				= NULL,
	@pPage_size			INT				= NULL,
    @result_cd			INT				OUTPUT,
    @result_msg			VARCHAR(200)	OUTPUT,
	@total_count		INT				OUTPUT,
	@total_pages		INT				OUTPUT
AS
BEGIN
	
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	BEGIN TRY
	
		IF (@pGroup_cd IS NULL)
		BEGIN
			-- 전체 레코드 수 계산
			SELECT @total_count = COUNT(*)
			FROM dbo.code_master AS CM WITH (NOLOCK)
			WHERE CM.group_cd IN ('20001', '20002')
			AND CM.is_active_cd = '10'
			AND CM.group_cd < '90000';

			-- 전체 페이지 수 계산
			SET @total_pages = CASE 
				WHEN @pPage_size IS NULL OR @pPage_size = 0 THEN 1
				ELSE CEILING(CAST(@total_count AS FLOAT) / @pPage_size)
			END;

			SELECT
				CM.master_id,
				CM.group_cd,
				CM.group_name,
				CM.detail_cd,
				CM.detail_name,
				CM.is_active_cd,
				dbo.fnGetDetailNameByDetailCode('90100', CM.is_active_cd) AS is_active_name,			
				CM.creator_id,
				CM.created_at,
				CM.modifier_id,
				CM.modified_at
			FROM dbo.code_master AS CM WITH (NOLOCK)
			WHERE CM.group_cd IN ('20001', '20002')
			AND CM.is_active_cd = '10'
			ORDER BY group_cd, detail_cd
			OFFSET (@pPage_no - 1) * @pPage_size ROWS
			FETCH NEXT @pPage_size ROWS ONLY;	
		END
		ELSE
		BEGIN
			-- 전체 레코드 수 계산
			SELECT @total_count = COUNT(*)
			FROM dbo.code_master AS CM WITH (NOLOCK)
			WHERE CM.group_cd = @pGroup_cd
			AND CM.is_active_cd = '10'
			AND CM.group_cd < '90000';

			-- 전체 페이지 수 계산
			SET @total_pages = CASE 
				WHEN @pPage_size IS NULL OR @pPage_size = 0 THEN 1
				ELSE CEILING(CAST(@total_count AS FLOAT) / @pPage_size)
			END;

			SELECT
				CM.master_id,
				CM.group_cd,
				CM.group_name,
				CM.detail_cd,
				CM.detail_name,
				CM.is_active_cd,
				dbo.fnGetDetailNameByDetailCode('90100', CM.is_active_cd) AS is_active_name,			
				CM.creator_id,
				CM.created_at,
				CM.modifier_id,
				CM.modified_at
			FROM dbo.code_master AS CM WITH (NOLOCK)
			WHERE CM.group_cd = @pGroup_cd
			AND CM.is_active_cd = '10'
			ORDER BY group_cd, detail_cd
			OFFSET (@pPage_no - 1) * @pPage_size ROWS
			FETCH NEXT @pPage_size ROWS ONLY;	
		END

		SET @result_cd = 0
		SET @result_msg = '성공'

	END TRY
	BEGIN CATCH
		SET @result_cd = -1;
		SET @result_msg = ERROR_MESSAGE();
		SET @total_count = 0;
		SET @total_pages = 0;
	END CATCH
	
END


--- Procedure 13 ---
ProcedureName: spDeleteOutputForTask
ProcedureDefinition:
-- =============================================
-- Author:		Jay Kwon
-- Create date: 2025-08-12
-- Description:	산출물정보를 삭제한다.
/*
DECLARE @result_cd INT, @result_msg VARCHAR(100);
 EXEC [dbo].[spDeleteOutputForTask] @pTask_id = 15, @pFile_path = '/nas/wellfood/marketing/20250528_신제품 디자인 초안2.pptx',@pOutput_comment = '디자인 초안 확인용', @pModifier_id = 1 , @result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT;
SELECT @result_cd as result_cd, @result_msg as result_msg;

*/
-- =============================================
CREATE PROCEDURE [dbo].[spDeleteOutputForTask]
	@pTask_id			INT				= NULL,
	@pFile_path			VARCHAR(200)	= NULL,
	@pModifier_id		VARCHAR(7)		= NULL,
    @result_cd			INT OUTPUT,
    @result_msg			VARCHAR(200) OUTPUT

AS
BEGIN
	
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	DECLARE @vSeverity				INT = NULL;
	DECLARE @vProject_id			INT = NULL;

	BEGIN TRY

		IF NOT EXISTS (SELECT 1 FROM task AS T WITH (NOLOCK) WHERE T.task_id = @pTask_id)
		BEGIN
			RAISERROR('존재하지 않는 태스크 입니다.', 16, 1);
		END
		
		---- 같은 태스크에 같은이름 파일은 못넣게 해야 함.
		--IF EXISTS (SELECT 1
		--			FROM task_output AS T WITH (NOLOCK) 
		--				INNER JOIN dbo.project AS P WITH (NOLOCK)
		--				ON T.project_id = P.project_id
		--				WHERE T.task_id = @pTask_id AND T.file_path = @pFile_path)
		--BEGIN
		--	RAISERROR('같은 태스크에 같은 이름의 산출물이 존재합니다.', 16, 1);
		--END

		UPDATE TOPT SET			
			TOPT.is_active_cd		=	'90',
			TOPT.Modifier_id		=	@pModifier_id,
			TOPT.modified_at		=	GETDATE()
		FROM dbo.task_output AS TOPT WITH (NOLOCK)
		WHERE TOPT.task_id = @pTask_id
		AND TOPT.file_path = @pFile_path


		SET @vSeverity = 0;
		SET @result_cd = 0;
		SET @result_msg = '성공';    
	END TRY
	BEGIN CATCH
		IF @@TRANCOUNT > 0
			ROLLBACK TRAN;
		
		-- 실패 메시지
		SET @vSeverity = ERROR_SEVERITY();
		SET @result_cd = -1;
		SET @result_msg = ERROR_MESSAGE();	
	END CATCH

	-- 로깅	
	DECLARE @log_param NVARCHAR(MAX);

	SET @log_param =
		'@pTask_id = '       + ISNULL(CAST(@pTask_id AS VARCHAR), 'NULL') + ', ' +
		'@pFile_path = '  + ISNULL(@pFile_path, 'NULL') + ', ' +
		'@pModifier_id = '         + ISNULL(@pModifier_id, 'NULL');


	INSERT INTO dbo.use_log (caller_id, severity, project_id, log_dt, log_message, proc_name, proc_param, result_cd, result_msg, created_at)
	VALUES(ISNULL(CAST(@pModifier_id AS VARCHAR(8)), 'UNKNOWN'), @vSeverity, ISNULL(@vProject_id, 0), CONVERT(CHAR(10), GETDATE(), 120), CAST(@pTask_id AS VARCHAR) + ' 태스크에 산출물을 삭제 하였습니다', '[spDeleteOutputForTask]', @log_param, @result_cd, @result_msg, GETDATE());

	RETURN;
END


--- Procedure 14 ---
ProcedureName: spUpdateOutputForTask
ProcedureDefinition:
-- =============================================
-- Author:		Jay Kwon
-- Create date: 2025-08-12
-- Description:	산출물정보를 수정한다.
/*
DECLARE @result_cd INT, @result_msg VARCHAR(100);
 EXEC [dbo].[spUpdateOutputForTask] @pTask_id = 15, @pFile_path = '/nas/wellfood/marketing/20250528_신제품 디자인 초안2.pptx',@pOutput_comment = '디자인 초안 확인용', @pModifier_id = 1 , @result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT;
SELECT @result_cd as result_cd, @result_msg as result_msg;

*/
-- =============================================
CREATE PROCEDURE [dbo].[spUpdateOutputForTask]
	@pTask_id			INT				= NULL,
	@pOutput_comment	VARCHAR(200)	= NULL,
	@pModifier_id		VARCHAR(7)		= NULL,
    @result_cd			INT OUTPUT,
    @result_msg			VARCHAR(200) OUTPUT

AS
BEGIN
	
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	DECLARE @vSeverity				INT = NULL;
	DECLARE @vProject_id			INT = NULL;

	BEGIN TRY

		IF NOT EXISTS (SELECT 1 FROM task AS T WITH (NOLOCK) WHERE T.task_id = @pTask_id)
		BEGIN
			RAISERROR('존재하지 않는 태스크 입니다.', 16, 1);
		END
		

		UPDATE TOPT SET			
			TOPT.output_comment		=	@pOutput_comment,
			TOPT.Modifier_id		=	@pModifier_id,
			TOPT.modified_at		=	GETDATE()
		FROM dbo.task_output AS TOPT WITH (NOLOCK)
		WHERE TOPT.task_id = @pTask_id


		SET @vSeverity = 0;
		SET @result_cd = 0;
		SET @result_msg = '성공';    
	END TRY
	BEGIN CATCH
		IF @@TRANCOUNT > 0
			ROLLBACK TRAN;
		
		-- 실패 메시지
		SET @vSeverity = ERROR_SEVERITY();
		SET @result_cd = -1;
		SET @result_msg = ERROR_MESSAGE();	
	END CATCH

	-- 로깅	
	DECLARE @log_param NVARCHAR(MAX);

	SET @log_param =
		'@pTask_id = '				+ ISNULL(CAST(@pTask_id AS VARCHAR), 'NULL') + ', ' +
		'@pOutput_comment = '		+ ISNULL(@pOutput_comment, 'NULL') + ', ' +
		'@pModifier_id = '			+ ISNULL(@pModifier_id, 'NULL');


	INSERT INTO dbo.use_log (caller_id, severity, project_id, log_dt, log_message, proc_name, proc_param, result_cd, result_msg, created_at)
	VALUES(ISNULL(CAST(@pModifier_id AS VARCHAR(8)), 'UNKNOWN'), @vSeverity, ISNULL(@vProject_id, 0), CONVERT(CHAR(10), GETDATE(), 120), CAST(@pTask_id AS VARCHAR) + ' 태스크에 산출물을 수정 하였습니다', '[spUpdateOutputForTask]', @log_param, @result_cd, @result_msg, GETDATE());

	RETURN;
END


--- Procedure 15 ---
ProcedureName: spGetDashBoardDataForMember
ProcedureDefinition:
-- =============================================
-- Author:		Jay Kwon
-- Create date: 2025-08-13
-- Description:	회원별 대시보드 데이터
/* 실행예제
DECLARE @result_cd INT, @result_msg VARCHAR(100);
EXEC [dbo].[spGetDashBoardDataForMember]  @result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT;
SELECT @result_cd as result_cd, @result_msg as result_msg;
*/
-- =============================================
CREATE PROCEDURE [dbo].[spGetDashBoardDataForMember]
    @result_cd			INT				OUTPUT,
    @result_msg			VARCHAR(200)	OUTPUT
AS
BEGIN
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	DECLARE @vSeverity				INT = NULL;

    BEGIN TRY

		SELECT
			R.member_id,
			R.member_name,
			R.member_dept_cd,
			DM.DEPT_NAME			AS member_dept_name,
			R.member_team_cd,	
			DM_T.DEPT_NAME			AS member_team_name,
			R.member_division_cd,
			DM_D.DEPT_NAME			AS member_division_name,
			R.progress_cnt,
			R.progress_project_ids,
			R.delayed_cnt,
			R.delayed_project_ids,
			R.done_cnt,
			R.done_project_ids
		FROM (
				SELECT
					M.member_id, 
					M.member_name,
					M.member_dept_cd,
					dbo.fnGetMemberDeptInfoForTeam(M.member_id)			AS member_team_cd,
					dbo.fnGetMemberDeptInfoForDivision(M.member_id)		AS member_division_cd,		
					COUNT(CASE WHEN M.state_cd = '20' THEN 1 END) AS progress_cnt,
					STRING_AGG(CASE WHEN M.state_cd = '20' THEN CAST(M.project_id AS VARCHAR) END, ',') AS progress_project_ids,
					COUNT(CASE WHEN M.state_cd = '30' THEN 1 END) AS delayed_cnt,
					STRING_AGG(CASE WHEN M.state_cd = '30' THEN CAST(M.project_id AS VARCHAR) END, ',') AS delayed_project_ids,
					COUNT(CASE WHEN M.state_cd IN ('90', '91') THEN 1 END) AS done_cnt,
					STRING_AGG(CASE WHEN M.state_cd IN ('90', '91') THEN CAST(M.project_id AS VARCHAR) END, ',') AS done_project_ids
				FROM (
						SELECT
							HM.EMP_ID											AS member_id, 
							HM.[NAME]											AS member_name,		
							HM.DEPT_CODE										AS member_dept_cd,
							P.project_id										AS project_id,
							dbo.fnGetProjectState(P.project_id)					AS state_cd
						FROM dbo.task AS T WITH (NOLOCK)
							INNER JOIN dbo.project AS P WITH (NOLOCK)
							ON T.project_id = P.project_id
							INNER JOIN dbo.task_owner AS TOWN WITH (NOLOCK)
							ON T.task_id = TOWN.task_id
							INNER JOIN dbo.hr_master AS HM WITH (NOLOCK)
							ON TOWN.member_id = HM.EMP_ID	
						WHERE T.is_active_cd = '10'
						AND P.project_type_cd = '10'
						AND P.is_active = '10'
						GROUP BY HM.EMP_ID, HM.[NAME], HM.DEPT_CODE, P.project_id) M
				GROUP BY M.member_id, M.member_name, M.member_dept_cd) R	
			LEFT JOIN dbo.dept_master AS DM WITH (NOLOCK)
			ON R.member_dept_cd = DM.DEPT_CODE
			LEFT JOIN dbo.dept_master AS DM_T WITH (NOLOCK)
			ON R.member_team_cd = DM_T.DEPT_CODE
			LEFT JOIN dbo.dept_master AS DM_D WITH (NOLOCK)
			ON R.member_division_cd = DM_D.DEPT_CODE
		ORDER BY member_division_name ASC, member_team_name ASC

		SET @vSeverity = 0;
		SET @result_cd = 0;
		SET @result_msg = '성공';

	END TRY

	BEGIN CATCH
		SET @result_cd = -1;
		SET @result_msg = ERROR_MESSAGE();
		SET @vSeverity = ERROR_SEVERITY();
	END CATCH


	RETURN;
END


--- Procedure 16 ---
ProcedureName: spInsertDeptAuth
ProcedureDefinition:

-- =============================================
-- Author:		JayKwon
-- Create date: 2025-07-01
-- Description:	부서 별 권한 등록
/*
DECLARE @result_cd INT, @result_msg VARCHAR(100);
EXEC [dbo].[spInsertDeptAuth] @pDept_cd = '13010101', @pAuth_cd = '10', @result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT;
SELECT @result_cd as result_cd, @result_msg as result_msg;
*/
-- =============================================
CREATE PROCEDURE [dbo].[spInsertDeptAuth]
	@pDept_cd		VARCHAR(8)		= NULL,
	@pAuth_cd		VARCHAR(8)		= NULL,	-- MST('90000', 사용자권한) 10:관리자, 20:마케터, 30:전체 프로젝트 열람 권한, 40:전체 프로젝트 열람 및 산출물 다운로드 권한, 50:스탭
	@pCreator_id	VARCHAR(7)		= NULL,
    @result_cd		INT				OUTPUT,
    @result_msg		VARCHAR(200)	OUTPUT
AS
BEGIN

	
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	IF NOT EXISTS(	SELECT 1
					FROM dbo.code_master AS CM WITH (NOLOCK)
					WHERE CM.group_cd = '90000'
					AND CM.detail_cd = @pAuth_cd)
	BEGIN
		SET @result_cd = 1;
		SET @result_msg = '정의되지 않은 권한 코드 입니다.';  
		RETURN;
	END

	IF NOT EXISTS(	SELECT 1
					FROM dbo.dept_master AS ODM WITH (NOLOCK)
					WHERE ODM.DEPT_CODE = @pDept_cd)
	BEGIN
		SET @result_cd = 1;
		SET @result_msg = '존재하지 않는 부서코드 입니다.';  
		RETURN;
	END

    BEGIN TRY
		BEGIN TRAN
			IF EXISTS(SELECT 1 FROM dbo.dept_auth AS DA WITH (NOLOCK) WHERE DA.dept_cd = @pDept_cd)
			BEGIN
				UPDATE DA SET
					DA.dept_auth_cd = @pAuth_cd,
					DA.modifier_id = @pCreator_id,
					DA.modified_at = GETDATE()
				FROM dbo.dept_auth AS DA WITH (NOLOCK)
				WHERE DA.dept_cd = @pDept_cd
			END
			ELSE
			BEGIN
				INSERT INTO dbo.dept_auth (	dept_cd,
											dept_auth_cd,
											creator_id,
											created_at,
											modifier_id,
											modified_at)
				VALUES (@pDept_cd, @pAuth_cd, @pCreator_id, GETDATE(), NULL, NULL)
			END
		COMMIT TRAN;

		SET @result_cd = 0;
		SET @result_msg = '성공';   
		RETURN;
	END TRY
	BEGIN CATCH
		ROLLBACK TRAN;
		SET @result_cd = -1;
		SET @result_msg = ERROR_MESSAGE();
		RETURN;
	END CATCH
END


--- Procedure 17 ---
ProcedureName: spGetMappingCodeLineToBrand
ProcedureDefinition:
-- =============================================
-- Author:		Jay Kwon
-- Create date: 2025-08-13
-- Description:	라인 코드에 맵핑된 브랜드를 가져온다.
/* 실행예제
DECLARE @result_cd INT, @result_msg VARCHAR(100);
EXEC [dbo].[spGetMappingCodeLineToBrand] @pLine_cd = NULL ,@pBrand_name = '거북알',@pBrand_cd = NULL, @result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT;
SELECT @result_cd as result_cd, @result_msg as result_msg;
*/
-- =============================================
CREATE PROCEDURE [dbo].[spGetMappingCodeLineToBrand]
	@pLine_cd			VARCHAR(8)		= NULL,
	@pBrand_name		NVARCHAR(240)	= NULL,
	@pBrand_cd			NVARCHAR(16)	= NULL,
    @result_cd			INT				OUTPUT,
    @result_msg			VARCHAR(200)	OUTPUT
AS
BEGIN
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	DECLARE @vSeverity				INT = NULL;

    BEGIN TRY
	

		IF (@pLine_cd IS NOT NULL)
		BEGIN
			IF NOT EXISTS(SELECT 1 FROM dbo.code_master AS CM WITH (NOLOCK) WHERE CM.group_cd IN ('20001','20002') AND CM.detail_cd = @pLine_cd)
			BEGIN
				RAISERROR('존재하지 않는 라인코드 입니다. 라인코드를 먼저 확인하세요.', 16, 1);
			END
		END

		SELECT
			dbo.fnGetLineTypeCd(LINE.detail_cd)	AS group_cd,
			dbo.fnGetDetailNameByDetailCode('20101',dbo.fnGetLineTypeCd(LINE.detail_cd)) AS group_name,
			LINE.detail_cd		AS line_cd,
			LINE.detail_name	AS line_name,
			SNB.BRANDCODE		AS brand_cd,
			SNB.BRANDNAME		AS brand_name
		FROM dbo.mapper_line_brand AS MLB WITH (NOLOCK)
			INNER JOIN dbo.IF_SAP_NPD_BRAND AS SNB WITH (NOLOCK)
			ON MLB.brand_cd = SNB.BRANDCODE
			LEFT JOIN dbo.code_master AS LINE WITH (NOLOCK)
			ON MLB.line_cd = LINE.detail_cd
			AND LINE.group_cd IN ('20001', '20002')
		WHERE (@pLine_cd IS NULL OR MLB.line_cd = @pLine_cd)
		AND SNB.BRANDTYPE = '200'
		AND (@pBrand_name IS NULL OR SNB.BRANDNAME = @pBrand_name)
		AND (@pBrand_cd IS NULL OR SNB.BRANDCODE = @pBrand_cd);

		
		SET @vSeverity = 0;
		SET @result_cd = 0;
		SET @result_msg = '성공';

	END TRY

	BEGIN CATCH

		SET @result_cd = -1;
		SET @result_msg = ERROR_MESSAGE();
		SET @vSeverity = ERROR_SEVERITY();
	END CATCH


	RETURN;
END


--- Procedure 18 ---
ProcedureName: spInsertMappingCodeLineToBrand
ProcedureDefinition:
-- =============================================
-- Author:		Jay Kwon
-- Create date: 2025-08-13
-- Description:	라인, 브랜드 맵핑 코드를 인서트 한다.
/* 실행예제
DECLARE @result_cd INT, @result_msg VARCHAR(100);
EXEC [dbo].[spInsertMappingCodeLineToBrand] @pLine_cd = 1102, @pBrand_cds = '10000001,10000002', @result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT;
SELECT @result_cd as result_cd, @result_msg as result_msg;
*/
-- =============================================
CREATE PROCEDURE [dbo].[spInsertMappingCodeLineToBrand]
	@pLine_cd			VARCHAR(8)		= NULL,
	@pBrand_cds			NVARCHAR(MAX)	= NULL,
    @result_cd			INT				OUTPUT,
    @result_msg			VARCHAR(200)	OUTPUT
AS
BEGIN
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
	
	DECLARE @vSeverity				INT = NULL;

    BEGIN TRY
	
		DECLARE @vBrand_cd_list TABLE (brand_cd NVARCHAR(16));



		-- CSV 문자열을 파싱해서 테이블에 삽입
		INSERT INTO @vBrand_cd_list (brand_cd)
		SELECT DISTINCT TRIM(value)
		FROM STRING_SPLIT(@pBrand_cds, ',')

		BEGIN TRAN

		INSERT INTO dbo.mapper_line_brand
		SELECT
			@pLine_cd,
			BCL.brand_cd
		FROM @vBrand_cd_list AS BCL
			LEFT JOIN dbo.mapper_line_brand AS MLB WITH (NOLOCK)
			ON BCL.brand_cd = MLB.brand_cd
		WHERE MLB.brand_cd IS NULL;
		
		COMMIT TRAN

		SET @vSeverity = 0;
		SET @result_cd = 0;
		SET @result_msg = '성공';

	END TRY

	BEGIN CATCH
		IF @@TRANCOUNT > 0
			ROLLBACK TRAN;

		SET @result_cd = -1;
		SET @result_msg = ERROR_MESSAGE();
		SET @vSeverity = ERROR_SEVERITY();
	END CATCH

	DECLARE @log_param VARCHAR(MAX);

	RETURN;
END


--- Procedure 19 ---
ProcedureName: spDeleteMappingCodeLineToBrand
ProcedureDefinition:
-- =============================================
-- Author:		Jay Kwon
-- Create date: 2025-08-13
-- Description:	맵핑된 라인, 브랜드 코드를 삭제 한다.
/* 실행예제
DECLARE @result_cd INT, @result_msg VARCHAR(100);
EXEC [dbo].[spDeleteMappingCodeLineToBrand] @pLine_cd = 1102 ,@pBrand_cd = '10000001', @result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT;
SELECT @result_cd as result_cd, @result_msg as result_msg;
*/
-- =============================================
CREATE PROCEDURE [dbo].[spDeleteMappingCodeLineToBrand]
	@pLine_cd			VARCHAR(8)		= NULL,
	@pBrand_cd			NVARCHAR(16)	= NULL,
    @result_cd			INT				OUTPUT,
    @result_msg			VARCHAR(200)	OUTPUT
AS
BEGIN
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	DECLARE @vSeverity				INT = NULL;

    BEGIN TRY
	

		DELETE MLB
		FROM dbo.mapper_line_brand AS MLB WITH (NOLOCK)
		WHERE MLB.line_cd = @pLine_cd
		AND MLB.brand_cd = @pBrand_cd

		SET @vSeverity = 0;
		SET @result_cd = 0;
		SET @result_msg = '성공';

	END TRY

	BEGIN CATCH
		IF @@TRANCOUNT > 0
			ROLLBACK TRAN;

		SET @result_cd = -1;
		SET @result_msg = ERROR_MESSAGE();
		SET @vSeverity = ERROR_SEVERITY();
	END CATCH


	RETURN;
END


--- Procedure 20 ---
ProcedureName: sp_upgraddiagrams
ProcedureDefinition:

	CREATE PROCEDURE dbo.sp_upgraddiagrams
	AS
	BEGIN
		IF OBJECT_ID(N'dbo.sysdiagrams') IS NOT NULL
			return 0;
	
		CREATE TABLE dbo.sysdiagrams
		(
			name sysname NOT NULL,
			principal_id int NOT NULL,	-- we may change it to varbinary(85)
			diagram_id int PRIMARY KEY IDENTITY,
			version int,
	
			definition varbinary(max)
			CONSTRAINT UK_principal_name UNIQUE
			(
				principal_id,
				name
			)
		);


		/* Add this if we need to have some form of extended properties for diagrams */
		/*
		IF OBJECT_ID(N'dbo.sysdiagram_properties') IS NULL
		BEGIN
			CREATE TABLE dbo.sysdiagram_properties
			(
				diagram_id int,
				name sysname,
				value varbinary(max) NOT NULL
			)
		END
		*/

		IF OBJECT_ID(N'dbo.dtproperties') IS NOT NULL
		begin
			insert into dbo.sysdiagrams
			(
				[name],
				[principal_id],
				[version],
				[definition]
			)
			select	 
				convert(sysname, dgnm.[uvalue]),
				DATABASE_PRINCIPAL_ID(N'dbo'),			-- will change to the sid of sa
				0,							-- zero for old format, dgdef.[version],
				dgdef.[lvalue]
			from dbo.[dtproperties] dgnm
				inner join dbo.[dtproperties] dggd on dggd.[property] = 'DtgSchemaGUID' and dggd.[objectid] = dgnm.[objectid]	
				inner join dbo.[dtproperties] dgdef on dgdef.[property] = 'DtgSchemaDATA' and dgdef.[objectid] = dgnm.[objectid]
				
			where dgnm.[property] = 'DtgSchemaNAME' and dggd.[uvalue] like N'_EA3E6268-D998-11CE-9454-00AA00A3F36E_' 
			return 2;
		end
		return 1;
	END
	

--- Procedure 21 ---
ProcedureName: spGetDashBoardDataForAll
ProcedureDefinition:
-- =============================================
-- Author:		Jay Kwon
-- Create date: 2025-07-04
-- Description:	전체 조회 대시보드 (구분값은 파라미터)
-- mst(20103, 프로젝트 구분) : 100 순수, 101 익스텐션, 102 체인전용, 103 리뉴얼
/* 000, 000, 0000
DECLARE @result_cd INT, @result_msg VARCHAR(100);
EXEC [dbo].[spGetDashBoardDataForAll] @pWork_type_cd = NULL, @result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT;
SELECT @result_cd as result_cd, @result_msg as result_msg;
*/
-- =============================================
CREATE PROCEDURE [dbo].[spGetDashBoardDataForAll]
	@pWork_type_cd	    AS VARCHAR(8) = NULL,
    @result_cd			INT OUTPUT,
    @result_msg			VARCHAR(200) OUTPUT
AS
BEGIN

	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

    DECLARE @vTemplate      TABLE(
        line_type_cd        VARCHAR(8),
        line_type_name      VARCHAR(50),
        line_cd             VARCHAR(8),
        line_name           VARCHAR(50)
    )

    INSERT INTO @vTemplate
    SELECT
        CM2.detail_cd       AS line_type_cd,
        CM2.detail_name     AS line_type_name,
        CM1.detail_cd       AS line_cd,
        CM1.detail_name     AS line_name
    FROM dbo.code_master AS CM1 WITH (NOLOCK)
        INNER JOIN dbo.code_master AS CM2 WITH (NOLOCK)
        ON CM1.group_cd = CM2.detail_cd
        AND CM2.group_cd = '20101';


    DECLARE @vResult TABLE(    
        line_cd                 VARCHAR(8),        
        progress_cnt            INT,
        progress_project_ids    VARCHAR(MAX),
        delayed_cnt             INT,
        delayed_project_ids     VARCHAR(MAX),
        done_cnt                INT,
        done_project_ids        VARCHAR(MAX)
    )


    BEGIN TRY
        -- 기존 PIVOT 제거하고 직접 상태별 COUNT 및 STRING_AGG 처리
        INSERT INTO @vResult
        SELECT 
            line_cd,
            COUNT(CASE WHEN state_cd = '20' THEN 1 END) AS progress_cnt,
            STRING_AGG(CASE WHEN state_cd = '20' THEN CAST(project_id AS VARCHAR) END, ',') AS progress_project_ids,
            COUNT(CASE WHEN state_cd = '30' THEN 1 END) AS delayed_cnt,
            STRING_AGG(CASE WHEN state_cd = '30' THEN CAST(project_id AS VARCHAR) END, ',') AS delayed_project_ids,
            COUNT(CASE WHEN state_cd IN ('90', '91') THEN 1 END) AS done_cnt,
            STRING_AGG(CASE WHEN state_cd IN ('90', '91') THEN CAST(project_id AS VARCHAR) END, ',') AS done_project_ids
        FROM (
            SELECT         
                P.project_id,
                P.line_cd,        
                dbo.fnGetProjectState(P.project_id) AS state_cd
            FROM dbo.project AS P
                LEFT JOIN dbo.task_finish_plan AS TFP WITH (NOLOCK)
                ON P.project_id = TFP.project_id
                AND TFP.plan_cd = '20'
            WHERE P.project_type_cd = '10'
            AND (@pWork_type_cd IS NULL OR P.work_type_cd = @pWork_type_cd)
            GROUP BY P.project_id, P.line_cd
        ) AS Sub
        GROUP BY line_cd

    SELECT
        TMP.line_type_cd,
        TMP.line_type_name,
        TMP.line_cd,
        TMP.line_name,
        ISNULL(R.progress_cnt,0) + ISNULL(R.delayed_cnt,0) + ISNULL(R.done_cnt,0) AS total,
        ISNULL(R.progress_cnt,0) + ISNULL(R.delayed_cnt,0) AS progress_total,
        ISNULL(R.progress_cnt,0) AS progress_cnt,
        ISNULL(R.progress_project_ids, '') AS progress_project_ids,
        ISNULL(R.delayed_cnt,0) AS delayed_cnt,
        ISNULL(R.delayed_project_ids, '') AS delayed_project_ids,
        ISNULL(R.done_cnt,0) AS done_cnt,
        ISNULL(R.done_project_ids, '') AS done_project_ids
    FROM @vTemplate AS TMP
        LEFT JOIN @vResult AS R
        ON TMP.line_cd = R.line_cd;


		SET @result_cd = 0;
		SET @result_msg = '성공';   

    END TRY
    BEGIN CATCH
        SET @result_cd = -1;
		SET @result_msg = ERROR_MESSAGE();
    END CATCH
END


--- Procedure 22 ---
ProcedureName: sp_helpdiagrams
ProcedureDefinition:

	CREATE PROCEDURE dbo.sp_helpdiagrams
	(
		@diagramname sysname = NULL,
		@owner_id int = NULL
	)
	WITH EXECUTE AS N'dbo'
	AS
	BEGIN
		DECLARE @user sysname
		DECLARE @dboLogin bit
		EXECUTE AS CALLER;
			SET @user = USER_NAME();
			SET @dboLogin = CONVERT(bit,IS_MEMBER('db_owner'));
		REVERT;
		SELECT
			[Database] = DB_NAME(),
			[Name] = name,
			[ID] = diagram_id,
			[Owner] = USER_NAME(principal_id),
			[OwnerID] = principal_id
		FROM
			sysdiagrams
		WHERE
			(@dboLogin = 1 OR USER_NAME(principal_id) = @user) AND
			(@diagramname IS NULL OR name = @diagramname) AND
			(@owner_id IS NULL OR principal_id = @owner_id)
		ORDER BY
			4, 5, 1
	END
	

--- Procedure 23 ---
ProcedureName: spGetDashBoardDataForMonthly
ProcedureDefinition:
-- =============================================
-- Author:		jay kwon
-- Create date: 2025-07-04
-- Description:	월별 조회 대시보드 (구분값은 파라미터)
/*

DECLARE @start_month VARCHAR(7), @result_cd INT, @result_msg VARCHAR(100);
EXEC [dbo].[spGetDashBoardDataForMonthly] @pWork_type_cd = NULL, @start_month = @start_month OUTPUT, @result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT;
SELECT @start_month as start_month, @result_cd as result_cd, @result_msg as result_msg;

*/
-- =============================================
CREATE PROCEDURE [dbo].[spGetDashBoardDataForMonthly]
	@pWork_type_cd	VARCHAR(8)		= NULL,
	@start_month	VARCHAR(7)		OUTPUT,
    @result_cd		INT				OUTPUT,
    @result_msg		VARCHAR(200)	OUTPUT
AS
BEGIN
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	DECLARE @vResult_org TABLE (
		line_cd				VARCHAR(8),
		planed_end_month	VARCHAR(7),
		project_cnt			INT,
		project_ids			VARCHAR(MAX)
	)


	DECLARE @vTemplate TABLE (
		line_type_cd	VARCHAR(8),
		line_type_name	VARCHAR(50),
		line_cd			VARCHAR(8),
		line_name		VARCHAR(50)
	)

	SET @start_month = FORMAT(DATEFROMPARTS(YEAR(GETDATE()), MONTH(GETDATE()), 1), 'yyyy-MM');

	BEGIN TRY
		-- 1. 라인 템플릿 구성
		INSERT INTO @vTemplate
		SELECT
			CM2.detail_cd       AS line_type_cd,
			CM2.detail_name     AS line_type_name,
			CM1.detail_cd       AS line_cd,
			CM1.detail_name     AS line_name
		FROM dbo.code_master AS CM1 WITH (NOLOCK)
			INNER JOIN dbo.code_master AS CM2 WITH (NOLOCK)
			ON CM1.group_cd = CM2.detail_cd
			AND CM2.group_cd = '20101';
		

		-- 2. 원본 프로젝트 데이터 수집
		INSERT INTO @vResult_org
		SELECT    
			A.line_cd,        
			A.planed_end_month,   
			COUNT(*) AS project_cnt,
			STRING_AGG(CAST(A.project_id AS VARCHAR), ',') AS project_ids
		FROM (
			SELECT         
				P.project_id,
				P.line_cd,                                
				LEFT(MAX(TFP.end_dt),7) AS planed_end_month            
			FROM dbo.project AS P
			LEFT JOIN dbo.task_finish_plan AS TFP WITH (NOLOCK)
				ON P.project_id = TFP.project_id
				AND TFP.plan_cd = '20'
			WHERE P.project_type_cd = '10'
			AND (@pWork_type_cd IS NULL OR P.work_type_cd = @pWork_type_cd)
			GROUP BY P.project_id, P.line_cd
		) A
		WHERE A.planed_end_month >= @start_month
		GROUP BY A.line_cd, A.planed_end_month


		-- 3. 기준 월별 데이터 조합
		DECLARE @base TABLE (
			line_type_cd	VARCHAR(8),
			line_type_name	VARCHAR(50),
			line_cd			VARCHAR(8),
			line_name		VARCHAR(50),
			month_index		INT,
			project_cnt		INT,
			project_ids		VARCHAR(MAX)
		)


		INSERT INTO @base (line_type_cd, line_type_name, line_cd, line_name, month_index, project_cnt, project_ids)
		SELECT     
			TMP.line_type_cd,
			TMP.line_type_name,
			TMP.line_cd,
			TMP.line_name,
			T.n AS month_index,
			ISNULL(R.project_cnt, 0),
			ISNULL(R.project_ids, '')
		FROM @vTemplate AS TMP 
		CROSS JOIN (
			SELECT 
				FORMAT(DATEADD(MONTH, v.n, DATEFROMPARTS(YEAR(GETDATE()), MONTH(GETDATE()), 1)), 'yyyy-MM') AS target_month,
				v.n
			FROM (VALUES (0),(1),(2),(3),(4),(5),(6),(7),(8),(9),(10),(11)) AS v(n)
		) AS T
		LEFT JOIN @vResult_org AS R
			ON TMP.line_cd = R.line_cd AND R.planed_end_month = T.target_month


		-- 4. 결과 출력 (start_month 포함)
		SELECT 
			line_type_cd,
			line_type_name,
			line_cd,
			line_name,
			SUM(CASE WHEN month_index = 0 THEN project_cnt ELSE 0 END) AS M0,
			STRING_AGG(CASE WHEN month_index = 0 THEN ISNULL(project_ids, '') END, ',') AS M0_ids,
			SUM(CASE WHEN month_index = 1 THEN project_cnt ELSE 0 END) AS M1,
			STRING_AGG(CASE WHEN month_index = 1 THEN ISNULL(project_ids, '') END, ',') AS M1_ids,
			SUM(CASE WHEN month_index = 2 THEN project_cnt ELSE 0 END) AS M2,
			STRING_AGG(CASE WHEN month_index = 2 THEN ISNULL(project_ids, '') END, ',') AS M2_ids,
			SUM(CASE WHEN month_index = 3 THEN project_cnt ELSE 0 END) AS M3,
			STRING_AGG(CASE WHEN month_index = 3 THEN ISNULL(project_ids, '') END, ',') AS M3_ids,
			SUM(CASE WHEN month_index = 4 THEN project_cnt ELSE 0 END) AS M4,
			STRING_AGG(CASE WHEN month_index = 4 THEN ISNULL(project_ids, '') END, ',') AS M4_ids,
			SUM(CASE WHEN month_index = 5 THEN project_cnt ELSE 0 END) AS M5,
			STRING_AGG(CASE WHEN month_index = 5 THEN ISNULL(project_ids, '') END, ',') AS M5_ids,
			SUM(CASE WHEN month_index = 6 THEN project_cnt ELSE 0 END) AS M6,
			STRING_AGG(CASE WHEN month_index = 6 THEN ISNULL(project_ids, '') END, ',') AS M6_ids,
			SUM(CASE WHEN month_index = 7 THEN project_cnt ELSE 0 END) AS M7,
			STRING_AGG(CASE WHEN month_index = 7 THEN ISNULL(project_ids, '') END, ',') AS M7_ids,
			SUM(CASE WHEN month_index = 8 THEN project_cnt ELSE 0 END) AS M8,
			STRING_AGG(CASE WHEN month_index = 8 THEN ISNULL(project_ids, '') END, ',') AS M8_ids,
			SUM(CASE WHEN month_index = 9 THEN project_cnt ELSE 0 END) AS M9,
			STRING_AGG(CASE WHEN month_index = 9 THEN ISNULL(project_ids, '') END, ',') AS M9_ids,
			SUM(CASE WHEN month_index = 10 THEN project_cnt ELSE 0 END) AS M10,
			STRING_AGG(CASE WHEN month_index = 10 THEN ISNULL(project_ids, '') END, ',') AS M10_ids,
			SUM(CASE WHEN month_index = 11 THEN project_cnt ELSE 0 END) AS M11,
			STRING_AGG(CASE WHEN month_index = 11 THEN ISNULL(project_ids, '') END, ',') AS M11_ids
		FROM @base
		GROUP BY line_type_cd, line_type_name, line_cd, line_name
		ORDER BY line_type_cd, line_cd;



		SET @result_cd = 0;
		SET @result_msg = '성공';
	END TRY
	BEGIN CATCH
		SET @result_cd = -1;
		SET @result_msg = ERROR_MESSAGE();
	END CATCH
END


--- Procedure 24 ---
ProcedureName: sp_helpdiagramdefinition
ProcedureDefinition:

	CREATE PROCEDURE dbo.sp_helpdiagramdefinition
	(
		@diagramname 	sysname,
		@owner_id	int	= null 		
	)
	WITH EXECUTE AS N'dbo'
	AS
	BEGIN
		set nocount on

		declare @theId 		int
		declare @IsDbo 		int
		declare @DiagId		int
		declare @UIDFound	int
	
		if(@diagramname is null)
		begin
			RAISERROR (N'E_INVALIDARG', 16, 1);
			return -1
		end
	
		execute as caller;
		select @theId = DATABASE_PRINCIPAL_ID();
		select @IsDbo = IS_MEMBER(N'db_owner');
		if(@owner_id is null)
			select @owner_id = @theId;
		revert; 
	
		select @DiagId = diagram_id, @UIDFound = principal_id from dbo.sysdiagrams where principal_id = @owner_id and name = @diagramname;
		if(@DiagId IS NULL or (@IsDbo = 0 and @UIDFound <> @theId ))
		begin
			RAISERROR ('Diagram does not exist or you do not have permission.', 16, 1);
			return -3
		end

		select version, definition FROM dbo.sysdiagrams where diagram_id = @DiagId ; 
		return 0
	END
	

--- Procedure 25 ---
ProcedureName: sp_creatediagram
ProcedureDefinition:

	CREATE PROCEDURE dbo.sp_creatediagram
	(
		@diagramname 	sysname,
		@owner_id		int	= null, 	
		@version 		int,
		@definition 	varbinary(max)
	)
	WITH EXECUTE AS 'dbo'
	AS
	BEGIN
		set nocount on
	
		declare @theId int
		declare @retval int
		declare @IsDbo	int
		declare @userName sysname
		if(@version is null or @diagramname is null)
		begin
			RAISERROR (N'E_INVALIDARG', 16, 1);
			return -1
		end
	
		execute as caller;
		select @theId = DATABASE_PRINCIPAL_ID(); 
		select @IsDbo = IS_MEMBER(N'db_owner');
		revert; 
		
		if @owner_id is null
		begin
			select @owner_id = @theId;
		end
		else
		begin
			if @theId <> @owner_id
			begin
				if @IsDbo = 0
				begin
					RAISERROR (N'E_INVALIDARG', 16, 1);
					return -1
				end
				select @theId = @owner_id
			end
		end
		-- next 2 line only for test, will be removed after define name unique
		if EXISTS(select diagram_id from dbo.sysdiagrams where principal_id = @theId and name = @diagramname)
		begin
			RAISERROR ('The name is already used.', 16, 1);
			return -2
		end
	
		insert into dbo.sysdiagrams(name, principal_id , version, definition)
				VALUES(@diagramname, @theId, @version, @definition) ;
		
		select @retval = @@IDENTITY 
		return @retval
	END
	

--- Procedure 26 ---
ProcedureName: sp_renamediagram
ProcedureDefinition:

	CREATE PROCEDURE dbo.sp_renamediagram
	(
		@diagramname 		sysname,
		@owner_id		int	= null,
		@new_diagramname	sysname
	
	)
	WITH EXECUTE AS 'dbo'
	AS
	BEGIN
		set nocount on
		declare @theId 			int
		declare @IsDbo 			int
		
		declare @UIDFound 		int
		declare @DiagId			int
		declare @DiagIdTarg		int
		declare @u_name			sysname
		if((@diagramname is null) or (@new_diagramname is null))
		begin
			RAISERROR ('Invalid value', 16, 1);
			return -1
		end
	
		EXECUTE AS CALLER;
		select @theId = DATABASE_PRINCIPAL_ID();
		select @IsDbo = IS_MEMBER(N'db_owner'); 
		if(@owner_id is null)
			select @owner_id = @theId;
		REVERT;
	
		select @u_name = USER_NAME(@owner_id)
	
		select @DiagId = diagram_id, @UIDFound = principal_id from dbo.sysdiagrams where principal_id = @owner_id and name = @diagramname 
		if(@DiagId IS NULL or (@IsDbo = 0 and @UIDFound <> @theId))
		begin
			RAISERROR ('Diagram does not exist or you do not have permission.', 16, 1)
			return -3
		end
	
		-- if((@u_name is not null) and (@new_diagramname = @diagramname))	-- nothing will change
		--	return 0;
	
		if(@u_name is null)
			select @DiagIdTarg = diagram_id from dbo.sysdiagrams where principal_id = @theId and name = @new_diagramname
		else
			select @DiagIdTarg = diagram_id from dbo.sysdiagrams where principal_id = @owner_id and name = @new_diagramname
	
		if((@DiagIdTarg is not null) and  @DiagId <> @DiagIdTarg)
		begin
			RAISERROR ('The name is already used.', 16, 1);
			return -2
		end		
	
		if(@u_name is null)
			update dbo.sysdiagrams set [name] = @new_diagramname, principal_id = @theId where diagram_id = @DiagId
		else
			update dbo.sysdiagrams set [name] = @new_diagramname where diagram_id = @DiagId
		return 0
	END
	

--- Procedure 27 ---
ProcedureName: sp_alterdiagram
ProcedureDefinition:

	CREATE PROCEDURE dbo.sp_alterdiagram
	(
		@diagramname 	sysname,
		@owner_id	int	= null,
		@version 	int,
		@definition 	varbinary(max)
	)
	WITH EXECUTE AS 'dbo'
	AS
	BEGIN
		set nocount on
	
		declare @theId 			int
		declare @retval 		int
		declare @IsDbo 			int
		
		declare @UIDFound 		int
		declare @DiagId			int
		declare @ShouldChangeUID	int
	
		if(@diagramname is null)
		begin
			RAISERROR ('Invalid ARG', 16, 1)
			return -1
		end
	
		execute as caller;
		select @theId = DATABASE_PRINCIPAL_ID();	 
		select @IsDbo = IS_MEMBER(N'db_owner'); 
		if(@owner_id is null)
			select @owner_id = @theId;
		revert;
	
		select @ShouldChangeUID = 0
		select @DiagId = diagram_id, @UIDFound = principal_id from dbo.sysdiagrams where principal_id = @owner_id and name = @diagramname 
		
		if(@DiagId IS NULL or (@IsDbo = 0 and @theId <> @UIDFound))
		begin
			RAISERROR ('Diagram does not exist or you do not have permission.', 16, 1);
			return -3
		end
	
		if(@IsDbo <> 0)
		begin
			if(@UIDFound is null or USER_NAME(@UIDFound) is null) -- invalid principal_id
			begin
				select @ShouldChangeUID = 1 ;
			end
		end

		-- update dds data			
		update dbo.sysdiagrams set definition = @definition where diagram_id = @DiagId ;

		-- change owner
		if(@ShouldChangeUID = 1)
			update dbo.sysdiagrams set principal_id = @theId where diagram_id = @DiagId ;

		-- update dds version
		if(@version is not null)
			update dbo.sysdiagrams set version = @version where diagram_id = @DiagId ;

		return 0
	END
	

--- Procedure 28 ---
ProcedureName: spDeleteTemplateProject
ProcedureDefinition:
-- =============================================
-- Author:		Jay Kwon
-- Create date: 2025-07-04
-- Description:	템플릿 삭제
-- =============================================
CREATE PROCEDURE [dbo].[spDeleteTemplateProject]
	@pProject_id			INT			= NULL,
	@pModifier_id			VARCHAR(7)	= NULL,
    @result_cd				INT OUTPUT,
    @result_msg				VARCHAR(200) OUTPUT
AS
BEGIN
	
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
	
	DECLARE @vSeverity				INT = NULL;

	BEGIN TRY
		

		UPDATE P SET
			P.is_active = '90',
			P.modifier_id = @pModifier_id,
			P.modified_at = GETDATE()
		FROM dbo.project AS P WITH (NOLOCK)
		WHERE P.project_id = @pProject_id
		AND P.project_type_cd = '90'
		AND P.is_active = '10'

		SET @vSeverity = 0;
		SET @result_cd = 0;
		SET @result_msg = '성공';

		
	END TRY
	BEGIN CATCH
		IF @@TRANCOUNT > 0
			ROLLBACK TRAN;

		-- 실패 메시지
		SET @result_cd = -1;
		SET @result_msg = ERROR_MESSAGE();
		SET @vSeverity = ERROR_SEVERITY();

	END CATCH

	DECLARE @log_param VARCHAR(MAX);

	SET @log_param = '@pProject_id = ' + ISNULL(CAST(@pProject_id AS VARCHAR), 'NULL') + ', '
				   + '@pModifier_id = ' + ISNULL(@pModifier_id, 'NULL');
				   

	INSERT INTO dbo.use_log (caller_id, severity, project_id, log_dt, log_message, proc_name, proc_param, result_cd, result_msg, created_at)
	VALUES(ISNULL(CAST(@pModifier_id AS VARCHAR(8)), 'UNKNOWN'), @vSeverity, ISNULL(@pProject_id, 0), CONVERT(CHAR(10), GETDATE(), 120), '템플릿 삭제', '[spDeleteTemplateProject]', @log_param, @result_cd, @result_msg, GETDATE());


END


--- Procedure 29 ---
ProcedureName: sp_dropdiagram
ProcedureDefinition:

	CREATE PROCEDURE dbo.sp_dropdiagram
	(
		@diagramname 	sysname,
		@owner_id	int	= null
	)
	WITH EXECUTE AS 'dbo'
	AS
	BEGIN
		set nocount on
		declare @theId 			int
		declare @IsDbo 			int
		
		declare @UIDFound 		int
		declare @DiagId			int
	
		if(@diagramname is null)
		begin
			RAISERROR ('Invalid value', 16, 1);
			return -1
		end
	
		EXECUTE AS CALLER;
		select @theId = DATABASE_PRINCIPAL_ID();
		select @IsDbo = IS_MEMBER(N'db_owner'); 
		if(@owner_id is null)
			select @owner_id = @theId;
		REVERT; 
		
		select @DiagId = diagram_id, @UIDFound = principal_id from dbo.sysdiagrams where principal_id = @owner_id and name = @diagramname 
		if(@DiagId IS NULL or (@IsDbo = 0 and @UIDFound <> @theId))
		begin
			RAISERROR ('Diagram does not exist or you do not have permission.', 16, 1)
			return -3
		end
	
		delete from dbo.sysdiagrams where diagram_id = @DiagId;
	
		return 0;
	END
	

--- Procedure 30 ---
ProcedureName: spGetProjectMember
ProcedureDefinition:
-- =============================================
-- Author:		jay kwon
-- Create date: 2025-07-07
-- Description:	프로젝트 멤버를 조회 한다.
/*
DECLARE @result_cd INT, @result_msg VARCHAR(100);
EXEC [dbo].[spGetProjectMember] @pProject_id = 25080009,　@result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT;
SELECT @result_cd as result_cd, @result_msg as result_msg;
*/
-- =============================================
CREATE PROCEDURE [dbo].[spGetProjectMember]
	@pProject_id		INT = NULL,
    @result_cd			INT				OUTPUT,
    @result_msg			VARCHAR(200)	OUTPUT
AS
BEGIN
	
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	SELECT
		PM.project_id,
		PM.member_id,
		ISNULL(HRM.[NAME],'미존재 회원')	AS member_name,
		PM.status_cd,
		ODM.DEPT_CODE,
		ODM.DEPT_NAME,
		PM.creator_id,
		PM.created_at,
		PM.modifier_id,
		PM.modified_at
	FROM dbo.project_member AS PM WITH (NOLOCK)
		LEFT JOIN dbo.hr_master AS HRM WITH (NOLOCK)
		ON PM.member_id = HRM.EMP_ID
		LEFT JOIN dbo.dept_master AS ODM WITH (NOLOCK)
		ON HRM.DEPT_CODE = ODM.DEPT_CODE
	WHERE PM.project_id = @pProject_id
	AND PM.status_cd = '10'
	
	SET @result_cd = 0
	SET @result_msg = '성공'
    
END


--- Procedure 31 ---
ProcedureName: spGetMemberInfo
ProcedureDefinition:


-- =============================================
-- Author:		jay kwon
-- Create date: 2025-07-09
-- Description:	이름 또는 회원 아이디로 회원 정보를 조회한다.
/*
-- 이름으로 조회
DECLARE @result_project_id INT, @result_cd INT, @result_msg VARCHAR(100);
EXEC [dbo].[spGetMemberInfo] @pMember_id = NULL, @pMember_name = '최민주', @result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT;
SELECT @result_cd as result_cd, @result_msg as result_msg;

-- 아이디로 조회
DECLARE @result_project_id INT, @result_cd INT, @result_msg VARCHAR(100);
EXEC [dbo].[spGetMemberInfo] @pMember_id = '2400016', @pMember_name = NULL, @result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT;
SELECT @result_cd as result_cd, @result_msg as result_msg;
*/
-- =============================================
CREATE PROCEDURE [dbo].[spGetMemberInfo]
	@pMember_id			VARCHAR(7) = NULL,
	@pMember_name		VARCHAR(20) = NULL,
	@result_cd			INT				OUTPUT,
    @result_msg			VARCHAR(200)	OUTPUT
AS
BEGIN

	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	DECLARE @vSeverity				INT = NULL;


	BEGIN TRY
		IF (ISNULL(@pMember_id,'') = '' AND ISNULL(@pMember_name, '') = '')
		BEGIN
			RAISERROR('조회 조건이 누락되었습니다.', 16, 1);
		END

		SELECT
			HRM.EMP_ID,
			HRM.[NAME],
			HRM.MOIN_ID,
			HRM.MOIN_EMAIL,
			HRM.DEPT_CODE,
			DM.DEPT_NAME,
			HRM.JOB_CODE,
			HRM.JOB_GRADE_NM,
			HRM.JOB_DUTY,
			HRM.JOB_DUTY_NM
		FROM dbo.hr_master AS HRM WITH (NOLOCK)
			LEFT JOIN dbo.dept_master AS DM WITH (NOLOCK)
			ON HRM.DEPT_CODE = DM.DEPT_CODE
		WHERE (@pMember_id IS NULL OR HRM.EMP_ID = @pMember_id)
		AND (@pMember_name IS NULL OR HRM.[NAME] LIKE '%' + @pMember_name + '%');

		SET @vSeverity = 0;
		SET @result_cd = 0;
		SET @result_msg = '성공';   
	END TRY
	BEGIN CATCH
		-- 실패 메시지
		SET @vSeverity = ERROR_SEVERITY();
		SET @result_cd = -1;
		SET @result_msg = ERROR_MESSAGE();
	END CATCH

	RETURN;
END


--- Procedure 32 ---
ProcedureName: spGetProjectHistory
ProcedureDefinition:

-- =============================================
-- Author:		jay kwon
-- Create date: 2025-07-15
-- Description:	사용 이력 조회
/*
DECLARE @result_cd INT, @result_msg VARCHAR(100), @total_count INT, @total_pages INT;
EXEC [dbo].[spGetProjectHistory] @pProject_id = 25080009, @pPage_no = 1, @pPage_size = 20, @total_count = @total_count OUTPUT, @total_pages = @total_pages OUTPUT, @result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT;
SELECT @result_cd AS result_cd, @result_msg AS result_msg, @total_count AS total_count, @total_pages AS total_pages;
*/
-- =============================================
CREATE PROCEDURE [dbo].[spGetProjectHistory]
	@pProject_id		INT				= NULL,
	@pPage_no			INT				= NULL,
	@pPage_size			INT				= NULL,
	@total_count		INT				OUTPUT,
	@total_pages		INT				OUTPUT,
    @result_cd			INT				OUTPUT,
    @result_msg			VARCHAR(200)	OUTPUT


AS
BEGIN
	
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	DECLARE @vResult TABLE(
		caller_id	VARCHAR(7),
		log_dt		VARCHAR(10),
		log_message	VARCHAR(200),
		created_at	DATETIME
	)
	DECLARE @vProject_name		VARCHAR(50) = NULL;
	DECLARE @vSeverity			INT = NULL;

	SELECT
		@vProject_name = P.project_name
	FROM dbo.project AS P WITH (NOLOCK)
	WHERE P.project_id = @pProject_id

	BEGIN TRY
		IF (@vProject_name IS NULL)
		BEGIN
			RAISERROR('프로젝트 확인 불가', 16, 1);
		END


		INSERT INTO @vResult
		SELECT
			UL.caller_id,
			UL.log_dt,
			UL.log_message,
			UL.created_at
		FROM dbo.use_log AS UL WITH (NOLOCK)
		WHERE UL.project_id = @pProject_id


		-- 전체 건수 계산
		SELECT @total_count = COUNT(*)
		FROM @vResult AS V

		-- 페이지 수 계산
		SET @total_pages = CASE 
			WHEN @pPage_size IS NULL OR @pPage_size = 0 THEN 1
			ELSE CEILING(CAST(@total_count AS FLOAT) / @pPage_size)
		END;

		SELECT
			@pProject_id		AS project_id,
			@vProject_name		AS project_name,
			R.caller_id			AS caller_id,
			HRM.[NAME]			AS member_name,
			R.log_dt			AS log_dt,
			R.log_message		AS log_message,
			R.created_at		AS created_at
		FROM @vResult AS R
			LEFT JOIN dbo.hr_master AS HRM WITH (NOLOCK)
			ON R.caller_id = HRM.EMP_ID
		ORDER BY R.created_at DESC		
		OFFSET (@pPage_no - 1) * @pPage_size ROWS
		FETCH NEXT @pPage_size ROWS ONLY;			


		SET @vSeverity = 0;
		SET @result_cd = 0;
		SET @result_msg = '성공';

	END TRY
	BEGIN CATCH
		SET @result_cd = -1;
		SET @vSeverity = ERROR_SEVERITY();
		SET @result_msg = ERROR_MESSAGE();
	END CATCH

	RETURN;
END


--- Procedure 33 ---
ProcedureName: spGetCodeMaster
ProcedureDefinition:
-- =============================================
-- Author:		Jay Kwon
-- Create date: 2025-05-28
-- Description:	코드마스터 검색
/*

DECLARE @result_cd INT, @result_msg VARCHAR(100), @total_count INT, @total_pages INT;
EXEC [dbo].[spGetCodeMaster] @pGroup_cd = '20100', @pGroup_name = NULL, @pDetail_cd = NULL, @pDetail_name = NULL, @pPage_no = 1, @pPage_size= 20, @result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT, @total_count = @total_count OUTPUT, @total_pages = @total_pages OUTPUT;
SELECT @result_cd AS result_cd, @result_msg AS result_msg, @total_count AS total_count, @total_pages AS total_pages;

*/

-- =============================================
CREATE PROCEDURE [dbo].[spGetCodeMaster]
	@pGroup_cd			VARCHAR(8)			= null,
	@pGroup_name		VARCHAR(50)			= null,
	@pDetail_cd			VARCHAR(8)			= NULL,
	@pDetail_name		VARCHAR(50)			= NULL,
	@pPage_no			INT				= NULL,
	@pPage_size			INT				= NULL,
    @result_cd			INT				OUTPUT,
    @result_msg			VARCHAR(200)	OUTPUT,
	@total_count		INT				OUTPUT,
	@total_pages		INT				OUTPUT
AS
BEGIN
	
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	BEGIN TRY
	


		IF (@pGroup_cd = '20100')
		BEGIN
			-- 전체 레코드 수 계산
			SELECT @total_count = COUNT(*)
			FROM dbo.code_master AS CM WITH (NOLOCK)
			WHERE (@pGroup_cd IS NULL	OR CM.group_cd IN ('20001', '20002'))
			AND (@pGroup_name IS NULL	OR CM.group_name LIKE '%' + @pGroup_name + '%')
			AND (@pDetail_cd IS NULL	OR CM.detail_cd = @pDetail_cd)
			AND (@pDetail_name IS NULL	OR CM.detail_name LIKE '%' + @pDetail_name + '%')
			AND CM.group_cd < '90000';

			-- 전체 페이지 수 계산
			SET @total_pages = CASE 
				WHEN @pPage_size IS NULL OR @pPage_size = 0 THEN 1
				ELSE CEILING(CAST(@total_count AS FLOAT) / @pPage_size)
			END;

			SELECT
				CM.master_id,
				CM.group_cd,
				CM.group_name,
				CM.detail_cd,
				CM.detail_name,
				CM.is_active_cd,
				dbo.fnGetDetailNameByDetailCode('90100', CM.is_active_cd) AS is_active_name,			
				CM.creator_id,
				CM.created_at,
				CM.modifier_id,
				CM.modified_at
			FROM dbo.code_master AS CM WITH (NOLOCK)
			WHERE (@pGroup_cd IS NULL	OR CM.group_cd IN ('20001', '20002'))
			AND (@pGroup_name IS NULL	OR CM.group_name LIKE '%' + @pGroup_name + '%')
			AND (@pDetail_cd IS NULL	OR CM.detail_cd = @pDetail_cd)
			AND (@pDetail_name IS NULL	OR CM.detail_name LIKE '%' + @pDetail_name + '%')		
			AND CM.is_active_cd = '10'
			ORDER BY group_cd, detail_cd
			OFFSET (@pPage_no - 1) * @pPage_size ROWS
			FETCH NEXT @pPage_size ROWS ONLY;	
		END
		ELSE
		BEGIN

			-- 전체 레코드 수 계산
			SELECT @total_count = COUNT(*)
			FROM dbo.code_master AS CM WITH (NOLOCK)
			WHERE (@pGroup_cd IS NULL	OR CM.group_cd = @pGroup_cd)
			AND (@pGroup_name IS NULL	OR CM.group_name LIKE '%' + @pGroup_name + '%')
			AND (@pDetail_cd IS NULL	OR CM.detail_cd = @pDetail_cd)
			AND (@pDetail_name IS NULL	OR CM.detail_name LIKE '%' + @pDetail_name + '%')
			AND CM.group_cd < '90000';

			-- 전체 페이지 수 계산
			SET @total_pages = CASE 
				WHEN @pPage_size IS NULL OR @pPage_size = 0 THEN 1
				ELSE CEILING(CAST(@total_count AS FLOAT) / @pPage_size)
			END;

			SELECT
				CM.master_id,
				CM.group_cd,
				CM.group_name,
				CM.detail_cd,
				CM.detail_name,
				CM.is_active_cd,
				dbo.fnGetDetailNameByDetailCode('90100', CM.is_active_cd) AS is_active_name,			
				CM.creator_id,
				CM.created_at,
				CM.modifier_id,
				CM.modified_at
			FROM dbo.code_master AS CM WITH (NOLOCK)
			WHERE (@pGroup_cd IS NULL	OR CM.group_cd = @pGroup_cd)
			AND (@pGroup_name IS NULL	OR CM.group_name LIKE '%' + @pGroup_name + '%')
			AND (@pDetail_cd IS NULL	OR CM.detail_cd = @pDetail_cd)
			AND (@pDetail_name IS NULL	OR CM.detail_name LIKE '%' + @pDetail_name + '%')		
			AND CM.is_active_cd = '10'
			ORDER BY group_cd, detail_cd
			OFFSET (@pPage_no - 1) * @pPage_size ROWS
			FETCH NEXT @pPage_size ROWS ONLY;	
		END

		SET @result_cd = 0
		SET @result_msg = '성공'

	END TRY
	BEGIN CATCH
		SET @result_cd = -1;
		SET @result_msg = ERROR_MESSAGE();
		SET @total_count = 0;
		SET @total_pages = 0;
	END CATCH
	
END


--- Procedure 34 ---
ProcedureName: spGetDeptCdByName
ProcedureDefinition:

-- =============================================
-- Author:		Jay Kwon
-- Create date: 2025-07-17
-- Description:	부서명으로 부서 코드를 가져온다.
/*
DECLARE @result_project_id INT, @result_cd INT, @result_msg VARCHAR(100);
EXEC [dbo].[spGetDeptCdByName] @pDept_name = '푸드사업부', @result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT;
SELECT @result_cd as result_cd, @result_msg as result_msg;
*/
-- =============================================
CREATE PROCEDURE [dbo].[spGetDeptCdByName]
	@pDept_name		VARCHAR(100)	= NULL,
    @result_cd		INT				OUTPUT,
    @result_msg		VARCHAR(200)	OUTPUT
AS
BEGIN

	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

    SELECT
		DM.DEPT_CODE,
		DM.DEPT_NAME
	FROM dbo.dept_master AS DM WITH (NOLOCK)
	WHERE DM.DEPT_NAME LIKE '%' + @pDept_name + '%';

	SET @result_cd = 0;
	SET @result_msg = '성공';   

	RETURN;
END


--- Procedure 35 ---
ProcedureName: spGetOutputListForTask
ProcedureDefinition:
-- =============================================
-- Author:		Jay Kwon
-- Create date: 2025-05-28
-- Description:	TASK에 연결된 산출물 목록을 가져온다.
/*
DECLARE @result_cd INT, @result_msg VARCHAR(100);
EXEC [dbo].[spGetOutputListForTask] @pTask_id = 15, @result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT;
SELECT @result_cd as result_cd, @result_msg as result_msg;
*/

-- =============================================
CREATE PROCEDURE [dbo].[spGetOutputListForTask]
	@pTask_id			INT = null,
	@result_cd			INT				OUTPUT,
    @result_msg			VARCHAR(200)	OUTPUT
AS
BEGIN	

	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	-- 파라미터 유효성 체크
    IF NOT EXISTS(SELECT 1 FROM dbo.task AS T WITH (NOLOCK) WHERE T.task_id = @pTask_id)
    BEGIN		
		SET @result_cd = 1;
		SET @result_msg = '존재하지 않는 태스크 입니다.';
        RETURN;	
    END

	BEGIN TRY
		SELECT
			T.output_id,
			T.task_id,
			T.project_id,
			T.file_name,
			T.file_path,
			T.is_active_cd,
			T.output_comment,
			T.creator_id,
			T.created_at,
			T.modifier_id,
			T.modified_at
		FROM dbo.task_output AS T WITH (NOLOCK)
		WHERE T.task_id = @pTask_id
		AND T.is_active_cd = '10';

		SET @result_cd = 0;
		SET @result_msg = '성공';

	END TRY
	BEGIN CATCH
		SET @result_cd = -1;
		SET @result_msg = ERROR_MESSAGE();
	END CATCH	
END


--- Procedure 36 ---
ProcedureName: spGetDeptAuth
ProcedureDefinition:

-- =============================================
-- Author:		Jay Kwon
-- Create date: 2025-07-17
-- Description:	부서 권한 조회
/*
DECLARE @result_project_id INT, @result_cd INT, @result_msg VARCHAR(100);
EXEC [dbo].[spGetDeptAuth] @pDept_cd = '12020102', @result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT;
SELECT @result_cd as result_cd, @result_msg as result_msg;
*/
-- =============================================
CREATE PROCEDURE [dbo].[spGetDeptAuth]
	@pDept_cd		VARCHAR(8) = NULL,
    @result_cd		INT				OUTPUT,
    @result_msg		VARCHAR(200)	OUTPUT
AS
BEGIN

	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;


    SELECT
		DA.dept_cd				AS dept_cd,
		DM.DEPT_NAME			AS dept_name,
		DA.dept_auth_cd			AS dept_auth_cd,
		dbo.fnGetDetailNameByDetailCode( '90000', DA.dept_auth_cd) AS dept_auth_name
	FROM dbo.dept_auth AS DA WITH (NOLOCK)
		INNER JOIN dbo.dept_master AS DM WITH (NOLOCK)
		ON DA.dept_cd = DM.DEPT_CODE
	WHERE DA.dept_cd = @pDept_cd;

	SET @result_cd = 0;
	SET @result_msg = '성공';   

	RETURN;
END


--- Procedure 37 ---
ProcedureName: spGetProjectApplicants
ProcedureDefinition:


-- =============================================
-- Author:		JayKwon
-- Create date: 2025-05-23
-- Description:	프로젝트에 참여 신청 목록을 가져온다.
/*
프로젝트 참여 신청	10	승인　20	신청　90	반려

DECLARE @result_cd INT, @result_msg VARCHAR(100), @total_count INT, @total_pages INT;
EXEC [dbo].[spGetProjectApplicants] @pProject_id = NULL, @pProject_name = NULL, @pProject_owner_id = '2400016', @pPage_no = 1, @pPage_size = 20, @result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT, @total_count = @total_count OUTPUT, @total_pages = @total_pages OUTPUT;
SELECT @result_cd AS result_cd, @result_msg AS result_msg, @total_count AS total_count, @total_pages AS total_pages;
*/
-- =============================================
CREATE PROCEDURE [dbo].[spGetProjectApplicants]
    @pProject_id		INT				= NULL,
	@pProject_name		VARCHAR(50)		= NULL,
	@pProject_owner_id	VARCHAR(7)		= NULL,
	@pPage_no				INT			= NULL,
	@pPage_size				INT			= NULL,
    @result_cd			INT				OUTPUT,
    @result_msg			VARCHAR(200)	OUTPUT,
	@total_count		INT				OUTPUT,
	@total_pages		INT				OUTPUT
AS
BEGIN

	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	-- 파라미터 유효성 체크
    IF ((@pProject_id IS NOT NULL) AND NOT EXISTS(SELECT 1 FROM dbo.project AS P WITH (NOLOCK) WHERE P.project_id = @pProject_id))
    BEGIN		
		SET @result_cd = 1
		SET @result_msg = '존재하지 않는 프로젝트 입니다.'
        RETURN;	
    END
	
	DECLARE @vTarget TABLE(
		project_id		INT,
		project_name	VARCHAR(50)
	)


	BEGIN TRY
		-- 대상 프로젝트 추출
		INSERT INTO @vTarget
		SELECT
			P.project_id,
			P.project_name
		FROM dbo.project AS P WITH (NOLOCK)
			LEFT JOIN dbo.project_owner	AS PO WITH (NOLOCK)
			ON P.project_id = PO.project_id
		WHERE (@pProject_id IS NULL OR P.project_id = @pProject_id)
		AND (@pProject_name IS NULL OR P.project_name LIKE  '%' + @pProject_name + '%')		
		AND (@pProject_owner_id IS NULL OR PO.member_id = @pProject_owner_id)
		GROUP BY P.project_id, P.project_name;

		-- 전체 건수 계산
		SELECT @total_count = COUNT(*)
		FROM @vTarget AS V
			INNER JOIN dbo.project_member AS PM WITH (NOLOCK)
			ON V.project_id = PM.project_id
		WHERE PM.status_cd = '20';


		-- 페이지 수 계산
		SET @total_pages = CASE 
			WHEN @pPage_size IS NULL OR @pPage_size = 0 THEN 1
			ELSE CEILING(CAST(@total_count AS FLOAT) / @pPage_size)
		END;

		SELECT
			V.project_id,
			V.project_name,
			PM.member_id,
			MI.[NAME] AS member_name,
			ODM.DEPT_CODE AS dept_cd,
			ODM.DEPT_NAME AS dept_name,
			PM.status_cd,
			dbo.fnGetDetailNameByDetailCode('90102', PM.status_cd) AS status_name,
			PM.creator_id,
			(SELECT MI.[NAME] FROM dbo.hr_master AS MI WITH (NOLOCK) WHERE MI.EMP_ID = PM.creator_id) AS creator_name,			
			POM.owner_names,
			PM.created_at
		FROM @vTarget AS V
			INNER JOIN dbo.project_member AS PM WITH (NOLOCK)
			ON V.project_id = PM.project_id
			LEFT JOIN dbo.hr_master AS MI WITH (NOLOCK)
			ON PM.member_id = MI.EMP_ID
			LEFT JOIN dbo.dept_master AS ODM WITH (NOLOCK)
			ON MI.DEPT_CODE = ODM.DEPT_CODE
			LEFT JOIN (	SELECT 
							PO.project_id,
							STRING_AGG(CAST(MI.[NAME] AS VARCHAR), ', ') AS owner_names
						FROM dbo.project_owner AS PO WITH (NOLOCK)
							INNER JOIN dbo.hr_master AS MI WITH (NOLOCK)
							ON PO.member_id = MI.EMP_ID
						WHERE PO.is_active_cd = '10'
						GROUP BY project_id) POM			
			ON V.project_id = POM.project_id
		WHERE PM.status_cd = '20' -- 신청 상태인 것만
		ORDER BY PM.created_at DESC
		OFFSET (@pPage_no - 1) * @pPage_size ROWS
		FETCH NEXT @pPage_size ROWS ONLY;	

		SET @result_cd = 0;
		SET @result_msg = '성공';
	END TRY
	BEGIN CATCH
		SET @result_cd = -1;
		SET @result_msg = ERROR_MESSAGE();
		SET @total_count = 0;
		SET @total_pages = 0;
	END CATCH

END



--- Procedure 38 ---
ProcedureName: spGetProjectList
ProcedureDefinition:

-- =============================================
-- Author:		JayKwon
-- Create date: 2025-05-19
-- Description:	get Project List
-- SAMPLE EXEC
/*
-- 전체 조회
DECLARE @rc INT, @msg VARCHAR(100), @cnt INT, @pages INT;
EXEC [dbo].[spGetProjectList] @pProject_name = NULL, @pProject_member_id = NULL, @pProject_ids = NULL, @pExclude_fin_project = NULL, @pMy_member_id = NULL, @pPage_no = 1, @pPage_size = 20, @result_cd = @rc OUTPUT, @result_msg = @msg OUTPUT, @total_count = @cnt OUTPUT, @total_pages = @pages OUTPUT;
SELECT @rc AS result_cd, @msg AS result_msg, @cnt AS total_count, @pages AS total_pages;

select * from code_master
-- 프로젝트 명 조회
DECLARE @rc INT, @msg VARCHAR(100), @cnt INT, @pages INT;
EXEC [dbo].[spGetProjectList] @pProject_name = '권프', @pProject_member_id = NULL, @pProject_ids = NULL, @pExclude_fin_project = NULL, @pMy_member_id = NULL, @pPage_no = 1, @pPage_size = 20, @result_cd = @rc OUTPUT, @result_msg = @msg OUTPUT, @total_count = @cnt OUTPUT, @total_pages = @pages OUTPUT;
SELECT @rc AS result_cd, @msg AS result_msg, @cnt AS total_count, @pages AS total_pages;

-- 프로젝트 id 조회
DECLARE @rc INT, @msg VARCHAR(100), @cnt INT, @pages INT;
EXEC [dbo].[spGetProjectList] @pProject_name = NULL, @pProject_member_id = 23, @pProject_ids = '3,4,5,6,7,8,9', @pExclude_fin_project = NULL, @pMy_member_id = NULL, @pPage_no = 1, @pPage_size = 20, @result_cd = @rc OUTPUT, @result_msg = @msg OUTPUT, @total_count = @cnt OUTPUT, @total_pages = @pages OUTPUT;
SELECT @rc AS result_cd, @msg AS result_msg, @cnt AS total_count, @pages AS total_pages;

-- 담당자로 조회
DECLARE @rc INT, @msg VARCHAR(100), @cnt INT, @pages INT;
EXEC [dbo].[spGetProjectList] @pProject_name = NULL, @pProject_member_id = NULL, @pProject_ids = NULL, @pExclude_fin_project = NULL, @pMy_member_id = '2400002', @pPage_no = 1, @pPage_size = 20, @result_cd = @rc OUTPUT, @result_msg = @msg OUTPUT, @total_count = @cnt OUTPUT, @total_pages = @pages OUTPUT;
SELECT @rc AS result_cd, @msg AS result_msg, @cnt AS total_count, @pages AS total_pages;

*/
-- =============================================
CREATE PROCEDURE [dbo].[spGetProjectList]
    @pProject_name			VARCHAR(50)		= NULL,	-- 데이터를 안넣고 던지면 전체 조회
	@pProject_member_id		VARCHAR(7)		= NULL,	-- 프로젝트 담당자 id 로 조회
    @pProject_ids			VARCHAR(MAX)	= NULL, -- project_id --> project_ids로 변경
	@pExclude_fin_project	INT				= NULL, -- 1로 던지면 완료 프로젝트 제외
	@pMy_member_id			VARCHAR(7)		= NULL,	
	@pPage_no				INT				= NULL,
	@pPage_size				INT				= NULL,
	@result_cd				INT				OUTPUT,
    @result_msg				VARCHAR(200)	OUTPUT,
	@total_count			INT				OUTPUT,
	@total_pages			INT				OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

    DECLARE @ParsedProjectIds TABLE (project_id INT);

    -- CSV 문자열 파싱
    IF @pProject_ids IS NOT NULL
    BEGIN
        INSERT INTO @ParsedProjectIds (project_id)
        SELECT TRY_CAST(value AS INT)
        FROM STRING_SPLIT(@pProject_ids, ',')
        WHERE TRY_CAST(value AS INT) IS NOT NULL
    END

    DECLARE @TargetProject TABLE(project_id INT);

    DECLARE @ProjectResult TABLE (
        project_id               INT,
        project_type_cd          VARCHAR(8),
        project_type_name        VARCHAR(50),
        line_cd                  VARCHAR(8),
        line_name                VARCHAR(50),
        brand_cd                 VARCHAR(8),
        brand_name               VARCHAR(50),
        fml_brand_cd             VARCHAR(8),
        fml_brand_name           VARCHAR(50),
        work_type_cd             VARCHAR(8),
        work_type_name           VARCHAR(50),
        project_name             VARCHAR(50),
        project_state_cd         VARCHAR(8),
        project_state            VARCHAR(50),
        planed_start_dt          VARCHAR(10),
        planed_end_dt            VARCHAR(10),
        owner_ids                VARCHAR(MAX),
        member_names             VARCHAR(MAX),
        planed_working_day       INT,
        progress_rate_actual     VARCHAR(50),
        progress_rate_plan       VARCHAR(50),
        is_active                VARCHAR(8),
        is_active_name           VARCHAR(50),
        kick_off_cd              VARCHAR(8),
        kick_off_name            VARCHAR(50),

        forced_end_dt            VARCHAR(10),
        forced_end_reason        VARCHAR(200),

        creator_id               VARCHAR(7),
        creator_name             VARCHAR(20),
        created_at               DATETIME,
        modifier_id              VARCHAR(7),
        modified_at              DATETIME
    );

    -- 내것만 보기설정이 된 경우
    IF (@pMy_member_id IS NOT NULL)
    BEGIN
        INSERT INTO @TargetProject
        SELECT
            PO.project_id
        FROM dbo.project_owner AS PO WITH (NOLOCK)
        WHERE PO.member_id = @pMy_member_id
        AND PO.is_active_cd = '10'
        UNION
        SELECT
            PM.project_id
        FROM dbo.project_member AS PM WITH (NOLOCK)
        WHERE PM.member_id = @pMy_member_id
        AND PM.status_cd = '10' -- 승인된 사람기준
    END
    ELSE
    BEGIN
        INSERT INTO @TargetProject
        SELECT P.project_id
        FROM dbo.project AS P WITH (NOLOCK)
        WHERE P.project_type_cd = '10'
            AND (@pProject_name IS NULL OR P.project_name LIKE '%' + @pProject_name + '%')
            AND (@pProject_member_id IS NULL OR P.project_id IN (
                SELECT 
                DISTINCT PM.project_id
                FROM dbo.project_member AS PM WITH (NOLOCK)
                WHERE PM.member_id = @pProject_member_id AND PM.status_cd = '10'          
                UNION
                SELECT 
                DISTINCT PO.project_id
                FROM dbo.project_owner AS PO WITH (NOLOCK)
                WHERE PO.member_id = @pProject_member_id AND PO.is_active_cd = '10'          
            ))
            AND (
                @pProject_ids IS NULL
                OR P.project_id IN (SELECT project_id FROM @ParsedProjectIds)
            );
    END
    
    


    BEGIN TRY
        INSERT INTO @ProjectResult
        SELECT
            p.project_id,
            p.project_type_cd,
            dbo.fnGetDetailNameByDetailCode('90200', p.project_type_cd),
            p.line_cd,
            --dbo.fnGetDetailNameByDetailCode('20100', p.line_cd),            
            CM.detail_name AS line_name,
            p.brand_cd,
            dbo.fnGetDetailNameByBrandCode('NB', p.brand_cd),
            p.fml_brand_cd,
            dbo.fnGetDetailNameByBrandCode('FB', p.fml_brand_cd),
            p.work_type_cd,
            dbo.fnGetDetailNameByDetailCode('20103', p.work_type_cd),
            p.project_name,
            dbo.fnGetProjectState(p.project_id),
            dbo.fnGetDetailNameByDetailCode('90302', CAST(dbo.fnGetProjectState(p.project_id) AS VARCHAR(8))),
            p.planed_start_dt,
            p.planed_end_dt,
            PO1.owner_ids,
            PM1.member_names,
            p.planed_working_day,
            dbo.fnGetProjectProgressRateActual(p.project_id),
            dbo.fnGetProjectProgressRatePlan(p.project_id),
            p.is_active,
            dbo.fnGetDetailNameByDetailCode('90100', p.is_active),
            p.kick_off_cd,
            dbo.fnGetDetailNameByDetailCode('90104', p.kick_off_cd),
            p.forced_end_dt,
            p.forced_end_reason,

            p.creator_id,
            MI.[NAME],
            p.created_at,
            p.modifier_id,
            p.modified_at
        FROM dbo.project p WITH (NOLOCK)
            INNER JOIN @TargetProject TP
            ON p.project_id = TP.project_id
            LEFT JOIN dbo.hr_master AS MI WITH (NOLOCK)
            ON p.creator_id = MI.EMP_ID
            LEFT JOIN (
                        SELECT 
                            PM.project_id,
                            STRING_AGG(CAST(MI.[NAME] AS VARCHAR), ', ') AS member_names
                        FROM dbo.project_member AS PM WITH (NOLOCK)
                            INNER JOIN dbo.hr_master AS MI WITH (NOLOCK)
                            ON PM.member_id = MI.EMP_ID
                        WHERE PM.status_cd = '10'
                        GROUP BY PM.project_id) PM1 
            ON p.project_id = PM1.project_id
            LEFT JOIN (
                        SELECT 
                            PO.project_id,
                            STRING_AGG(CAST(MI.EMP_ID AS VARCHAR), ', ') AS owner_ids
                        FROM dbo.project_owner AS PO WITH (NOLOCK)
                            INNER JOIN dbo.hr_master AS MI WITH (NOLOCK)
                            ON PO.member_id = MI.EMP_ID
                        WHERE PO.is_active_cd = '10'
                        GROUP BY PO.project_id) PO1 
            ON p.project_id = PO1.project_id
            LEFT JOIN dbo.code_master AS CM WITH (NOLOCK)
            ON p.line_cd = CM.detail_cd
            AND CM.group_cd IN ('20001','20002')
        WHERE (@pExclude_fin_project IS NULL OR dbo.fnGetProjectState(p.project_id) NOT IN ('90', '91'));


        -- 페이징 계산
        SELECT @total_count = COUNT(*) FROM @ProjectResult;
        SET @total_pages = CASE
            WHEN @pPage_size IS NULL OR @pPage_size = 0 THEN 1
            ELSE CEILING(CAST(@total_count AS FLOAT) / @pPage_size)
        END;

        -- 결과 반환
        SELECT
            RT.project_id,
            RT.project_type_cd,
            RT.project_type_name,
            RT.line_cd,
            RT.line_name,
            RT.brand_cd,
            RT.brand_name,
            RT.fml_brand_cd,
            RT.fml_brand_name,
            RT.work_type_cd,
            RT.work_type_name,
            RT.project_name,
            RT.project_state_cd,
            RT.project_state,
            CASE WHEN RT.project_state = '지연' THEN 4
                 WHEN RT.project_state = '정상' THEN 3
                 WHEN RT.project_state = '착수전' THEN 2
                 WHEN RT.project_state = '완료' THEN 1
                 ELSE 0
            END AS project_state_ordering,
            RT.planed_start_dt,
            RT.planed_end_dt,
            RT.owner_ids,
            RT.member_names,
            RT.planed_working_day,
            (SELECT SUM(ISNULL(TFP.working_day,0))
             FROM dbo.task_finish_plan AS TFP WITH (NOLOCK) 
             WHERE TFP.plan_cd = '10' 
             AND TFP.project_id = RT.project_id 
             GROUP BY TFP.project_id) AS std_working_day,

            RT.progress_rate_actual,
            RT.progress_rate_plan,
            RT.is_active,
            RT.is_active_name,
            RT.kick_off_cd,
            RT.kick_off_name,
            dbo.fnGetCurrentTaskId(RT.project_id) AS current_task_id,
            dbo.fnGetStateForKickOff(RT.project_id) AS kick_off_available_cd,
            (SELECT T.task_name 
             FROM dbo.task AS T WITH (NOLOCK) 
             WHERE T.task_id = dbo.fnGetCurrentTaskId(RT.project_id)) AS current_task_name,

            RT.forced_end_dt,
            RT.forced_end_reason,
            
            RT.creator_id,
            RT.creator_name,
            RT.created_at,
            RT.modifier_id,
            RT.modified_at,
            @total_count AS total_count,
            @total_pages AS total_pages
        FROM @ProjectResult AS RT
        ORDER BY RT.planed_start_dt DESC, project_state_ordering DESC
        OFFSET (@pPage_no - 1) * @pPage_size ROWS
        FETCH NEXT @pPage_size ROWS ONLY;

        SET @result_cd = 0;
        SET @result_msg = '성공';
    END TRY
    BEGIN CATCH
        SET @result_cd = -1;
        SET @result_msg = ERROR_MESSAGE();
        SET @total_count = 0;
        SET @total_pages = 0;
    END CATCH
END


--- Procedure 39 ---
ProcedureName: spGetProjectOwnerList
ProcedureDefinition:
-- =============================================
-- Author:		Jay Kwon
-- Create date: 2025-06-09
-- Description:	프로젝트의 담당자 조회
/* 실행 예제
DECLARE @result_cd INT, @result_msg VARCHAR(100);
EXEC  [dbo].[spGetProjectOwnerList] @pProject_id = 25080015, @result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT;
SELECT @result_cd as result_cd, @result_msg as result_msg;
*/
-- =============================================
CREATE PROCEDURE [dbo].[spGetProjectOwnerList]
	@pProject_id		INT,
    @result_cd			INT				OUTPUT,
    @result_msg			VARCHAR(200)	OUTPUT
AS
BEGIN
	
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	-- 파라미터 유효성 체크
    IF NOT EXISTS(SELECT 1 FROM dbo.project AS P WITH (NOLOCK) WHERE P.project_id = @pProject_id)
    BEGIN		
		SET @result_cd = 1
		SET @result_msg = '존재하지 않는 프로젝트 입니다.'
        RETURN;	
    END

	BEGIN TRY
		SELECT
			P.project_id,
			P.project_name,								
			MI.EMP_ID AS member_id,
			MI.[NAME] AS member_name,
			ODM.DEPT_CODE,
			ODM.DEPT_NAME
		FROM dbo.project AS P WITH (NOLOCK)
			INNER JOIN dbo.project_owner AS PO WITH (NOLOCK)
			ON P.project_id = PO.project_id
			LEFT JOIN dbo.hr_master AS MI WITH (NOLOCK)
			ON PO.member_id = MI.EMP_ID		
			LEFT JOIN dbo.dept_master AS ODM WITH (NOLOCK)
			ON MI.DEPT_CODE = ODM.DEPT_CODE
		WHERE P.project_id = @pProject_id
		AND PO.is_active_cd = '10';
		
		SET @result_cd = 0
		SET @result_msg = '성공'
	END TRY
	BEGIN CATCH
		SET @result_cd = -1
		SET @result_msg = ERROR_MESSAGE()
	END CATCH
END


--- Procedure 40 ---
ProcedureName: spGetProjectProgressRate
ProcedureDefinition:
-- =============================================
-- Author:		Jay Kwon
-- Create date: 2025-05-29
-- Description:	프로젝트 공정률 계산
/*
DECLARE @result_cd INT, @result_msg VARCHAR(100);
EXEC [dbo].[spGetProjectProgressRate] @pProject_id = 25080054,@result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT;
SELECT @result_cd as result_cd, @result_msg as result_msg;
*/
-- =============================================
CREATE PROCEDURE [dbo].[spGetProjectProgressRate]
	@pProject_id		INT = null,
	@result_cd			INT				OUTPUT,
    @result_msg			VARCHAR(200)	OUTPUT
AS
BEGIN
	
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;	

	-- 파라미터 유효성 체크
    IF NOT EXISTS(SELECT 1 FROM dbo.project AS P WITH (NOLOCK) WHERE P.project_id = @pProject_id)
    BEGIN		
		SET @result_cd = 1;
		SET @result_msg = '존재하지 않는 프로젝트 입니다.';
        RETURN;	
    END

	DECLARE @now_dt AS VARCHAR(10) = CONVERT(VARCHAR(10), GETDATE(), 121);
	

	-- 지연 일수 계산 (계획 최대 종료일 VS 실제 최대 종료일)
	DECLARE @vMax_planed_end_dt		VARCHAR(10) = NULL, @vMax_actual_end_dt		VARCHAR(10) = NULL;
	
	SELECT
		@vMax_planed_end_dt = MAX(TFP.end_dt)
	FROM dbo.task_finish_plan AS TFP WITH (NOLOCK)
	WHERE TFP.project_id = @pProject_id
	AND TFP.plan_cd = '20'
	GROUP BY TFP.project_id

	SELECT
		@vMax_actual_end_dt = MAX(TFP.end_dt)
	FROM dbo.task_finish_plan AS TFP WITH (NOLOCK)
	WHERE TFP.project_id = @pProject_id
	AND TFP.plan_cd = '30'
	GROUP BY TFP.project_id


	

	BEGIN TRY
		SELECT
			P.project_id,
			P.project_name,
			dbo.fnGetProjectProgressRateActual(@pProject_id)					AS actual_rate,
			dbo.fnGetProjectProgressRatePlan(@pProject_id)						AS planed_rate,
			ISNULL(D.delayed_tasks,0)											AS delayed_tasks,
			(dbo.fnCalcWorkingDay(@vMax_planed_end_dt,@vMax_actual_end_dt) - 1) AS delayed_days
		FROM dbo.project AS P WITH (NOLOCK)
			LEFT JOIN (
						SELECT
							T.project_id,
							COUNT(*) AS delayed_tasks
						FROM task AS T WITH (NOLOCK)
						WHERE T.project_id = @pProject_id
						AND T.status_cd = '30'	-- 10 대기, 20 진행, 30 지연, 90 완료
						GROUP BY T.project_id
						) D
			ON P.project_id = D.project_id
		WHERE P.project_id = @pProject_id;

		SET @result_cd = 0;
		SET @result_msg = '성공';

	END TRY
	BEGIN CATCH
		SET @result_cd = -1;
		SET @result_msg = ERROR_MESSAGE();
	END CATCH
END


--- Procedure 41 ---
ProcedureName: spGetProjectTemplateList
ProcedureDefinition:

-- =============================================
-- Author:		jaykwon
-- Create date: 2025-06-23
-- Description:	프로젝트 템플릿 목록 조회
/*

DECLARE @result_cd INT, @result_msg VARCHAR(100), @total_count INT, @total_pages INT;
EXEC [dbo].[spGetProjectTemplateList] @pProject_name = NULL, @pPage_no = 1, @pPage_size = 20, @result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT, @total_count = @total_count OUTPUT, @total_pages = @total_pages OUTPUT;
SELECT @result_cd AS result_cd, @result_msg AS result_msg, @total_count AS total_count, @total_pages AS total_pages;

*/
-- =============================================
CREATE PROCEDURE [dbo].[spGetProjectTemplateList]
	@pProject_name			VARCHAR(50)		= NULL,
	@pPage_no				INT				= NULL,
	@pPage_size				INT				= NULL,
    @result_cd				INT				OUTPUT,
    @result_msg				VARCHAR(200)	OUTPUT,
	@total_count			INT				OUTPUT,
	@total_pages			INT				OUTPUT
AS
BEGIN
	
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	BEGIN TRY

		-- 전체 템플릿 개수 계산
		SELECT @total_count = COUNT(*)
		FROM dbo.project AS P WITH (NOLOCK)
		WHERE (@pProject_name IS NULL OR P.project_name LIKE '%' + @pProject_name + '%')
		AND P.project_type_cd = '90'
		AND P.is_active = '10';

		-- 페이지 수 계산
		SET @total_pages = CASE 
			WHEN @pPage_size IS NULL OR @pPage_size = 0 THEN 1
			ELSE CEILING(CAST(@total_count AS FLOAT) / @pPage_size)
		END;

		SELECT
			P.project_id,
			P.project_type_cd,
			P.work_type_cd,
			dbo.fnGetDetailNameByDetailCode('20103', P.work_type_cd) AS work_type_name,
			dbo.fnGetProjectWorkingDayByType(P.project_id, '10') AS std_working_day,
			P.project_name,		
			P.creator_id,			
			(SELECT M.[NAME] FROM dbo.hr_master AS M WITH (NOLOCK) WHERE M.EMP_ID = P.creator_id) AS creator_name,
			P.created_at,
			P.modifier_id,			
			(SELECT M.[NAME] FROM dbo.hr_master AS M WITH (NOLOCK) WHERE M.EMP_ID = P.modifier_id) AS modifier_name,
			P.modified_at
		FROM dbo.project AS P WITH (NOLOCK)
		WHERE (@pProject_name IS NULL OR P.project_name LIKE '%' + @pProject_name + '%')
		AND P.project_type_cd = '90'
		AND P.is_active = '10'
		ORDER BY P.created_at DESC
		OFFSET (@pPage_no - 1) * @pPage_size ROWS
		FETCH NEXT @pPage_size ROWS ONLY;	

		SET @result_cd = 0;
		SET @result_msg = '성공';
	END TRY
	BEGIN CATCH
		SET @result_cd = -1;
		SET @result_msg = ERROR_MESSAGE();
		SET @total_count = 0;
		SET @total_pages = 0;	
	END CATCH
END


--- Procedure 42 ---
ProcedureName: spGetTaskInfoDetail
ProcedureDefinition:

-- =============================================
-- Author:		Jay Kwon
-- Create date: 2025-05-27
-- Description:	태스크의 상세 정보를 가져온다.
/*
DECLARE @result_cd INT, @result_msg VARCHAR(100);
EXEC [dbo].[spGetTaskInfoDetail] @pTask_id = 6, @result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT;
SELECT @result_cd as result_cd, @result_msg as result_msg;
*/
-- =============================================
CREATE PROCEDURE [dbo].[spGetTaskInfoDetail]
	@pTask_id			INT = null,
	@result_cd			INT				OUTPUT,
    @result_msg			VARCHAR(200)	OUTPUT
AS
BEGIN
	
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
	
	DECLARE @vProject_id		INT = NULL;
	DECLARE @vSeverity			INT = NULL;

	SELECT 
		@vProject_id = T.project_id
	FROM dbo.task AS T WITH (NOLOCK)
	WHERE T.task_id = @pTask_id
	GROUP BY T.project_id;

	-- 파라미터 유효성 체크
    IF NOT EXISTS(SELECT 1 FROM dbo.task AS T WITH (NOLOCK) WHERE T.task_id = @pTask_id)
    BEGIN
		RAISERROR('존재하지 않는 태스크 입니다.', 11, 1);			
    END

	BEGIN TRY
		WITH RankedDelay AS (
			SELECT 
				task_id,
				end_dt,
				delay_reason_cd,
				delay_reason,
				ROW_NUMBER() OVER (PARTITION BY task_id ORDER BY end_dt) AS rn
			FROM dbo.task_finish_plan WITH (NOLOCK)
			WHERE plan_cd = '40'
			AND task_id = @pTask_id
			AND project_id = @vProject_id
		),
		DelayPivot AS (
		SELECT 
			task_id,
			[delay_dt_01], [delay_dt_02], [delay_dt_03], [delay_dt_04], [delay_dt_05],
			[delay_dt_06], [delay_dt_07], [delay_dt_08], [delay_dt_09], [delay_dt_10]
		FROM (
			SELECT 
				task_id,
				end_dt,
				CONCAT('delay_dt_', RIGHT('00' + CAST(rn AS VARCHAR), 2)) AS colname
			FROM RankedDelay
			WHERE rn <= 10
		) AS src
		PIVOT (
			MAX(end_dt) FOR colname IN (
				[delay_dt_01], [delay_dt_02], [delay_dt_03], [delay_dt_04], [delay_dt_05],
				[delay_dt_06], [delay_dt_07], [delay_dt_08], [delay_dt_09], [delay_dt_10]
				)
			) AS pvt
		),
		ReasonPivotCd AS (
			SELECT 
				task_id,
				[delay_reason_cd_01], [delay_reason_cd_02], [delay_reason_cd_03], [delay_reason_cd_04], [delay_reason_cd_05],
				[delay_reason_cd_06], [delay_reason_cd_07], [delay_reason_cd_08], [delay_reason_cd_09], [delay_reason_cd_10]
			FROM (
				SELECT 
					task_id,
					delay_reason_cd,
					CONCAT('delay_reason_cd_', RIGHT('00' + CAST(rn AS VARCHAR), 2)) AS colname
				FROM RankedDelay
				WHERE rn <= 10
			) AS src
			PIVOT (
				MAX(delay_reason_cd) FOR colname IN (
					[delay_reason_cd_01], [delay_reason_cd_02], [delay_reason_cd_03], [delay_reason_cd_04], [delay_reason_cd_05],
					[delay_reason_cd_06], [delay_reason_cd_07], [delay_reason_cd_08], [delay_reason_cd_09], [delay_reason_cd_10]
				)
			) AS pvt
		),
		ReasonPivot AS (
		SELECT 
			task_id,
			[delay_reason_01], [delay_reason_02], [delay_reason_03], [delay_reason_04], [delay_reason_05],
			[delay_reason_06], [delay_reason_07], [delay_reason_08], [delay_reason_09], [delay_reason_10]
		FROM (
			SELECT 
				task_id,
				delay_reason,
				CONCAT('delay_reason_', RIGHT('00' + CAST(rn AS VARCHAR), 2)) AS colname
			FROM RankedDelay
			WHERE rn <= 10
		) AS src
		PIVOT (
			MAX(delay_reason) FOR colname IN (
				[delay_reason_01], [delay_reason_02], [delay_reason_03], [delay_reason_04], [delay_reason_05],
				[delay_reason_06], [delay_reason_07], [delay_reason_08], [delay_reason_09], [delay_reason_10]
				)
			) AS pvt
		),
		DelayWithReason AS (
			SELECT 
				dp.task_id,
				dp.[delay_dt_01], rp.[delay_reason_01], rpc.[delay_reason_cd_01],
				dp.[delay_dt_02], rp.[delay_reason_02], rpc.[delay_reason_cd_02],
				dp.[delay_dt_03], rp.[delay_reason_03], rpc.[delay_reason_cd_03],
				dp.[delay_dt_04], rp.[delay_reason_04], rpc.[delay_reason_cd_04],
				dp.[delay_dt_05], rp.[delay_reason_05], rpc.[delay_reason_cd_05],
				dp.[delay_dt_06], rp.[delay_reason_06], rpc.[delay_reason_cd_06],
				dp.[delay_dt_07], rp.[delay_reason_07], rpc.[delay_reason_cd_07],
				dp.[delay_dt_08], rp.[delay_reason_08], rpc.[delay_reason_cd_08],
				dp.[delay_dt_09], rp.[delay_reason_09], rpc.[delay_reason_cd_09],
				dp.[delay_dt_10], rp.[delay_reason_10], rpc.[delay_reason_cd_10]
			FROM DelayPivot dp
			LEFT JOIN ReasonPivot rp ON dp.task_id = rp.task_id
			LEFT JOIN ReasonPivotCd rpc ON dp.task_id = rpc.task_id
		)

	
		SELECT
			T.task_id,
			T.task_name,
			T.project_id,
			P.project_name,
			TM1.member_ids,
			TM1.member_names,
			T.order_no,
			TFS.start_dt	AS std_start_dt,
			TFS.end_dt		AS std_end_dt,
			dbo.fnCalcWorkingDay (TFS.start_dt,TFS.end_dt) AS std_working_day,
			TFP.start_dt	AS planed_start_dt,
			TFP.end_dt		AS planed_end_dt,
			dbo.fnCalcWorkingDay (TFP.start_dt,TFP.end_dt) AS planed_working_day,
			TFA.start_dt	AS act_start_dt,
			TFA.end_dt		AS act_end_dt,
			dbo.fnCalcWorkingDay (TFA.start_dt,TFA.end_dt) AS act_working_day,
			T.status_cd,
			dbo.fnGetTaskState(T.task_id) AS task_state_name,
			(SELECT TOP 1 T.task_name FROM task AS T WITH (NOLOCK) WHERE T.task_id = TD.dependency_id) AS dependency_task_name,	
			CM.detail_name AS dependency_name,
			dbo.fnCalcWorkingDay(TFA.start_dt, TFA.end_dt) AS actual_working_day,
			T.is_output_need,
			PVT.delay_dt_01,PVT.delay_reason_cd_01, dbo.fnGetDetailNameByDetailCode('20202', PVT.delay_reason_cd_01) AS delay_reason_name_01, PVT.delay_reason_01,
			PVT.delay_dt_02,PVT.delay_reason_cd_02, dbo.fnGetDetailNameByDetailCode('20202', PVT.delay_reason_cd_02) AS delay_reason_name_02, PVT.delay_reason_02,
			PVT.delay_dt_03,PVT.delay_reason_cd_03, dbo.fnGetDetailNameByDetailCode('20202', PVT.delay_reason_cd_03) AS delay_reason_name_03, PVT.delay_reason_03,
			PVT.delay_dt_04,PVT.delay_reason_cd_04, dbo.fnGetDetailNameByDetailCode('20202', PVT.delay_reason_cd_04) AS delay_reason_name_04, PVT.delay_reason_04,
			PVT.delay_dt_05,PVT.delay_reason_cd_05, dbo.fnGetDetailNameByDetailCode('20202', PVT.delay_reason_cd_05) AS delay_reason_name_05, PVT.delay_reason_05,
			PVT.delay_dt_06,PVT.delay_reason_cd_06, dbo.fnGetDetailNameByDetailCode('20202', PVT.delay_reason_cd_06) AS delay_reason_name_06, PVT.delay_reason_06,
			PVT.delay_dt_07,PVT.delay_reason_cd_07, dbo.fnGetDetailNameByDetailCode('20202', PVT.delay_reason_cd_07) AS delay_reason_name_07, PVT.delay_reason_07,
			PVT.delay_dt_08,PVT.delay_reason_cd_08, dbo.fnGetDetailNameByDetailCode('20202', PVT.delay_reason_cd_08) AS delay_reason_name_08, PVT.delay_reason_08,
			PVT.delay_dt_09,PVT.delay_reason_cd_09, dbo.fnGetDetailNameByDetailCode('20202', PVT.delay_reason_cd_09) AS delay_reason_name_09, PVT.delay_reason_09,
			PVT.delay_dt_10,PVT.delay_reason_cd_10, dbo.fnGetDetailNameByDetailCode('20202', PVT.delay_reason_cd_10) AS delay_reason_name_10, PVT.delay_reason_10
		FROM 
			dbo.project AS P WITH (NOLOCK)
			INNER JOIN task AS T WITH (NOLOCK)	
			ON P.project_id = T.project_id
			LEFT JOIN task_finish_plan AS TFS WITH (NOLOCK)
			ON T.task_id = TFS.task_id
			AND TFS.plan_cd = '10'	-- 10: 표준, 20: 계획, 30: 실제
			LEFT JOIN task_finish_plan AS TFP WITH (NOLOCK)
			ON T.task_id = TFP.task_id
			AND TFP.plan_cd = '20'
			LEFT JOIN task_finish_plan AS TFA WITH (NOLOCK)
			ON T.task_id = TFA.task_id
			AND TFA.plan_cd = '30'
			LEFT JOIN DelayWithReason AS PVT
			ON T.task_id = PVT.task_id
			LEFT JOIN (
						SELECT 
							TOWN.task_id,
							STRING_AGG(CAST(MI.[NAME] AS VARCHAR), ', ') AS member_names,
							STRING_AGG(CAST(MI.EMP_ID AS VARCHAR), ', ') AS member_ids
						FROM dbo.task_owner AS TOWN WITH (NOLOCK)
							INNER JOIN dbo.hr_master AS MI WITH (NOLOCK)
							ON TOWN.member_id = MI.EMP_ID
						WHERE TOWN.is_active_cd = '10'					
						GROUP BY task_id) TM1
			ON T.task_id = TM1.task_id
			LEFT JOIN task_dependency AS TD WITH (NOLOCK)
			ON T.task_id = TD.task_id
			LEFT JOIN dbo.code_master AS CM WITH (NOLOCK)
			ON TD.dependency_cd = CM.detail_cd
			AND CM.group_cd = '90301'	-- 10: 하위, 20: 후행
		WHERE T.task_id = @pTask_id
		AND T.project_id = @vProject_id;
		
		SET @vSeverity = 0;
		SET @result_cd = 0;
		SET @result_msg = '성공';

	END TRY
	BEGIN CATCH

		SET @result_cd = -1;
		SET @vSeverity = ERROR_SEVERITY();
		SET @result_msg = ERROR_MESSAGE();

	END CATCH

	RETURN;
END


--- Procedure 43 ---
ProcedureName: spGetTaskList
ProcedureDefinition:
-- =============================================
-- Author:		JayKwon
-- Create date: 2025-05-21
-- Description:	프로젝트에 등록된 태스크 리스트를 가져온다.
/* SAMPLE EXEC

DECLARE @result_cd INT, @result_msg VARCHAR(100);
EXEC [dbo].[spGetTaskList] @pProject_id = 25080009,　@result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT;
SELECT @result_cd as result_cd, @result_msg as result_msg;

*/
-- =============================================
CREATE PROCEDURE [dbo].[spGetTaskList]
    @pProject_id    INT = NULL,
    @result_cd			INT				OUTPUT,
    @result_msg			VARCHAR(200)	OUTPUT
AS
BEGIN
	SET NOCOUNT ON;
    SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	-- 파라미터 유효성 체크
    IF NOT EXISTS(SELECT 1 FROM dbo.project AS P WITH (NOLOCK) WHERE P.project_id = @pProject_id)
    BEGIN		
		SET @result_cd = 1
		SET @result_msg = '존재하지 않는 프로젝트 입니다.'
        RETURN;	
    END
	
    BEGIN TRY
		WITH RankedDelay AS (
			SELECT 
				task_id,
				end_dt,
				delay_reason,
				ROW_NUMBER() OVER (PARTITION BY task_id ORDER BY end_dt) AS rn
			FROM dbo.task_finish_plan WITH (NOLOCK)				
			WHERE plan_cd = '40'
			AND project_id = @pProject_id
		),
		DelayPivot AS (
		SELECT 
			task_id,
			[delay_dt_01], [delay_dt_02], [delay_dt_03], [delay_dt_04], [delay_dt_05],
			[delay_dt_06], [delay_dt_07], [delay_dt_08], [delay_dt_09], [delay_dt_10]
		FROM (
			SELECT 
				task_id,
				end_dt,
				CONCAT('delay_dt_', RIGHT('00' + CAST(rn AS VARCHAR), 2)) AS colname
			FROM RankedDelay
			WHERE rn <= 10
		) AS src
		PIVOT (
			MAX(end_dt) FOR colname IN (
				[delay_dt_01], [delay_dt_02], [delay_dt_03], [delay_dt_04], [delay_dt_05],
				[delay_dt_06], [delay_dt_07], [delay_dt_08], [delay_dt_09], [delay_dt_10]
				)
			) AS pvt
		),
		ReasonPivot AS (
		SELECT 
			task_id,
			[delay_reason_01], [delay_reason_02], [delay_reason_03], [delay_reason_04], [delay_reason_05],
			[delay_reason_06], [delay_reason_07], [delay_reason_08], [delay_reason_09], [delay_reason_10]
		FROM (
			SELECT 
				task_id,
				delay_reason,
				CONCAT('delay_reason_', RIGHT('00' + CAST(rn AS VARCHAR), 2)) AS colname
			FROM RankedDelay
			WHERE rn <= 10
		) AS src
		PIVOT (
			MAX(delay_reason) FOR colname IN (
				[delay_reason_01], [delay_reason_02], [delay_reason_03], [delay_reason_04], [delay_reason_05],
				[delay_reason_06], [delay_reason_07], [delay_reason_08], [delay_reason_09], [delay_reason_10]
				)
			) AS pvt
		),
		DelayWithReason AS (
			SELECT 
				dp.task_id,
				dp.[delay_dt_01], rp.[delay_reason_01],
				dp.[delay_dt_02], rp.[delay_reason_02],
				dp.[delay_dt_03], rp.[delay_reason_03],
				dp.[delay_dt_04], rp.[delay_reason_04],
				dp.[delay_dt_05], rp.[delay_reason_05],
				dp.[delay_dt_06], rp.[delay_reason_06],
				dp.[delay_dt_07], rp.[delay_reason_07],
				dp.[delay_dt_08], rp.[delay_reason_08],
				dp.[delay_dt_09], rp.[delay_reason_09],
				dp.[delay_dt_10], rp.[delay_reason_10]
			FROM DelayPivot dp
			LEFT JOIN ReasonPivot rp ON dp.task_id = rp.task_id
		)

		SELECT
			ROW_NUMBER() OVER (ORDER BY T.order_no ASC) as seq,
			T.task_id,
			CASE WHEN dbo.fnGetDepthForTask(T.project_id, T.task_id) = 1  THEN T.task_name
				 ELSE CONCAT(REPLICATE('  ', dbo.fnGetDepthForTask(T.project_id, T.task_id) - 1), 'ㄴ', T.task_name)
			END AS task_name,
			A.dependency_infos,
			TFS.start_dt AS std_start_dt,
			TFS.end_dt AS std_end_dt,
			TFP.start_dt AS planed_start_dt,
			TFP.end_dt AS planed_end_dt,
			TFA.start_dt AS actual_start_dt,
			TFA.end_dt AS actual_end_dt,		
			dbo.fnGetTaskWorkingDayByType(T.task_id, '10') AS std_workding_day,
			dbo.fnCalcWorkingDay(TFP.start_dt, TFP.end_dt) AS planed_workding_day,
			dbo.fnCalcWorkingDay(TFA.start_dt, TFA.end_dt) AS actual_workding_day,
			dbo.fnGetTaskState(T.task_id) AS task_state_name,
			T.project_id,
			P.project_name,
			T.order_no,
			TM1.member_names,
			TM1.member_ids,
			T.is_active_cd,
			dbo.fnGetDetailNameByDetailCode('90100',T.is_active_cd) AS is_active_name,
			T.status_cd,
			(SELECT CM.detail_name FROM dbo.code_master AS CM WITH (NOLOCK)
			 WHERE CM.group_cd = '90300' AND CM.detail_cd = T.status_cd) AS status_name,
			T.is_output_need,
			dbo.fnGetDetailNameByDetailCode('90100', T.is_output_need) AS is_output_need_name,
			CASE WHEN TOPT.task_id IS NULL THEN '90'
				 ELSE '10'
			END AS is_output_registed_cd,
			dbo.fnGetTaskStateForReady(T.task_id) AS task_ready,			
			-- 명시적으로 delay 정보 추가
			D.delay_dt_01, D.delay_reason_01,
			D.delay_dt_02, D.delay_reason_02,
			D.delay_dt_03, D.delay_reason_03,
			D.delay_dt_04, D.delay_reason_04,
			D.delay_dt_05, D.delay_reason_05,
			D.delay_dt_06, D.delay_reason_06,
			D.delay_dt_07, D.delay_reason_07,
			D.delay_dt_08, D.delay_reason_08,
			D.delay_dt_09, D.delay_reason_09,
			D.delay_dt_10, D.delay_reason_10
		INTO #RESULT_TMP
		FROM dbo.task AS T WITH (NOLOCK)
			INNER JOIN dbo.project AS P WITH (NOLOCK) 
			ON T.project_id = P.project_id
			LEFT JOIN (
				SELECT
					T.task_id,
					STRING_AGG(CONCAT(CONVERT(VARCHAR, TD.dependency_id), ' ', CM.detail_name), ',') AS dependency_infos
				FROM dbo.task AS T WITH (NOLOCK)
					INNER JOIN dbo.task_dependency AS TD WITH (NOLOCK)
					ON T.task_id = TD.task_id
					INNER JOIN dbo.code_master AS CM WITH (NOLOCK)
					ON TD.dependency_cd = CM.detail_cd
					AND CM.group_cd = '90301'
				WHERE T.project_id = @pProject_id
				GROUP BY T.task_id) A 
			ON T.task_id = A.task_id
			LEFT JOIN dbo.task_finish_plan AS TFS WITH (NOLOCK)
			ON T.task_id = TFS.task_id
			AND TFS.plan_cd = '10'
			LEFT JOIN dbo.task_finish_plan AS TFP WITH (NOLOCK)
			ON T.task_id = TFP.task_id
			AND TFP.plan_cd = '20'
			LEFT JOIN dbo.task_finish_plan AS TFA WITH (NOLOCK)
			ON T.task_id = TFA.task_id
			AND TFA.plan_cd = '30'
			LEFT JOIN DelayWithReason D
			ON T.task_id = D.task_id
			LEFT JOIN (
						SELECT 
							TOWN.task_id,
							STRING_AGG(CAST(MI.[NAME] AS VARCHAR), ', ') AS member_names,
							STRING_AGG(CAST(MI.EMP_ID AS VARCHAR), ', ') AS member_ids
						FROM dbo.task_owner AS TOWN WITH (NOLOCK)
							INNER JOIN dbo.hr_master AS MI WITH (NOLOCK)
							ON TOWN.member_id = MI.EMP_ID
						WHERE TOWN.is_active_cd = '10'					
						GROUP BY task_id) TM1
			ON T.task_id = TM1.task_id
			LEFT JOIN (SELECT task_id FROM dbo.task_output WITH (NOLOCK) WHERE project_id = @pProject_id GROUP BY task_id) AS TOPT
			ON T.task_id = TOPT.task_id
		WHERE T.project_id = @pProject_id
		AND T.is_active_cd = '10'; --삭제가 아닌것만 조회
	



        -- 넘버링 처리
		DECLARE @target	TABLE (
			numbering		VARCHAR(10),
			task_id			INT
		)
		
		DECLARE @step01	TABLE (
			task_numbering	VARCHAR(10),
			task_id			INT
		)

		INSERT INTO @step01
		SELECT
			ROW_NUMBER() OVER (ORDER BY T.order_no) AS task_numbering,
			T.task_id
		FROM dbo.task AS T WITH (NOLOCK)
			LEFT JOIN dbo.task_dependency AS TD WITH (NOLOCK)
			ON T.task_id = TD.task_id
		WHERE T.project_id = @pProject_id
		AND (TD.dependency_cd != '10' OR TD.dependency_cd IS NULL)
		AND T.is_active_cd = '10'
		--ORDER BY T.order_no

		INSERT INTO @target
		SELECT
			S.task_numbering AS numbering,
			S.task_id
		FROM @step01 AS S

		INSERT INTO @target
		SELECT
			CAST(A.parent_task_numbering AS VARCHAR) + '-' + CAST(A.task_numbering AS VARCHAR),
			A.task_id
		FROM (	
		SELECT
					ST1.task_numbering AS parent_task_numbering,
					ST1.task_id AS parent_id,
					ROW_NUMBER() OVER (PARTITION BY ST1.task_id ORDER BY TD.task_id ASC) AS task_numbering,
					TD.task_id
				FROM @step01 AS ST1
					INNER JOIN dbo.task_dependency AS TD WITH (NOLOCK)
					ON ST1.task_id = TD.dependency_id
					AND TD.dependency_cd = '10') A;
		-- 넘버링 처리 종료

		SELECT
			T.numbering,
			RT.*
		FROM #RESULT_TMP AS RT
			LEFT JOIN @target AS T
			ON RT.task_id = T.task_id
		ORDER BY RT.order_no



		SET @result_cd = 0
		SET @result_msg = '성공'

	END TRY
	BEGIN CATCH
		SET @result_cd = -1
		SET @result_msg = ERROR_MESSAGE()
	END CATCH

END




--- Procedure 44 ---
ProcedureName: spGetTaskOwnerList
ProcedureDefinition:

-- =============================================
-- Author:		Jay Kwon
-- Create date: 2025-06-09
-- Description:	TASK에 할당된 인원 목록 조회
/* 실행 예제
DECLARE @result_cd INT, @result_msg VARCHAR(100);
EXEC  [dbo].[spGetTaskOwnerList] @pTask_id = 3, @result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT;
SELECT @result_cd as result_cd, @result_msg as result_msg;
*/
-- =============================================
CREATE PROCEDURE [dbo].[spGetTaskOwnerList]
	@pTask_id			INT,
    @result_cd			INT				OUTPUT,
    @result_msg			VARCHAR(200)	OUTPUT
AS
BEGIN
	
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	-- 파라미터 유효성 체크
    IF NOT EXISTS(SELECT 1 FROM dbo.task AS T WITH (NOLOCK) WHERE T.task_id = @pTask_id)
    BEGIN		
		SET @result_cd = 1;
		SET @result_msg = '존재하지 않는 태스크 입니다.';
        RETURN;	
    END

	BEGIN TRY
		SELECT
			P.project_id,
			P.project_name,
			T.task_id,
			T.task_name,
			MI.EMP_ID AS member_id,
			MI.[NAME] AS member_name
		FROM dbo.project AS P WITH (NOLOCK)
			INNER JOIN dbo.task AS T WITH (NOLOCK)
			ON P.project_id = T.project_id
			INNER JOIN dbo.task_owner AS TOWN WITH (NOLOCK)
			ON T.task_id = TOWN.task_id
			INNER JOIN dbo.hr_master AS MI WITH (NOLOCK)
			ON TOWN.member_id = MI.EMP_ID
		WHERE TOWN.task_id = @pTask_id
		
		SET @result_cd = 0;
		SET @result_msg = '성공';

	END TRY
	BEGIN CATCH
		SET @result_cd = -1;
		SET @result_msg = ERROR_MESSAGE();
	END CATCH
END


--- Procedure 45 ---
ProcedureName: spInsertCodeMaster
ProcedureDefinition:
-- =============================================
-- Author:		jaykwon
-- Create date: 2025-06-10
-- Description:	코드 마스터값 추가
-- select * from code_master order by 2 desc
/*
DECLARE @result_cd INT, @result_msg VARCHAR(100);
EXEC [dbo].[spInsertCodeMaster] @pGroup_cd = '99999', @pDetail_name = '마스터코드테스트1', @pCreator_id = 1 , @result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT;
SELECT @result_cd as result_cd, @result_msg as result_msg;
*/
-- =============================================
CREATE PROCEDURE [dbo].[spInsertCodeMaster]
	@pGroup_cd			VARCHAR(8),
	@pDetail_name		VARCHAR(50),
	@pCreator_id		VARCHAR(7),
    @result_cd			INT				OUTPUT,
    @result_msg			VARCHAR(200)	OUTPUT
AS
BEGIN

	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	DECLARE @vSeverity				INT = NULL;

	-- 그룹코드 채번
	DECLARE @max_detail_cd	INT = null;

	SELECT
		@max_detail_cd = CAST(MAX(CM.detail_cd) AS INT) + 1
	FROM dbo.code_master AS CM WITH (NOLOCK)
	WHERE CM.group_cd = @pGroup_cd
	GROUP BY CM.group_cd

	BEGIN TRY

		-- 채번한 그룹코드가 중복이 없는지 다시 한번 체크
		IF EXISTS(SELECT 1 FROM code_master AS CM WITH (NOLOCK) WHERE CM.group_cd = @pGroup_cd AND CM.detail_cd = CAST(@max_detail_cd AS VARCHAR(8)))
		BEGIN
			RAISERROR('그룹코드 채번에 실패 하였습니다.', 16, 1);
		END

		IF (@pGroup_cd >= '90000')
		BEGIN
			RAISERROR('시스템 코드는 접근할 수 없습니다.', 16, 1);
		END

		IF EXISTS (SELECT 1 FROM dbo.code_master AS CM WITH (NOLOCK) WHERE CM.group_cd = @pGroup_cd AND CM.detail_name = @pDetail_name)
		BEGIN
			RAISERROR('이미 존재하는 코드입니다.', 16, 1);
		END

		IF NOT EXISTS (SELECT 1 FROM dbo.code_master AS CM WITH (NOLOCK) WHERE CM.group_cd = @pGroup_cd)
		BEGIN
			RAISERROR('그룹코드가 존재하지 않습니다.', 16, 1);
		END

		BEGIN TRAN
		
		INSERT INTO dbo.code_master (				
				group_cd,
				group_name,
				detail_cd,
				detail_name,
				is_active_cd,
				creator_id,
				created_at,
				modifier_id,
				modified_at
		)
		SELECT TOP 1			
			CM.group_cd,
			CM.group_name,
			@max_detail_cd	AS detail_cd,
			@pDetail_name	AS detail_name,
			'10'			AS is_active_cd,
			@pCreator_id	AS creator_id,
			GETDATE()		AS created_at,
			null			AS modifier_id,
			null			AS modified_at
		FROM dbo.code_master AS CM WITH (NOLOCK)
		WHERE CM.group_cd = @pGroup_cd

		COMMIT TRAN
		
		SET @vSeverity = 0;
		SET @result_cd = 0;
		SET @result_msg = '성공';

	END TRY
	BEGIN CATCH
		IF @@TRANCOUNT > 0
			ROLLBACK TRAN;

		SET @result_cd = -1;
		SET @result_msg = ERROR_MESSAGE();
		SET @vSeverity = ERROR_SEVERITY();

	END CATCH

	DECLARE @log_param VARCHAR(MAX);

	SET @log_param = '@pGroup_cd = ' + ISNULL(@pGroup_cd, 'NULL') + ', '
				   + '@pDetail_name = ' + ISNULL(@pDetail_name, 'NULL') + ', '
				   + '@pCreator_id = ' + ISNULL(@pCreator_id, 'NULL');

	INSERT INTO dbo.use_log (caller_id, severity, project_id, log_dt, log_message, proc_name, proc_param, result_cd, result_msg, created_at)
	VALUES(ISNULL(CAST(@pCreator_id AS VARCHAR(8)), 'UNKNOWN'), @vSeverity, ISNULL(NULL, 0), CONVERT(CHAR(10), GETDATE(), 120), @pDetail_name + ' 마스터 코드 생성', '[spInsertCodeMaster]', @log_param, @result_cd, @result_msg, GETDATE());

	RETURN;
END


--- Procedure 46 ---
ProcedureName: spInsertOutputForTask
ProcedureDefinition:
-- =============================================
-- Author:		Jay Kwon
-- Create date: 2025-05-28
-- Description:	산출물정보를 입력한다.
/*
DECLARE @result_cd INT, @result_msg VARCHAR(100);
 EXEC [dbo].[spInsertOutputForTask] @pTask_id = 15, @pFile_path = '/nas/wellfood/marketing/20250528_신제품 디자인 초안2.pptx',@pOutput_comment = '디자인 초안 확인용', @pCreator_id = 1 , @result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT;
SELECT @result_cd as result_cd, @result_msg as result_msg;

*/
-- =============================================
CREATE PROCEDURE [dbo].[spInsertOutputForTask]
	@pTask_id			INT				= NULL,
	@pFile_name			VARCHAR(200)    = NULL,
	@pFile_path			VARCHAR(200)	= NULL,
	@pOutput_comment	VARCHAR(200)	= NULL,
	@pCreator_id		VARCHAR(7)		= NULL,
    @result_cd			INT OUTPUT,
    @result_msg			VARCHAR(200) OUTPUT

AS
BEGIN
	
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	DECLARE @vSeverity				INT = NULL;
	DECLARE @vProject_id			INT = NULL;

	SET @vProject_id = (SELECT
							DISTINCT TOP 1 T.project_id
						FROM dbo.task AS T WITH (NOLOCK)
						WHERE T.task_id = @pTask_id);


	BEGIN TRY

		IF NOT EXISTS (SELECT 1 FROM task AS T WITH (NOLOCK) WHERE T.task_id = @pTask_id)
		BEGIN
			RAISERROR('존재하지 않는 태스크 입니다.', 16, 1);
		END
		
		-- 같은 태스크에 같은이름 파일은 못넣게 해야 함.
		IF EXISTS (SELECT 1
					FROM task_output AS T WITH (NOLOCK) 
						INNER JOIN dbo.project AS P WITH (NOLOCK)
						ON T.project_id = P.project_id
						WHERE T.task_id = @pTask_id AND T.file_path = @pFile_path)
		BEGIN
			RAISERROR('같은 태스크에 같은 이름의 산출물이 존재합니다.', 16, 1);
		END


		INSERT INTO task_output (		
			task_id,
			project_id,
			file_name,
			file_path,
			output_comment,
			is_active_cd,
			creator_id,
			created_at,
			modifier_id,
			modified_at
		) VALUES (
			@pTask_id,
			@vProject_id,
			@pFile_name,
			@pFile_path,
			@pOutput_comment,
			'10',	-- 인서트니까 디폴트는 사용으로
			@pCreator_id,
			GETDATE(),
			null,
			null
		)
		SET @vSeverity = 0;
		SET @result_cd = 0;
		SET @result_msg = '성공';    
	END TRY
	BEGIN CATCH
		IF @@TRANCOUNT > 0
			ROLLBACK TRAN;
		
		-- 실패 메시지
		SET @vSeverity = ERROR_SEVERITY();
		SET @result_cd = -1;
		SET @result_msg = ERROR_MESSAGE();	
	END CATCH

	-- 로깅	
	DECLARE @log_param NVARCHAR(MAX);

	SET @log_param =
		'@pTask_id = '       + ISNULL(CAST(@pTask_id AS VARCHAR), 'NULL') + ', ' +
		'@pFile_path = '  + ISNULL(@pFile_path, 'NULL') + ', ' +
		'@pOutput_comment = '          + ISNULL(@pOutput_comment, 'NULL') + ', ' +
		'@pCreator_id = '         + ISNULL(@pCreator_id, 'NULL');


	INSERT INTO dbo.use_log (caller_id, severity, project_id, log_dt, log_message, proc_name, proc_param, result_cd, result_msg, created_at)
	VALUES(ISNULL(CAST(@pCreator_id AS VARCHAR(8)), 'UNKNOWN'), @vSeverity, ISNULL(@vProject_id, 0), CONVERT(CHAR(10), GETDATE(), 120), CAST(@pTask_id AS VARCHAR) + ' 태스크에 산출물을 등록 하였습니다', '[spInsertOutputForTask]', @log_param, @result_cd, @result_msg, GETDATE());

	RETURN;
END


--- Procedure 47 ---
ProcedureName: spGetAccessStateForUser
ProcedureDefinition:

-- =============================================
-- Author:		Jay Kwon
-- Create date: 2025-07-18
-- Description:	로그인 제어 상태 가져오기
/*
DECLARE @result_cd INT, @result_msg VARCHAR(100);
EXEC [dbo].[spGetAccessStateForUser] @pMember_id = '2204901', @result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT;
SELECT @result_cd as result_cd, @result_msg as result_msg;
*/
-- =============================================
CREATE PROCEDURE [dbo].[spGetAccessStateForUser]
	@pMember_id			VARCHAR(7) = NULL,
    @result_cd			INT				OUTPUT,
    @result_msg			VARCHAR(200)	OUTPUT
AS
BEGIN
	
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	DECLARE @vSeverity				INT = NULL;

    BEGIN TRY

		IF NOT EXISTS(SELECT 1 FROM dbo.hr_master AS HRM WITH (NOLOCK) WHERE HRM.EMP_ID = @pMember_id)
		BEGIN
			RAISERROR('존재하지 않는 회원 아이디 입니다.', 16, 1);
		END

		--화이트 베이스로 운영하며 제어 할 사람만 넣어준다.
		SELECT
			HRM.EMP_ID					AS member_id,
			HRM.[NAME]					AS member_name,
			ISNULL(LC.access_yn,'Y')	AS access_yn
		FROM dbo.hr_master AS HRM WITH (NOLOCK)
			LEFT JOIN dbo.login_control AS LC WITH (NOLOCK)
			ON HRM.EMP_ID = LC.member_id
		WHERE HRM.EMP_ID = @pMember_id

		SET @vSeverity = 0;
		SET @result_cd = 0;
		SET @result_msg = '성공';

	END TRY

	BEGIN CATCH
		SET @result_cd = -1;
		SET @result_msg = ERROR_MESSAGE();
		SET @vSeverity = ERROR_SEVERITY();
	END CATCH

	RETURN;
END


--- Procedure 48 ---
ProcedureName: spInsertProjectInfo
ProcedureDefinition:
-- =============================================
-- Author:		JayKwon
-- Create date: 2025-05-19
-- Description:	insert project info
-- SAMPLE EXECUTION
/*

-- 템플릿 프로젝트
DECLARE @result_cd INT, @result_msg VARCHAR(100);
EXEC [dbo].[spInsertProjectInfo]
	@project_id			= NULL,		  -- 신규로 생성하는 템플릿이면 NULL, 다른 템플릿에서 따오는거면 다른 템플릿의 프로젝트 id를 넣어줌	
    @project_type_cd    = '90',       -- mst(90200,프로젝트타입)		: 10 프로젝트, 20 테스트프로젝트, 90 템플릿
    @line_cd            = NULL,
    @brand_cd           = NULL,
	@fml_brand_cd       = NULL,    
	@work_type_cd		= '100',		  -- mst(20103,프로젝트 구분)		: 100 순수, 101 익스텐션, 102 체인전용, 103 리뉴얼, 104 개인프로젝트
    @project_name       = '빙과 신제품 개발 프로젝트 템플릿5',
    @planed_start_dt    = NULL,
    @is_active          = '10',       -- code_master.group_cd = '90100'
    @creator_id         = '2400000',	
	@result_cd = @result_cd OUTPUT,
	@result_msg = @result_msg OUTPUT;

SELECT @result_cd as result_cd, @result_msg as result_msg;

-- 템플릿 기반으로 생성한 프로젝트
DECLARE @result_cd INT, @result_msg VARCHAR(100);
EXEC [dbo].[spInsertProjectInfo]
	@project_id			= 15,		  -- 신규로 생성하는 템플릿이면 NULL, 다른 템플릿에서 따오는거면 다른 템플릿의 프로젝트 id를 넣어줌	
    @project_type_cd    = '10',       -- mst(90200,프로젝트타입)		: 10 프로젝트, 20 테스트프로젝트, 90 템플릿
    @line_cd            = '1103',     -- mst(20100,라인)				: 1001 껌, 1002 캔디, 1003 비스킷, 1004 초코, 1005 케익, 1006 스택, 1007 빙과, 1008 제빵
    @brand_cd           = '20000082',    
	@fml_brand_cd       = '10000001',    
	@work_type_cd		= '100',		  -- mst(20103,프로젝트 구분)		: 100 순수, 101 익스텐션, 102 체인전용, 103 리뉴얼, 104 개인프로젝트
    @project_name       = '월드콘 민트초코맛 신제품 개발10',
    @planed_start_dt    = '2025-07-20', 
    @is_active          = '10',       -- code_master.group_cd = '90100'
    @creator_id         = '2400000',	
	@result_cd = @result_cd OUTPUT,
	@result_msg = @result_msg OUTPUT;

SELECT @result_cd as result_cd, @result_msg as result_msg;
*/
-- =============================================
CREATE PROCEDURE [dbo].[spInsertProjectInfo]
	@project_id				INT = NULL,			
	@project_type_cd		VARCHAR(8),	-- project_type_cd = '90' 템플릿인경우 task를 찾기 위함
    @line_cd				VARCHAR(8),
    @brand_cd				VARCHAR(8),
	@fml_brand_cd			VARCHAR(8),    
	@work_type_cd			VARCHAR(8),
    @project_name			VARCHAR(50),
    @planed_start_dt		VARCHAR(10),
    @is_active				VARCHAR(8) = NULL,
	@pApply_tmplt			INT = 0,
    @creator_id				VARCHAR(7),	
    @result_cd				INT OUTPUT,
    @result_msg				VARCHAR(200) OUTPUT
AS
BEGIN

	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	DECLARE @std_working_dt			INT = NULL;
	DECLARE @new_project_id			INT = NULL;
	DECLARE @vSeverity				INT = NULL;
	DECLARE @vStd_template_id		INT = NULL;

	-- 표준 템플릿 아이디 취득
	SELECT
		@vStd_template_id = CM.detail_name
	FROM dbo.code_master AS CM WITH (NOLOCK)
	WHERE CM.group_cd = '90303'
	AND CM.detail_cd = '10'



	BEGIN TRY
		IF (@pApply_tmplt = 1)
		BEGIN
			IF (ISNULL(@vStd_template_id, '') = '')
			BEGIN
				RAISERROR('표준템플릿으로 생성 요청 하였으나 설정된 표준템플릿 아이디가 없습니다.', 16, 1);
			END
			
			IF NOT EXISTS(SELECT 1 FROM dbo.project AS P WITH (NOLOCK) WHERE P.project_id = @vStd_template_id AND P.project_type_cd = '90')
			BEGIN
				RAISERROR('표준템플릿으로 등록된 프로젝트아이디가 잘못되었습니다.', 16, 1);
			END
		END

		
		-- 필수값 유효성 체크
		IF (
			@project_type_cd IS NULL OR LTRIM(RTRIM(@project_type_cd)) = '' OR		
			@project_name    IS NULL OR LTRIM(RTRIM(@project_name)) = ''
		)
		BEGIN
			RAISERROR('필수 입력 항목이 누락되었습니다.', 16, 1);
		END

		-- 브랜드 코드 점검
		IF ( (@brand_cd IS NOT NULL) AND NOT EXISTS(	SELECT 1
														FROM [dbo].[IF_SAP_NPD_BRAND] AS SB WITH (NOLOCK)
														WHERE SB.BRANDTYPE = '200'
														AND SB.BRANDCODE = @brand_cd) )
		BEGIN
			RAISERROR('존재하지 않는 브랜드 코드 입니다.', 16, 1);
		END

			-- 패밀리 브랜드 코드 점검
		IF ( (@fml_brand_cd IS NOT NULL) AND NOT EXISTS(	SELECT 1
														FROM [dbo].[IF_SAP_NPD_BRAND] AS SB WITH (NOLOCK)
														WHERE SB.BRANDTYPE = '100'
														AND SB.BRANDCODE = @fml_brand_cd) )
		BEGIN
			RAISERROR('존재하지 않는 패밀리 브랜드 코드 입니다.', 16, 1);
		END

	

		-- 프로젝트 이름 중복 체크
		IF EXISTS (
			SELECT 1
			FROM project WITH (NOLOCK)
			WHERE project_name = @project_name
		)
		BEGIN
			RAISERROR('동일한 프로젝트명이 이미 존재합니다.', 16, 1);
		END


		-- 마스터 코드 존재 여부 검사
		IF NOT EXISTS (SELECT 1 FROM code_master WHERE group_cd = '90200' AND detail_cd = @project_type_cd)
		BEGIN
			RAISERROR('유효하지 않은 프로젝트 타입 코드입니다.', 16, 1);
		END

		-- 탬플릿 기반으로 생성시 탬플릿에 등록된 태스크가 없다면 오류
		IF ( (@project_id IS NOT NULL) AND (@project_type_cd = '10') AND NOT EXISTS(	SELECT 1
																						FROM dbo.task AS T WITH (NOLOCK)
																						WHERE T.project_id = @project_id
																						AND T.is_active_cd = '10') )
		BEGIN
			RAISERROR('템플릿에 등록된 태스크가 없습니다.', 16, 1);
		END

		-- 탬플릿 기반으로 일반 프로젝트 생성시 전달받은 프로젝트 아이디가 템플릿이 아니면 오류
		IF ( (@project_id IS NOT NULL) AND (@project_type_cd = '10') AND EXISTS(	SELECT 1
																					FROM dbo.project AS P WITH (NOLOCK)
																					WHERE P.project_id = @project_id
																					AND P.project_type_cd != '90') )
		BEGIN
			RAISERROR('템플릿 기반으로 프로젝트 생성시 project_id에 해당하는 프로젝트는 템플릿이어야만 합니다.', 16, 1);
		END

		IF (@project_type_cd = '90')
		BEGIN
			IF (@line_cd IS NOT NULL OR @brand_cd IS NOT NULL OR @fml_brand_cd IS NOT NULL)
			BEGIN
				RAISERROR('템플릿 생성시 라인, 브랜드, 패밀리 데이터를 넣을 수 없습니다.', 16, 1);
			END
		END

		-- 트랜잭션 시작
		BEGIN TRAN
		
		EXEC dbo.spGenerateProjectId @project_id = @new_project_id OUTPUT;
		

		-- 프로젝트 데이터 삽입
		INSERT INTO project (
			project_id,
			project_type_cd,
			line_type_cd,
			line_cd,
			brand_cd,
			fml_brand_cd,
			work_type_cd,
			project_name,
			planed_start_dt,
			planed_end_dt,
			forced_end_dt,
			forced_end_reason,
			planed_working_day,
			is_active,
			kick_off_cd,
			creator_id,
			created_at,
			modifier_id,
			modified_at
		)
		VALUES (
			@new_project_id,
			@project_type_cd,
			dbo.fnGetLineTypeCd(@line_cd),
			@line_cd,
			@brand_cd,
			@fml_brand_cd,
			@work_type_cd,
			@project_name,
			@planed_start_dt,	
			NULL,				-- 프로젝트 생성시에는 planed_end_dt를 안받고 null로 일단 넣고, 킥오프때 계획 종료일중 가장 큰 값으로 넣어준다.
			NULL,
			NULL,
			NULL,
			@is_active,
			CASE WHEN @project_type_cd = '90' THEN '99' -- kick_off_cd 신규 생성시에는 무조건 미착수(90) 상태로 넣는다. mst ref (90104 : 10착수, 20 준비완료, 90 미착수, 99 착수불가)
				 ELSE '90'
			END,				
			@creator_id,
			GETDATE(),
			NULL,
			NULL
		);
	
		-- 템플릿으로 프로젝트 생성한 경우 테스크를 만들어준다.
		-- 일괄 정보 한번 붓고 해야 함.
		--IF ( (@project_id IS NOT NULL) AND EXISTS (SELECT 1 FROM project WITH (NOLOCK) WHERE project_id = @project_id AND project_type_cd = '90') )
		IF (@pApply_tmplt = 1)
		BEGIN
			SET @project_id = @vStd_template_id;
		END

		IF ( (@project_id IS NOT NULL) AND EXISTS (SELECT 1 FROM project WITH (NOLOCK) WHERE project_id = @project_id) )
		BEGIN

			INSERT INTO task (			
				task_name,
				project_id,
				order_no,
				status_cd,
				is_active_cd,
				is_output_need,
				creator_id,
				created_at,
				modifier_id,
				modified_at)
			SELECT			
				T.task_name,
				@new_project_id, -- 4
				T.order_no,
				T.status_cd,
				T.is_active_cd,
				T.is_output_need,
				@creator_id			AS creator_id,
				GETDATE()			AS created_at,
				null				AS modifier_id,
				null				AS modified_at
			FROM task AS T
			WHERE T.project_id = @project_id -- 1
		
			
			SELECT
				A.task_id AS old_task_id,
				B.task_id AS new_task_id
			INTO #task_id_mapper
			FROM 
				(SELECT T.task_id, T.order_no
				FROM task AS T WITH (NOLOCK)
				WHERE T.project_id = @project_id
				AND T.is_active_cd = '10') A
			INNER JOIN 
				(SELECT T.task_id, T.order_no
				FROM task AS T WITH (NOLOCK)
				WHERE T.project_id = @new_project_id
				AND T.is_active_cd = '10') B
			ON A.order_no = B.order_no
			
			INSERT INTO task_dependency (
				task_id,
				project_id,
				dependency_id,
				dependency_cd,
				creator_id,
				created_at,
				modifier_id,
				modified_at)
			SELECT
				TIM1.new_task_id AS task_id,
				@new_project_id		AS project_id,
				TIM2.new_task_id	AS dependency_id,
				TD.dependency_cd	AS dependency_cd,
				@creator_id			AS creator_id,
				GETDATE()			AS created_at,
				null				AS modifier_id,
				null				AS modified_at
			FROM task_dependency AS TD
				INNER JOIN #task_id_mapper AS TIM1
				ON TD.task_id = TIM1.old_task_id
				INNER JOIN #task_id_mapper AS TIM2
				ON TD.dependency_id = TIM2.old_task_id
		
			-- 태스크 피니시 플랜 생성
			INSERT INTO task_finish_plan (			
				project_id,
				task_id,
				plan_cd,
				start_dt,
				end_dt,
				working_day,
				delay_reason,
				creator_id,
				created_at,
				modifier_id,
				modified_at )
			SELECT			
				@new_project_id			AS project_id,
				TIM.new_task_id			AS task_id,
				plan_cd					AS plan_cd,
				NULL					AS start_dt,
				NULL					AS end_dt,
				working_day				AS working_day,
				delay_reason			AS delay_reason,
				@creator_id				AS creator_id,
				GETDATE()				AS created_at,
				modifier_id				AS modifier_id,
				modified_at				AS modified_at
			FROM task_finish_plan AS TFP
				INNER JOIN #task_id_mapper AS TIM
				ON TFP.task_id = TIM.old_task_id
			WHERE TFP.project_id = @project_id

		END

		COMMIT TRAN

		-- 표준, 계획 일정을 채워 넣는다.
		DECLARE @vResult_cd INT, @vResult_msg VARCHAR(100);			
		EXEC [dbo].[spMakeTaskFinishPlanDate] @pProject_id = @new_project_id, @result_cd = @vResult_cd OUTPUT, @result_msg = @vResult_msg OUTPUT;
		
		IF (@vResult_cd = -1)
		BEGIN
			--CATCH로 이동
			RAISERROR('태스크 종료 일정 설정 오류 발생', 16, 1);
		END
		
		-- 채워넣은 계획일정을 실제로 복제 한다.
		DECLARE @vProject_type_cd AS VARCHAR(8) = NULL;
		SELECT
			@vProject_type_cd = P.project_type_cd
		FROM dbo.project AS P WITH (NOLOCK)
		WHERE P.project_id = @new_project_id

		IF (@vProject_type_cd != '90')
		BEGIN
			INSERT INTO dbo.task_finish_plan
			SELECT
				TFP.project_id,
				TFP.task_id,
				'20' AS plan_cd,
				TFP.start_dt,
				TFP.end_dt,
				TFP.working_day,
				TFP.delay_reason_cd,
				TFP.delay_reason,
				TFP.creator_id,
				GETDATE() AS created_at,
				NULL AS modifier_id,
				NULL AS modified_at
			FROM dbo.task_finish_plan AS TFP
			WHERE TFP.project_id = @new_project_id
			AND TFP.plan_cd = '10';
		END

		SELECT @new_project_id AS project_id;

		SET @vSeverity = 0;
		SET @result_cd = 0;
		SET @result_msg = '성공';    

	END TRY
	BEGIN CATCH
		IF @@TRANCOUNT > 0
			ROLLBACK TRAN;
		
		-- 실패 메시지
		SET @vSeverity = ERROR_SEVERITY();
		SET @result_cd = -1;
		SET @result_msg = ERROR_MESSAGE();
	END CATCH


	-- 로깅	
	DECLARE @log_param NVARCHAR(MAX);

	SET @log_param =
		'@project_id = '       + ISNULL(CAST(@project_id AS VARCHAR), 'NULL') + ', ' +
		'@project_type_cd = '  + ISNULL(@project_type_cd, 'NULL') + ', ' +
		'@line_cd = '          + ISNULL(@line_cd, 'NULL') + ', ' +
		'@brand_cd = '         + ISNULL(@brand_cd, 'NULL') + ', ' +
		'@fml_brand_cd = '     + ISNULL(@fml_brand_cd, 'NULL') + ', ' +
		'@work_type_cd = '     + ISNULL(@work_type_cd, 'NULL') + ', ' +
		'@project_name = '     + ISNULL(@project_name, 'NULL') + ', ' +
		'@planed_start_dt = '  + ISNULL(@planed_start_dt, 'NULL') + ', ' +
		'@is_active = '        + ISNULL(@is_active, 'NULL') + ', ' +
		'@creator_id = '       + ISNULL(@creator_id, 'NULL');


	INSERT INTO dbo.use_log (caller_id, severity, project_id, log_dt, log_message, proc_name, proc_param, result_cd, result_msg, created_at)
	VALUES(ISNULL(CAST(@creator_id AS VARCHAR(8)), 'UNKNOWN'), @vSeverity, ISNULL(@new_project_id, 0), CONVERT(CHAR(10), GETDATE(), 120), @project_name + ' 프로젝트 생성. [' + ISNULL(CAST(@project_id AS VARCHAR(50)), '베이스없음') + ']', '[spInsertProjectInfo]', @log_param, @result_cd, @result_msg, GETDATE());

	RETURN;

END


--- Procedure 49 ---
ProcedureName: spUpdateAccessStateForUser
ProcedureDefinition:

-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
/* 실행예제
DECLARE @result_cd INT, @result_msg VARCHAR(100);
EXEC [dbo].[spUpdateAccessStateForUser] @pMember_id = '2204901', @pAccess_yn = 'N', @pCreator_id = '2204901', @result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT;
SELECT @result_cd as result_cd, @result_msg as result_msg;
*/
-- =============================================
CREATE PROCEDURE [dbo].[spUpdateAccessStateForUser]
	@pMember_id			VARCHAR(7)		= NULL,
	@pAccess_yn			CHAR(1)			= NULL,
	@pCreator_id		VARCHAR(7)		= NULL,
    @result_cd			INT				OUTPUT,
    @result_msg			VARCHAR(200)	OUTPUT
AS
BEGIN
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	DECLARE @vSeverity				INT = NULL;
	DECLARE @vAccess_yn				CHAR(1) = NULL;
	
    BEGIN TRY

		IF (@pMember_id IS NULL OR @pAccess_yn IS NULL)
		BEGIN
			RAISERROR('파라미터가 누락되었습니다.', 16, 1);
		END

		SET @vAccess_yn = UPPER(LTRIM(RTRIM(@pAccess_yn)));

		IF (@vAccess_yn NOT IN ('Y', 'N'))
		BEGIN
			RAISERROR('액세스여부 파라미터는 Y 또는 N 만 가능 합니다.', 16, 1);
		END

		IF NOT EXISTS (SELECT 1 FROM dbo.hr_master AS HRM WITH (NOLOCK) WHERE HRM.EMP_ID = @pMember_id)
		BEGIN
			RAISERROR('존재하지 않는 회원 입니다.', 16, 1);
		END

		IF NOT EXISTS(	SELECT 1
						FROM dbo.login_control AS LC WITH (NOLOCK)
						WHERE LC.member_id = @pMember_id)
		BEGIN
			INSERT INTO dbo.login_control(member_id, access_yn, creator_id, created_at, modifier_id, modified_at)
			VALUES (@pMember_id, @vAccess_yn, @pCreator_id, GETDATE(), NULL, NULL);
		END
		ELSE
		BEGIN
			UPDATE LC SET
				LC.access_yn = @vAccess_yn,
				LC.modifier_id = @pCreator_id,
				LC.modified_at = GETDATE()
			FROM dbo.login_control AS LC WITH (NOLOCK)
			WHERE LC.member_id = @pMember_id
		END

		SET @vSeverity = 0;
		SET @result_cd = 0;
		SET @result_msg = '성공';

	END TRY

	BEGIN CATCH
		SET @result_cd = -1;
		SET @result_msg = ERROR_MESSAGE();
		SET @vSeverity = ERROR_SEVERITY();
	END CATCH

	DECLARE @log_param VARCHAR(MAX);

	SET @log_param = '@pMember_id = ' + ISNULL(@pMember_id, 'NULL') + ', '
				   + '@pAccess_yn = ' + ISNULL(@pAccess_yn, 'NULL') + ', ' +
				   + '@pCreator_id = ' + ISNULL(@pCreator_id, 'NULL') + ', ';
				   
	INSERT INTO dbo.use_log (caller_id, severity, project_id, log_dt, log_message, proc_name, proc_param, result_cd, result_msg, created_at)
	VALUES(ISNULL(CAST(@pCreator_id AS VARCHAR(8)), 'UNKNOWN'), @vSeverity, 0, CONVERT(CHAR(10), GETDATE(), 120), @pMember_id + ' 사용자의 접근을 ' + @vAccess_yn + '로 변경 하였습니다.', '[spUpdateAccessStateForUser]', @log_param, @result_cd, @result_msg, GETDATE());


	RETURN;
END


--- Procedure 50 ---
ProcedureName: spInsertProjectMember
ProcedureDefinition:


-- =============================================
-- Author:		JayKwon
-- Create date: 2025-05-20
-- Description:	프로젝트 멤버 참여 신청
-- mst ref : 90102, 10 승인, 20 신청, 90 반려
/* SAMPLE EXECUTION

DECLARE @result_cd INT, @result_msg VARCHAR(100);
EXEC [dbo].[spInsertProjectMember] @project_id = 2, @member_id = '2400010', @status_cd = 20, @creator_id = '2400010' , @result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT;
SELECT @result_cd as result_cd, @result_msg as result_msg;

DECLARE @result_cd INT, @result_msg VARCHAR(100);
EXEC [dbo].[spInsertProjectMember] @project_id = 2, @member_id = '2400010', @status_cd = 10, @creator_id = 1 , @result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT;
SELECT @result_cd as result_cd, @result_msg as result_msg;

DECLARE @result_cd INT, @result_msg VARCHAR(100);
EXEC [dbo].[spInsertProjectMember] @project_id = 2, @member_id = '2400010, @status_cd = 20, @creator_id = 1 , @result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT;
SELECT @result_cd as result_cd, @result_msg as result_msg;


*/
-- =============================================
CREATE PROCEDURE [dbo].[spInsertProjectMember]
	@project_id				INT,
	@member_id				VARCHAR(7),
	@status_cd				VARCHAR(8),-- master 10:승인, 20:신청, 90:반려
    @creator_id				VARCHAR(7),
    @result_cd				INT OUTPUT,
    @result_msg				VARCHAR(200) OUTPUT
AS
BEGIN
	
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
		
	-- 프로젝트 유효성 체크
    IF NOT EXISTS (
        SELECT 1
        FROM project WITH (NOLOCK)
        WHERE project_id = @project_id
    )
    BEGIN
		SET @result_cd = 1;
		SET @result_msg = CAST(@project_id AS VARCHAR(8)) + ' : 존재하지 않는 프로젝트 입니다.'		
        RETURN;
    END
	
	-- 마스터 코드 유효성 체크
    IF NOT EXISTS (
        SELECT 1
        FROM code_master WITH (NOLOCK)
        WHERE group_cd = '90102'
		AND detail_cd = @status_cd 
    )
    BEGIN		
		SET @result_cd = 1;
		SET @result_msg = CAST(@status_cd AS VARCHAR(8)) + ' : 존재하지 않는 구분자 입니다.'        
        RETURN;
    END
	
	-- 템플릿 프로젝트에는 멤버를 넣을 수 없다.
	IF EXISTS (
		SELECT 1
		FROM dbo.project AS P WITH (NOLOCK)
		WHERE P.project_id = @project_id
		AND P.project_type_cd = '90')
	BEGIN
		SET @result_cd = 1;
		SET @result_msg = '템플릿에는 멤버를 넣을 수 없습니다.'        
        RETURN;
	END
	
	-- master 10:승인, 20:신청, 90:반려
	IF EXISTS (SELECT 1 FROM project_member WITH (NOLOCK) WHERE project_id = @project_id AND member_id = @member_id AND status_cd = '10')
	BEGIN	
		SET @result_cd = 1;
		SET @result_msg = CAST((SELECT [NAME] AS member_name FROM dbo.hr_master WHERE EMP_ID = @member_id) AS VARCHAR(8)) + '님은 이미 프로젝트에 참여중 입니다.';
        RETURN;
    END

	IF EXISTS (SELECT 1 FROM project_member WITH (NOLOCK) WHERE project_id = @project_id AND member_id = @member_id AND status_cd = '20')
	BEGIN				
		SET @result_cd = 1;
		SET @result_msg = CAST((SELECT [NAME] AS member_name FROM dbo.hr_master WHERE EMP_ID = @member_id) AS VARCHAR(8)) + '님은 프로젝트에 참여 신청 상태 입니다.';        
        RETURN;
    END

	IF EXISTS (SELECT 1 FROM project_member WITH (NOLOCK) WHERE project_id = @project_id AND member_id = @member_id AND status_cd = '90')
	BEGIN				
		SET @result_cd = 1;
		SET @result_msg = CAST((SELECT [NAME] AS member_name FROM dbo.hr_master WHERE EMP_ID = @member_id) AS VARCHAR(8)) + '님은 프로젝트에 참여 거부 상태 입니다.';            
        RETURN;
    END

	BEGIN TRY
		INSERT INTO project_member(
			project_id,
			member_id,
			status_cd,
			creator_id,
			created_at,
			modifier_id,
			modified_at
		)
		VALUES (
			@project_id,
			@member_id,
			@status_cd,
			@creator_id,
			GETDATE(),
			null,
			null
		)

		SET @result_cd = 0;
		SET @result_msg = '성공';

	END TRY
	BEGIN CATCH
		SET @result_cd = -1;
		SET @result_msg = ERROR_MESSAGE();
	END CATCH	

END


--- Procedure 51 ---
ProcedureName: spInsertProjectOwner
ProcedureDefinition:

-- =============================================
-- Author:		Jay Kwon
-- Create date: 2025-06-09
-- Description:	프로젝트에 담당자(오너)를 할당한다.
/*
-- 프로젝트 오너 지정
DECLARE @result_cd INT, @result_msg VARCHAR(100);
EXEC [dbo].[spInsertProjectOwner] @pProject_id = 25080009, @pMember_ids = '2400001, 2400002, 2400003', @pIsActive_cd = '10', @pCreator_id = 1,@result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT;
SELECT @result_cd as result_cd, @result_msg as result_msg;

*/
-- =============================================
CREATE PROCEDURE [dbo].[spInsertProjectOwner]
	@pProject_id		INT,
	@pMember_ids		VARCHAR(MAX),	-- CSV 형태로 받음 '2400001,2400002,...'
	@pIsActive_cd		VARCHAR(8) = '10',
	@pCreator_id		VARCHAR(7),
    @result_cd			INT				OUTPUT,
    @result_msg			VARCHAR(200)	OUTPUT

AS
BEGIN
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
	
	DECLARE @vSeverity				INT = NULL;


	BEGIN TRY
		-- 프로젝트 유효성 체크
		IF NOT EXISTS (
			SELECT 1
			FROM dbo.project AS P WITH (NOLOCK)
			WHERE P.project_id = @pProject_id
		)
		BEGIN
			SET @result_msg = CAST(@pProject_id AS VARCHAR(8)) + ' : 존재하지 않는 프로젝트 id 입니다.';		        
			RAISERROR(@result_msg, 16, 1);
		END

		-- 템플릿에는 할당 불가
		IF EXISTS(SELECT 1 FROM dbo.project AS P WITH (NOLOCK) WHERE P.project_id = @pProject_id AND P.project_type_cd = '90')
		BEGIN
			SET @result_msg = '템플릿에는 마케터를 할당 할 수 없습니다.';
			RAISERROR(@result_msg, 16, 1);
		END


		-- 문자열을 테이블로 변환
		DECLARE @member TABLE (member_id VARCHAR(7));

		INSERT INTO @member (member_id)
		SELECT DISTINCT TRIM(value)
		FROM STRING_SPLIT(@pMember_ids, ',')

		-- 회원 유효성 검사
		IF EXISTS(	SELECT 1
					FROM @member AS M
						LEFT JOIN dbo.hr_master AS HRM WITH (NOLOCK)
						ON M.member_id = HRM.EMP_ID
					WHERE HRM.EMP_ID IS NULL)
		BEGIN			
			SET @result_msg = '유효하지 않은 회원 아이디가 전달 되었습니다.';		
			RAISERROR(@result_msg, 16, 1);
		END
	
		-- 중복 제거 및 이미 등록된 항목 제외 후 삽입
		INSERT INTO project_owner (
			project_id,
			member_id,
			is_active_cd,
			creator_id,
			created_at,
			modifier_id,
			modified_at)
		SELECT
			@pProject_id,
			M.member_id,
			@pIsActive_cd,
			@pCreator_id,
			GETDATE(),
			NULL,
			NULL
		FROM @member M
			LEFT JOIN dbo.project_owner AS PO WITH (NOLOCK)
			ON M.member_id = PO.member_id
			AND PO.project_id = @pProject_id
		WHERE PO.member_id IS NULL;

		SET @vSeverity = 0;
		SET @result_cd = 0;
		SET @result_msg = '성공';

	END TRY
	BEGIN CATCH
		SET @result_cd = -1;
		SET @result_msg = ERROR_MESSAGE();
		SET @vSeverity = ERROR_SEVERITY();

	END CATCH
	
	DECLARE @log_param VARCHAR(MAX)

	SET @log_param = 
		  '@pProject_id = ' + ISNULL(CAST(@pProject_id AS VARCHAR), 'NULL') + ', '
		+ '@pMember_ids = ''' + ISNULL(@pMember_ids, 'NULL') + ''', '
		+ '@pIsActive_cd = ''' + ISNULL(@pIsActive_cd, 'NULL') + ''', '
		+ '@pCreator_id = ''' + ISNULL(@pCreator_id, 'NULL') + ''''

	INSERT INTO dbo.use_log (caller_id, severity, project_id, log_dt, log_message, proc_name, proc_param, result_cd, result_msg, created_at)
	VALUES(ISNULL(CAST(@pCreator_id AS VARCHAR(8)), 'UNKNOWN'), @vSeverity, ISNULL(@pProject_id,0), CONVERT(CHAR(10), GETDATE(), 120),'[' + @pMember_ids + ']' + ' 마케터 할당', '[spInsertProjectOwner]', @log_param, @result_cd, @result_msg, GETDATE());


	RETURN;
END


--- Procedure 52 ---
ProcedureName: spGenerateProjectId
ProcedureDefinition:
-- =============================================
-- Author:		Jay Kwon
-- Create date: 2025-07-21
-- Description:	프로젝트 아이디를 발번한다.
/*
DECLARE @project_id INT;
EXEC spGenerateProjectId @project_id = @project_id OUTPUT;
SELECT @project_id;
*/
-- =============================================
CREATE PROCEDURE [dbo].[spGenerateProjectId]
    @project_id INT OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    SET XACT_ABORT ON;

    DECLARE @yymm CHAR(4) = FORMAT(GETDATE(), 'yyMM');
    DECLARE @seq INT;
    DECLARE @existing_max_id INT;
    DECLARE @candidate_id INT;

    BEGIN TRAN;

    -- 1. 시퀀스 증가
    MERGE project_seq AS seq
    USING (SELECT @yymm AS yymm) AS src
    ON (seq.yymm = src.yymm)
    WHEN MATCHED THEN
        UPDATE SET last_seq = last_seq + 1
    WHEN NOT MATCHED THEN
        INSERT (yymm, last_seq) VALUES (@yymm, 1);

    -- 2. 현재 시퀀스 조회
    SELECT @seq = last_seq FROM project_seq WHERE yymm = @yymm;

    -- 3. 후보 project_id 생성: YYMM + SEQ
    SET @candidate_id = CAST(@yymm + RIGHT('0000' + CAST(@seq AS VARCHAR), 4) AS INT);

    -- 4. 현재 YYMM 기준, project 테이블의 최대 ID와 비교
    SELECT @existing_max_id = MAX(P.project_id)
    FROM dbo.project AS P WITH (NOLOCK)
    WHERE LEFT(CAST(P.project_id AS VARCHAR), 4) = @yymm;

    -- 5. 이미 존재하는 값보다 작거나 같으면 시퀀스를 보정
    IF @existing_max_id IS NOT NULL AND @candidate_id <= @existing_max_id
    BEGIN
        -- 기존 MAX project_id의 시퀀스 + 1 계산
        SET @seq = RIGHT(CAST(@existing_max_id AS VARCHAR), 4) + 1;

        -- 보정한 시퀀스로 project_seq 갱신
        UPDATE project_seq SET last_seq = @seq WHERE yymm = @yymm;

        -- 새로 계산한 project_id
        SET @candidate_id = CAST(@yymm + RIGHT('0000' + CAST(@seq AS VARCHAR), 4) AS INT);
    END

    -- 6. 결과 반환
    SET @project_id = @candidate_id;

    COMMIT;
END;


--- Procedure 53 ---
ProcedureName: spInsertProjectTask
ProcedureDefinition:
-- =============================================
-- Author:		JayKwon
-- Create date: 2025-05-20
-- Description:	단건 태스크 인서트
-- SAMPLE EXECUTION
-- select * from project where project_id = 15
-- select * from task where project_id = 15; select * from task_dependency; select * from task_finish_plan;
/*
DECLARE @task_id INT, @result_cd INT, @result_msg VARCHAR(100);
EXEC [dbo].[spInsertProjectTask] @task_name = '표시사항', @project_id = 15, @dependency_id = null, @dependency_cd = null, @pre_order_no = 3, @post_order_no = null, 
								 @planed_start_dt = '2025-06-10', @planed_end_dt = '2025-06-12', @working_day = 10, @status_cd = '10', @is_active_cd = '10', @is_output_need = '10', @creator_id= 1 , 
								 @task_id =  @task_id OUTPUT , @result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT;
SELECT @task_id as task_id, @result_cd as result_cd, @result_msg as result_msg;


DECLARE @task_id INT, @result_cd INT, @result_msg VARCHAR(100);
EXEC [dbo].[spInsertProjectTask] @task_name = '표시사항', @project_id = 16, @dependency_id = 116, @dependency_cd = '20', @pre_order_no = 2, @post_order_no = null,
								 @planed_start_dt = '2025-06-10', @planed_end_dt = '2025-06-12', @working_day = 5, @status_cd = '10', @is_active_cd = '10', @is_output_need = '10', @creator_id= 1 , 
								 @task_id =  @task_id OUTPUT , @result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT;
SELECT @task_id as task_id, @result_cd as result_cd, @result_msg as result_msg;

*/
-- truncate table task; truncate table task_dependency;  truncate table task_finish_plan;
-- EXEC [dbo].[spInsertProjectTask] '표시문안', 1, null, null, null, null, '2025-06-15', '2025-06-17', '10', '10', '10',1
-- EXEC [dbo].[spInsertProjectTask] '디자인확정', 1, null, null, 100, null, '2025-06-18', '2025-06-22', '10', '10', '10',1
-- EXEC [dbo].[spInsertProjectTask] '표시사항', 1, null, null, null, 100, '2025-06-13', '2025-06-14', '10', '10', '10',1
-- EXEC [dbo].[spInsertProjectTask] '선행원자재발주', 1, 3, '10', 50, 100, '2025-06-13', '2025-06-14', '10', '10', '90',1
-- EXEC [dbo].[spInsertProjectTask] '도입보고', 1, null, null, null, 50, '2025-06-10', '2025-06-12', '10', '10', '10',1
-- EXEC [dbo].[spInsertProjectTask] '상세페이지제작', 1, 5, 10, 25, 50, '2025-06-10', '2025-06-12', '10', '10', '10',1
-- EXEC [dbo].[spInsertProjectTask] '체인등록', 1, 2, 10, 101, null, '2025-06-18', '2025-06-20', '10', '10', '90',1
-- EXEC [dbo].[spInsertProjectTask] '원부자재발주+입고', 1, 2, 20, 102, null, '2025-06-23', '2025-06-25', '10', '10', '10',1
-- EXEC [dbo].[spInsertProjectTask] '영업프로모션', 1, 2, 10, 101, 102, '2025-06-20', '2025-06-22', '10', '10', '10',1
-- =============================================
CREATE PROCEDURE [dbo].[spInsertProjectTask]
	@task_name			VARCHAR(200),
    @project_id			INT,
    @dependency_id		INT,			-- null 인 경우 뎁스1
	@dependency_cd		VARCHAR(8),		-- master ref : 10 하위, 20 후행
	@pre_order_no		FLOAT,			-- 앞뒤 태스크의 order_no를 던져준다.
	@post_order_no		FLOAT,
	@planed_start_dt		VARCHAR(10),	-- 태스크 최초 등록시에는 계획 시작일, 종료일을 입력 해준다.
	@planed_end_dt		VARCHAR(10),	-- 태스크 최초 등록시에는 계획 시작일, 종료일을 입력 해준다.    
	@working_day		INT,			-- 템플릿 태스크 인 경우 워킹데이를 넣어준다.
	@status_cd			VARCHAR(8),		-- 태스크 상태(90300) : 10 대기, 20 진행, 30 지연, 90 완료
    @is_active_cd		VARCHAR(8),		-- 사용 여부(90100) : 10 사용, 90 미사용
	@is_output_need		VARCHAR(8),		-- 산출물 여부(90100) : 10 사용, 90 미사용
    @creator_id			VARCHAR(7),
	@task_id			INT				OUTPUT,
    @result_cd			INT				OUTPUT,
    @result_msg			VARCHAR(200)	OUTPUT
AS
BEGIN
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
	
	DECLARE @vTemplate_pjt			INT = NULL;
	DECLARE @vProject_type_cd		VARCHAR(8) = NULL;
	DECLARE @vSeverity				INT = NULL;

	-- 만약 템플릿 프로젝트에 태스크를 추가하는것이라면 날짜는 다 지우고 워킹데이만 넣어준다.
	IF EXISTS(SELECT 1 FROM dbo.project AS P WITH (NOLOCK) WHERE P.project_id = @project_id AND P.project_type_cd = '90')
	BEGIN
		SET @vTemplate_pjt = 1;
		SET @planed_start_dt = NULL;
		SET @planed_end_dt = NULL;
	END

	BEGIN TRY

		IF NOT EXISTS(SELECT 1 FROM dbo.code_master AS CM WITH (NOLOCK) WHERE CM.group_cd = '90100' AND CM.detail_cd = @is_output_need)
		BEGIN
			RAISERROR('산출물 여부 코드는 10(사용), 90(미사용)만 들어올 수 있습니다.', 16, 1);
		END

		IF (@vTemplate_pjt != 1)
		BEGIN
			-- 날짜 형식 유효성 검사
			IF (LEN(@planed_start_dt) != 10 OR TRY_CONVERT(DATE, @planed_start_dt) IS NULL)
			BEGIN
				RAISERROR('시작일(plan_start_dt)의 형식이 잘못되었습니다. (예: 2025-07-02)', 16, 1);
			END

			IF (LEN(@planed_end_dt) != 10 OR TRY_CONVERT(DATE, @planed_end_dt) IS NULL)
			BEGIN
				RAISERROR('종료일(plan_end_dt)의 형식이 잘못되었습니다. (예: 2025-07-15)', 16, 1);
			END
		END

		-- 프로젝트 id 유효성 체크
		IF NOT EXISTS (
			SELECT 1
			FROM project WITH (NOLOCK)
			WHERE project_id = @project_id
		)
		BEGIN
			SET @result_msg = CAST(@project_id AS VARCHAR(8)) + ' : 존재하지 않는 프로젝트 입니다.';		        

			RAISERROR(@result_msg, 16, 1);
		END
	
		-- 프로젝트 id 유효성 체크
		IF ( (@pre_order_no IS NOT NULL) AND NOT EXISTS (
			SELECT 1
			FROM dbo.task AS T WITH (NOLOCK)
			WHERE T.project_id = @project_id
			AND T.order_no = @pre_order_no
		) ) OR (
			( @post_order_no IS NOT NULL) AND NOT EXISTS (
			SELECT 1
			FROM dbo.task AS T WITH (NOLOCK)
			WHERE T.project_id = @project_id
			AND T.order_no = @post_order_no
		) )
		BEGIN		
			RAISERROR('존재하지 않는 order_no입니다.', 16, 1);
		END

		-- dependency 유효성 체크
		IF @dependency_id IS NOT NULL
		BEGIN
			IF NOT EXISTS (
				SELECT 1
				FROM task AS T WITH (NOLOCK)
				WHERE T.task_id = @dependency_id
				AND T.project_id = @project_id
			)
			BEGIN
			
				SET @result_msg = CAST(@dependency_id AS VARCHAR(8)) + ' : 존재하지 않는 dependency TASK ID 입니다.';
				RAISERROR(@result_msg, 16, 1);
			
			END
		END

		-- 킥오프가 된 상태라면 디펜던시가 있는 태스크가 중간에 추가될 수 없다. (개별만 가능함)
		IF (EXISTS(	SELECT
						1
					FROM dbo.project as P WITH (NOLOCK)
					WHERE P.project_id = @project_id
					AND P.kick_off_cd = '10') AND (@dependency_id IS NOT NULL) )
		BEGIN
			SET @result_msg = '이미 킥오프 된 프로젝트라면 개별 태스크만 추가 가능 합니다.';
			RAISERROR(@result_msg, 16, 1);
		END

		SELECT
			@vProject_type_cd = P.project_type_cd	-- MST(90200, 프로젝트타입) 10:프로젝트, 20 테스트프로젝트, 90 템플릿
		FROM dbo.project AS P WITH (NOLOCK)
		WHERE P.project_id = @project_id	

	
		BEGIN TRAN
			INSERT INTO task (
				task_name,
				project_id,
				order_no,
				status_cd,
				is_active_cd,
				is_output_need,
				creator_id,
				created_at,
				modifier_id,
				modified_at
			)
			VALUES (
				@task_name,
				@project_id,
				dbo.fnCalcOrderNo(@project_id, @pre_order_no, @post_order_no),
				@status_cd,
				@is_active_cd,
				@is_output_need,
				@creator_id,
				GETDATE(),
				null,
				null
			);
		      
			SET @task_id = SCOPE_IDENTITY();
			
			IF ( (@dependency_id IS NOT NULL) AND EXISTS (SELECT 1 FROM dbo.task AS T WITH (NOLOCK) WHERE T.task_id = @dependency_id) )
			BEGIN
				INSERT INTO task_dependency
				(
					task_id,
					project_id,
					dependency_id,
					dependency_cd,
					creator_id,
					created_at,
					modifier_id,
					modified_at
				)
				VALUES
				(
					@task_id,
					@project_id,
					@dependency_id,
					@dependency_cd,
					@creator_id,
					GETDATE(),
					null,
					null
				)
			END

			-- 킥오프 한 프로젝트에 태스크를 추가 하는 경우
			IF EXISTS (SELECT * FROM dbo.project AS P WITH (NOLOCK) WHERE P.project_id = @project_id AND P.kick_off_cd = '10' AND P.project_type_cd = '10')
			BEGIN
				INSERT INTO task_finish_plan
				(		
					task_id,
					project_id,
					plan_cd,
					start_dt,
					end_dt,
					working_day, -- 템플릿 태스크 추가 인 경우 넣어준다.
					delay_reason_cd,
					delay_reason,
					creator_id,
					created_at,
					modifier_id,
					modified_at
				) VALUES
				(
					@task_id,
					@project_id,
					'20',
					@planed_start_dt,
					@planed_end_dt,
					dbo.fnCalcWorkingDay(@planed_start_dt, @planed_end_dt), 
					null,
					null,
					@creator_id,
					GETDATE(),
					null,
					null
				);

				-- 생성한 내역 복제
				DECLARE @vFinishPlanId INT = NULL;
				SET @vFinishPlanId = SCOPE_IDENTITY();

				INSERT INTO dbo.task_finish_plan
				SELECT					
					project_id,
					task_id,
					'30'			AS plan_cd,
					start_dt,
					end_dt,
					working_day,
					delay_reason_cd,
					delay_reason,
					creator_id,
					created_at,
					modifier_id,
					modified_at
				FROM dbo.task_finish_plan AS TFP WITH (NOLOCK)
				WHERE TFP.finish_plan_id = @vFinishPlanId
			END
			ELSE
			BEGIN
				INSERT INTO task_finish_plan
				(		
					task_id,
					project_id,
					plan_cd,
					start_dt,
					end_dt,
					working_day, -- 템플릿 태스크 추가 인 경우 넣어준다.
					delay_reason_cd,
					delay_reason,
					creator_id,
					created_at,
					modifier_id,
					modified_at
				) VALUES
				(
					@task_id,
					@project_id,
					CASE WHEN @vProject_type_cd = '90' THEN '10' -- master ref : 10 표준, 20 계획, 30 실제, 40 지연
							ELSE '20'
					END,
					@planed_start_dt,
					@planed_end_dt,
					CASE WHEN @vTemplate_pjt = 1 THEN @working_day ELSE NULL END, 
					null,
					null,
					@creator_id,
					GETDATE(),
					null,
					null
				)
			END

			

		COMMIT TRAN
		
		-- 성공
		SET @vSeverity = 0;
		SET @result_cd = 0;
		SET @result_msg = '성공';

	END TRY

	BEGIN CATCH
		IF @@TRANCOUNT > 0
			ROLLBACK TRAN;

		SET @result_cd = -1;
		SET @result_msg = ERROR_MESSAGE();
		SET @vSeverity = ERROR_SEVERITY();

	END CATCH

	-- 로깅	
	DECLARE @log_param NVARCHAR(MAX);

	SET @log_param =
		'@task_name = '        + ISNULL(@task_name, 'NULL') + ', ' +
		'@project_id = '       + ISNULL(CAST(@project_id AS VARCHAR), 'NULL') + ', ' +
		'@dependency_id = '    + ISNULL(CAST(@dependency_id AS VARCHAR), 'NULL') + ', ' +
		'@dependency_cd = '    + ISNULL(@dependency_cd, 'NULL') + ', ' +
		'@pre_order_no = '     + ISNULL(CAST(@pre_order_no AS VARCHAR), 'NULL') + ', ' +
		'@post_order_no = '    + ISNULL(CAST(@post_order_no AS VARCHAR), 'NULL') + ', ' +
		'@planed_start_dt = '    + ISNULL(@planed_start_dt, 'NULL') + ', ' +
		'@planed_end_dt = '      + ISNULL(@planed_end_dt, 'NULL') + ', ' +
		'@working_day = '      + ISNULL(CAST(@working_day AS VARCHAR), 'NULL') + ', ' +
		'@status_cd = '        + ISNULL(@status_cd, 'NULL') + ', ' +
		'@is_active_cd = '     + ISNULL(@is_active_cd, 'NULL') + ', ' +
		'@is_output_need = '   + ISNULL(@is_output_need, 'NULL') + ', ' +
		'@creator_id = '       + ISNULL(@creator_id, 'NULL');

	INSERT INTO dbo.use_log (caller_id, severity, project_id, log_dt, log_message, proc_name, proc_param, result_cd, result_msg, created_at)
	VALUES(ISNULL(CAST(@creator_id AS VARCHAR(8)), 'UNKNOWN'), @vSeverity, ISNULL(@project_id,0), CONVERT(CHAR(10), GETDATE(), 120), ISNULL(CAST(@task_id AS VARCHAR(8)), 'UNKNOWN') + ' [' + ISNULL(@task_name, 'UNKNOWN') + '] 태스크 생성', '[spInsertProjectTask]', @log_param, @result_cd, @result_msg, GETDATE());

	RETURN;
END


--- Procedure 54 ---
ProcedureName: spInsertTaskOwner
ProcedureDefinition:
-- =============================================
-- Author:		Jay Kwon
-- Create date: 2025-06-09
-- Description:	태스크 담당자 할당
-- select * from task where project_id =6;
/*

DECLARE @result_cd INT, @result_msg VARCHAR(100);
EXEC [dbo].[spInsertTaskOwner] @pTask_id = 25,  @pMember_ids = '2400000, 2400001', @pIsActive_cd = '10', @pCreator_id = 1 , @result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT;
SELECT @result_cd as result_cd, @result_msg as result_msg;
*/
-- =============================================
CREATE PROCEDURE [dbo].[spInsertTaskOwner]
	@pTask_id			INT				= NULL,
	@pMember_ids		VARCHAR(MAX)	= NULL,	
	@pIsActive_cd		VARCHAR(8)		= NULL,
	@pCreator_id		VARCHAR(7)		= NULL,
    @result_cd			INT OUTPUT,
    @result_msg			VARCHAR(200) OUTPUT

AS
BEGIN
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	DECLARE @MemberList TABLE (member_id VARCHAR(7));

	-- CSV 문자열을 파싱해서 테이블에 삽입
	;WITH Split AS (
		SELECT LTRIM(RTRIM(value)) AS member_id
		FROM STRING_SPLIT(@pMember_ids, ',')
	)
	INSERT INTO @MemberList(member_id)
	SELECT member_id FROM Split WHERE member_id IS NOT NULL;

	-- 템플릿 프로젝트 검사
	IF EXISTS (
		SELECT 1
		FROM dbo.project AS P WITH (NOLOCK)
		INNER JOIN dbo.task AS T WITH (NOLOCK) ON P.project_id = T.project_id
		WHERE T.task_id = @pTask_id
		AND P.project_type_cd != '10'
	)
	BEGIN
		SET @result_cd = 1;
		SET @result_msg = '템플릿 프로젝트의 태스크에는 담당자를 할당할 수 없습니다.';
		RETURN;
	END

	-- 유효한 태스크인지 확인
	IF NOT EXISTS (
		SELECT 1 FROM dbo.task AS T WITH (NOLOCK) WHERE T.task_id = @pTask_id
	)
	BEGIN
		SET @result_cd = 1;
		SET @result_msg = CAST(@pTask_id AS VARCHAR(8)) + ' : 존재하지 않는 태스크id 입니다.';
		RETURN;
	END

	BEGIN TRY
		BEGIN TRAN
			DECLARE @member_id VARCHAR(7);

			DECLARE member_cursor CURSOR FOR
				SELECT member_id FROM @MemberList;

			OPEN member_cursor;
			FETCH NEXT FROM member_cursor INTO @member_id;

			WHILE @@FETCH_STATUS = 0
			BEGIN
				IF NOT EXISTS (
					SELECT 1
					FROM dbo.task_owner AS TOWN WITH (NOLOCK)
					WHERE TOWN.task_id = @pTask_id
					AND TOWN.member_id = @member_id
				)
				BEGIN
					INSERT INTO task_owner (
						task_id,
						member_id,
						is_active_cd,
						creator_id,
						created_at,
						modifier_id,
						modified_at
					)
					VALUES (
						@pTask_id,
						@member_id,
						@pIsActive_cd,
						@pCreator_id,
						GETDATE(),
						NULL,
						NULL
					);
				END

				FETCH NEXT FROM member_cursor INTO @member_id;
			END

			CLOSE member_cursor;
			DEALLOCATE member_cursor;
		
		COMMIT TRAN;

		SET @result_cd = 0;
		SET @result_msg = '성공';

	END TRY
	BEGIN CATCH
		ROLLBACK TRAN;
		SET @result_cd = -1;
		SET @result_msg = ERROR_MESSAGE();
	END CATCH
END

--- Procedure 55 ---
ProcedureName: spIsAccsProject
ProcedureDefinition:
-- =============================================
-- Author:		JayKwon
-- Create date: 2025-05-23
-- Description:	프로젝트에 접근 가능한지 확인
/* SAMPLE EXEC
DECLARE @result_cd INT, @result_msg VARCHAR(100);
EXEC [dbo].[spIsAccsProject] @pProject_id = 25080009, @pMember_id = '2400000', @result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT;
SELECT @result_cd as result_cd, @result_msg as result_msg;
*/
-- =============================================
CREATE PROCEDURE [dbo].[spIsAccsProject]
    @pProject_id		INT = NULL,
	@pMember_id			VARCHAR(7) = NULL,
    @result_cd			INT OUTPUT,
    @result_msg			VARCHAR(200) OUTPUT
AS
BEGIN

	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	-- 파라미터 유효성 체크
    IF NOT EXISTS(SELECT 1 FROM dbo.project AS P WITH (NOLOCK) WHERE P.project_id = @pProject_id)
    BEGIN		
		SET @result_cd = 1;
		SET @result_msg = '존재하지 않는 프로젝트 입니다.';
        RETURN;	
    END

	-- 파라미터 유효성 체크
    IF NOT EXISTS(SELECT 1 FROM dbo.hr_master AS MI WITH (NOLOCK) WHERE MI.EMP_ID = @pMember_id)
    BEGIN		
		SET @result_cd = 1;
		SET @result_msg = '존재하지 않는 회원 입니다.';
        RETURN;	
    END

	BEGIN TRY
		IF EXISTS(
					SELECT 1
					FROM project_member AS PM WITH (NOLOCK)
						INNER JOIN project AS P WITH (NOLOCK)
						ON PM.project_id = P.project_id
					WHERE PM.member_id = @pMember_id
					AND PM.project_id = @pProject_id
					AND PM.status_cd = '10'
					UNION
					SELECT 1
					FROM project_owner AS PO WITH (NOLOCK)
						INNER JOIN project AS P WITH (NOLOCK)
						ON PO.project_id = P.project_id
					WHERE PO.member_id = @pMember_id
					AND PO.project_id = @pProject_id
					AND PO.is_active_cd = '10'
					)
		BEGIN
			SELECT '1' AS isAccessable;
			SET @result_cd = 0;
			SET @result_msg = '성공';
		END
		ELSE
		BEGIN
			SELECT '0' AS isAccessable;
			SET @result_cd = 0;
			SET @result_msg = '성공';
		END
	END TRY
	BEGIN CATCH
		SET @result_cd = -1;
		SET @result_msg = ERROR_MESSAGE();
	END CATCH
END



--- Procedure 56 ---
ProcedureName: spMakeTaskFinishPlanDate
ProcedureDefinition:
-- =============================================
-- Author:		jay kwon
-- Create date: 2025-07-15
-- Description:	플랜, 액튜얼 데이트 자동 계산(업데이트)
-- =============================================
CREATE PROCEDURE [dbo].[spMakeTaskFinishPlanDate]
	@pProject_id		INT = NULL,
    @result_cd			INT OUTPUT,
    @result_msg			VARCHAR(200) OUTPUT
AS
BEGIN

	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	DECLARE @vPlaned_start_dt VARCHAR(10);

	SELECT
		@vPlaned_start_dt = P.planed_start_dt
	FROM dbo.project AS P WITH (NOLOCK)
	WHERE P.project_id = @pProject_id

	-- 최 선행 노드 처리
	DECLARE @top_node TABLE(
		task_id		INT,
		processed	INT
	)

	INSERT INTO @top_node
	SELECT
		TD1.dependency_id,
		0
	FROM dbo.task_dependency AS TD1 WITH (NOLOCK)
		LEFT JOIN dbo.task_dependency AS TD2 WITH (NOLOCK)
		ON TD1.dependency_id = TD2.task_id
	WHERE TD1.dependency_cd = '20'
	AND TD1.project_id = @pProject_id
	AND TD2.task_id IS NULL
	UNION 
	SELECT
		T.task_id,
		0
	FROM dbo.task AS T WITH (NOLOCK)
		LEFT JOIN dbo.task_dependency AS TD WITH (NOLOCK)
		ON T.task_id = TD.task_id
		AND TD.dependency_cd = '20'
	WHERE T.project_id = @pProject_id
	AND TD.task_id IS NULL
	AND T.task_id NOT IN (SELECT task_id FROM dbo.task_dependency WHERE project_id = @pProject_id AND dependency_cd = '10')


	DECLARE @vProcess_node_id INT;

	SELECT
		TOP 1
		@vProcess_node_id = TN.task_id
	FROM @top_node AS TN
	WHERE TN.processed = 0

	BEGIN TRY
		BEGIN TRAN
		-- 탑노드 처리
		WHILE (@vProcess_node_id IS NOT NULL)
		BEGIN
			UPDATE TFP SET		
				TFP.start_dt = @vPlaned_start_dt,
				TFP.end_dt = dbo.fnGetWorkingDateAdd(@vPlaned_start_dt, TFP.working_day)
			FROM dbo.task_finish_plan AS TFP WITH (NOLOCK)
			WHERE TFP.project_id = @pProject_id
			AND TFP.plan_cd = '10'
			AND TFP.task_id = @vProcess_node_id;

			UPDATE TN SET
				TN.processed = 1
			FROM @top_node AS TN
			WHERE TN.task_id = @vProcess_node_id;

			SET @vProcess_node_id = NULL;

			SELECT
				TOP 1
				@vProcess_node_id = TN.task_id
			FROM @top_node AS TN
			WHERE TN.processed = 0;
		END

		SET @vProcess_node_id = NULL;

		SELECT
			TOP 1
			@vProcess_node_id = TN.task_id
		FROM @top_node AS TN
		WHERE TN.processed = 1

		INSERT INTO @top_node
		SELECT
			T.task_id,
			NULL
		FROM @top_node AS TN
			INNER JOIN dbo.task_dependency AS TD WITH (NOLOCK)
			ON TN.task_id = TD.dependency_id
			INNER JOIN dbo.task AS T WITH (NOLOCK)
			ON TD.task_id = T.task_id		

		DECLARE @vProcess_leaf_node_id	INT = NULL;

		SELECT
			TOP 1
			@vProcess_leaf_node_id = TN.task_id
		FROM @top_node AS TN
		WHERE TN.processed IS NULL;

		WHILE (@vProcess_leaf_node_id IS NOT NULL)
		BEGIN
			UPDATE TFP SET						
				TFP.start_dt = PARENT_TFP.start_dt,
				TFP.end_dt = dbo.fnGetWorkingDateAdd(PARENT_TFP.start_dt, TFP.working_day)
			FROM dbo.task_finish_plan AS TFP WITH (NOLOCK)
				INNER JOIN dbo.task_dependency AS TD WITH (NOLOCK)
				ON TFP.task_id = TD.task_id
				INNER JOIN dbo.task_finish_plan AS PARENT_TFP WITH (NOLOCK)
				ON TD.dependency_id = PARENT_TFP.task_id
			WHERE TFP.task_id = @vProcess_leaf_node_id
			AND TD.dependency_cd = '10';

			UPDATE TFP SET				
				TFP.start_dt = dbo.fnGetWorkingDateAdd(PARENT_TFP.end_dt, 2),
				TFP.end_dt = dbo.fnGetWorkingDateAdd(dbo.fnGetWorkingDateAdd(PARENT_TFP.end_dt, 2), TFP.working_day)
			FROM dbo.task_finish_plan AS TFP WITH (NOLOCK)
				INNER JOIN dbo.task_dependency AS TD WITH (NOLOCK)
				ON TFP.task_id = TD.task_id
				INNER JOIN dbo.task_finish_plan AS PARENT_TFP WITH (NOLOCK)
				ON TD.dependency_id = PARENT_TFP.task_id
			WHERE TFP.task_id = @vProcess_leaf_node_id
			AND TD.dependency_cd = '20';
			
			UPDATE TN SET
				TN.processed = 0
			FROM @top_node AS TN
			WHERE TN.task_id = @vProcess_leaf_node_id;

			IF NOT EXISTS(	SELECT 1
							FROM @top_node AS TN
							WHERE TN.processed IS NULL)
			BEGIN
				INSERT INTO @top_node
				SELECT
					T.task_id,
					NULL
				FROM @top_node AS TN
					INNER JOIN dbo.task_dependency AS TD WITH (NOLOCK)
					ON TN.task_id = TD.dependency_id
					INNER JOIN dbo.task AS T WITH (NOLOCK)
					ON TD.task_id = T.task_id		
				WHERE TN.processed = 0;

				UPDATE TN SET
					TN.processed = 1
				FROM @top_node AS TN
				WHERE TN.processed = 0;
			END


			SET @vProcess_leaf_node_id = NULL;

			SELECT 
				@vProcess_leaf_node_id = TN.task_id
			FROM @top_node AS TN
			WHERE TN.processed IS NULL;
		END


		COMMIT TRAN;

		-- 성공		
		SET @result_cd = 0;
		SET @result_msg = '성공';

	END TRY

	BEGIN CATCH
		IF @@TRANCOUNT > 0
			ROLLBACK TRAN;

		SET @result_cd = -1;
		SET @result_msg = ERROR_MESSAGE();		
	END CATCH
END


--- Procedure 57 ---
ProcedureName: spDeleteTasks
ProcedureDefinition:
-- =============================================
-- Author:		Jay Kwon
-- Create date: 2025-07-21
-- Description:	태스크들을 삭제 한다.
/* 실행예제
DECLARE @result_cd INT, @result_msg VARCHAR(100);
EXEC [dbo].[spDeleteTasks] @pTask_ids = '1037,1040' , @result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT;
SELECT @result_cd as result_cd, @result_msg as result_msg;
*/
-- =============================================
CREATE PROCEDURE [dbo].[spDeleteTasks]
	@pTask_ids			VARCHAR(MAX)	= NULL,
	@pModifier_id		VARCHAR(7)		= NULL,
    @result_cd			INT				OUTPUT,
    @result_msg			VARCHAR(200)	OUTPUT
AS
BEGIN
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	DECLARE @vSeverity				INT = NULL;
	DECLARE @vProject_id			INT = NULL;
	DECLARE @vTaskList				TABLE (task_id INT);
	DECLARE @vResultTaskList		TABLE (task_id INT);
	
	-- CSV 문자열을 파싱해서 테이블에 삽입
	;WITH Split AS (
		SELECT LTRIM(RTRIM(value)) AS task_id
		FROM STRING_SPLIT(@pTask_ids, ',')
	)
	INSERT INTO @vTaskList(task_id)
	SELECT CAST(task_id AS INT) FROM Split WHERE task_id IS NOT NULL;

	SET @vProject_id =  (	SELECT		
								DISTINCT TOP 1 T.project_id
							FROM @vTaskList AS TL
								INNER JOIN dbo.task AS T WITH (NOLOCK)
								ON TL.task_id = T.task_id);		

    BEGIN TRY

		IF EXISTS(	SELECT 1
					FROM @vTaskList AS TL
						LEFT JOIN dbo.task AS T WITH (NOLOCK)
						ON TL.task_id = T.task_id
					WHERE T.task_id IS NULL)
		BEGIN
			RAISERROR('존재하지 않는 태스크 아이디가 있습니다.', 16, 1);
		END

		-- 1뎁스의 태스크는 한번에 한개만 삭제 가능 하다.
		IF EXISTS(	SELECT 1
					FROM @vTaskList AS TL 
						LEFT JOIN dbo.task_dependency AS TD WITH (NOLOCK)
						ON TL.task_id = TD.dependency_id
						AND TD.dependency_cd = '20'
					WHERE TD.task_id IS NOT NULL
					GROUP BY TD.project_id
					HAVING COUNT(*) > 1)
		BEGIN
			RAISERROR('1뎁스의 태스크는 한번에 하나만 삭제 할 수 있습니다.',16,1);
		END

		-- pre, center, post 태스크 아이디 찾기
		DECLARE 	@vPre_task_id			INT = NULL;
		DECLARE 	@vCenter_task_id		INT = NULL;
		DECLARE 	@vPost_task_id			INT = NULL;
	
		-- 1뎁스의 센터 아이디 찾기
		SELECT
			@vCenter_task_id = M.task_id
		FROM (
				-- 후행이 딸려있는 케이스
				SELECT
					TL.task_id
				FROM @vTaskList AS TL 
					LEFT JOIN dbo.task_dependency AS TD WITH (NOLOCK)
					ON TL.task_id = TD.dependency_id
					AND TD.dependency_cd = '20'
				WHERE TD.task_id IS NOT NULL
				-- 후행이 없고 && 선행만 있는 경우
				UNION
				SELECT TL.task_id
				FROM @vTaskList AS TL
					INNER JOIN dbo.task_dependency AS TD WITH (NOLOCK)
					ON TL.task_id = TD.task_id
					AND TD.dependency_cd = '20'
					LEFT JOIN dbo.task_dependency AS TD_POST WITH (NOLOCK)
					ON TL.task_id = TD.dependency_id
				WHERE TD_POST.task_id IS NULL) M

		-- 선행 태스크 찾기	
		SELECT
			@vPre_task_id = TD.dependency_id
		FROM dbo.task_dependency AS TD WITH (NOLOCK)		
		WHERE TD.dependency_cd = '20'
		AND TD.task_id = @vCenter_task_id

		-- 후행 태스크 찾기
		SELECT
			@vPost_task_id = TD.task_id
		FROM dbo.task_dependency AS TD WITH (NOLOCK)		
		WHERE TD.dependency_cd = '20'
		AND TD.dependency_id = @vCenter_task_id

		-- 디펜던시 업데이트
		-- SELECT @vPre_task_id, @vCenter_task_id, @vPost_task_id
		UPDATE TD SET
			dependency_id = @vPre_task_id,
			modifier_id = @pModifier_id,
			modified_at	= GETDATE()
		FROM dbo.task_dependency AS TD WITH (NOLOCK)
		WHERE TD.task_id = @vPost_task_id


		INSERT INTO @vResultTaskList
		SELECT
			TL.task_id
		FROM @vTaskList AS TL
		UNION
		SELECT
			TD.task_id
		FROM @vTaskList AS TL
			INNER JOIN dbo.task_dependency AS TD WITH (NOLOCK)
			ON TL.task_id = TD.dependency_id
			AND TD.dependency_cd = '10'

		UPDATE T SET
			T.is_active_cd    = '90',
			T.order_no		  = 90000 + ISNULL(T.task_id,0),
            T.modifier_id     = ISNULL(@pModifier_id,     T.modifier_id),
            T.modified_at     = GETDATE()    
		FROM @vResultTaskList AS RTL
			INNER JOIN dbo.task AS T WITH (NOLOCK)
			ON RTL.task_id = T.task_id
		WHERE T.is_active_cd = '10'


		-- 태스크 피니시 플랜 삭제
		DELETE TFP
		FROM @vResultTaskList AS RTL
			INNER JOIN dbo.task_finish_plan AS TFP WITH (NOLOCK)
			ON RTL.task_id = TFP.task_id		
			
		-- 태스크 디펜던시 삭제
		DELETE TD
		FROM @vResultTaskList AS RTL
			INNER JOIN dbo.task_dependency AS TD WITH (NOLOCK)
			ON RTL.task_id = TD.task_id		

		--DECLARE @vResult_cd INT, @vResult_msg VARCHAR(100);			
		--EXEC [dbo].[spMakeTaskFinishPlanDate] @pProject_id = @vProject_id, @result_cd = @vResult_cd OUTPUT, @result_msg = @vResult_msg OUTPUT;

		-- 태스크를 삭제 했을때는, 계획 + 실제만 건드린다.

		DECLARE @vResult_cd INT, @vResult_msg VARCHAR(100);
		EXEC [dbo].[spUpdateDateByShifting] @pProject_id = @vProject_id, @pTask_id = NULL, @pPlan_cd = '20' , @result_cd = @vResult_cd OUTPUT, @result_msg = @vResult_msg OUTPUT;
		EXEC [dbo].[spUpdateDateByShifting] @pProject_id = @vProject_id, @pTask_id = NULL, @pPlan_cd = '30' , @result_cd = @vResult_cd OUTPUT, @result_msg = @vResult_msg OUTPUT;

		SET @vSeverity = 0;
		SET @result_cd = 0;
		SET @result_msg = '성공';

	END TRY

	BEGIN CATCH
		IF @@TRANCOUNT > 0
			ROLLBACK TRAN;

		SET @result_cd = -1;
		SET @result_msg = ERROR_MESSAGE();
		SET @vSeverity = ERROR_SEVERITY();
	END CATCH

	DECLARE @log_param VARCHAR(MAX);

	SET @log_param = '@pTask_ids = ' + ISNULL(@pTask_ids, 'NULL') + ', '
				   + '@pModifier_id = ' + ISNULL(@pModifier_id, 'NULL');
				   

	INSERT INTO dbo.use_log (caller_id, severity, project_id, log_dt, log_message, proc_name, proc_param, result_cd, result_msg, created_at)
	VALUES(ISNULL(CAST(@pModifier_id AS VARCHAR(8)), 'UNKNOWN'), @vSeverity, ISNULL(NULL, 0), CONVERT(CHAR(10), GETDATE(), 120), '[' + @pTask_ids + '] 태스크가 삭제 되었습니다.', '[spDeleteTasks]', @log_param, @result_cd, @result_msg, GETDATE());

	RETURN;
END


--- Procedure 58 ---
ProcedureName: spUpdateProjectMembers
ProcedureDefinition:
-- =============================================
-- Author:		Jay Kwon
-- Create date: 2025-07-22
-- Description:	프로젝트 멤버를 변경한다.
/* 실행예제
DECLARE @result_cd INT, @result_msg VARCHAR(100);
EXEC [dbo].[spUpdateProjectMembers] @pProject_id = NULL , @pMember_ids = NULL, @pModifier_id = NULL, @result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT;
SELECT @result_cd as result_cd, @result_msg as result_msg;
*/
-- =============================================
CREATE PROCEDURE [dbo].[spUpdateProjectMembers]
	@pProject_id		INT				= NULL,
	@pMember_ids		VARCHAR(MAX)	= NULL,	-- CSV 형태로 받음 '2400001,2400002,...'
	@pModifier_id		VARCHAR(7)		= NULL,
    @result_cd			INT				OUTPUT,
    @result_msg			VARCHAR(200)	OUTPUT
AS
BEGIN
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	DECLARE @vSeverity				INT = NULL;

    BEGIN TRY
		-- 프로젝트 유효성 체크
		IF NOT EXISTS (
			SELECT 1
			FROM dbo.project AS P WITH (NOLOCK)
			WHERE P.project_id = @pProject_id
		)
		BEGIN  
			RAISERROR('존재하지 않는 프로젝트 아이디 입니다.', 16, 1);
		END

		-- 템플릿에는 할당 불가
		IF EXISTS(SELECT 1 FROM dbo.project AS P WITH (NOLOCK) WHERE P.project_id = @pProject_id AND P.project_type_cd = '90')
		BEGIN			
			RAISERROR('템플릿에는 할당 할 수 없습니다', 16, 1);
		END


		-- 문자열을 테이블로 변환
		DECLARE @member TABLE (member_id VARCHAR(7));

		INSERT INTO @member (member_id)
		SELECT DISTINCT TRIM(value)
		FROM STRING_SPLIT(@pMember_ids, ',')


		BEGIN TRAN;
			-- 마케터가 할당하는것이므로 이미 신청한 사람이 있다면 승인 상태로 바꿔주고, 나머지는 승인 상태로 인서트
			UPDATE PM SET
				PM.status_cd = '10',
				PM.modifier_id = @pModifier_id,
				PM.modified_at = GETDATE()
			FROM dbo.project_member AS PM WITH (NOLOCK)
				INNER JOIN @member AS M
				ON PM.member_id = M.member_id
				AND PM.project_id = @pProject_id;
		
			INSERT INTO dbo.project_member
			SELECT
				@pProject_id	AS project_id,
				M.member_id		AS member_id,
				'10'			AS status_cd,
				@pModifier_id	AS creator_id,
				GETDATE()		AS created_at,
				NULL			AS modifier_id,
				NULL			AS modified_at
			FROM @member AS M
				LEFT JOIN dbo.project_member AS PM WITH (NOLOCK)
				ON M.member_id = PM.member_id
				AND PM.project_id = @pProject_id
			WHERE PM.member_id IS NULL;

			-- 던진 리스트에 없는 애들은 반려 처리
			UPDATE PM SET
				PM.status_cd = '90',
				PM.modifier_id = @pModifier_id,
				PM.modified_at = GETDATE()
			FROM dbo.project_member AS PM WITH (NOLOCK)
				LEFT JOIN @member AS M
				ON PM.member_id = M.member_id
			WHERE M.member_id IS NULL
			AND PM.project_id = @pProject_id;

		COMMIT TRAN;

		SET @vSeverity = 0;
		SET @result_cd = 0;
		SET @result_msg = '성공';

	END TRY

	BEGIN CATCH
		IF @@TRANCOUNT > 0
			ROLLBACK TRAN;

		SET @result_cd = -1;
		SET @result_msg = ERROR_MESSAGE();
		SET @vSeverity = ERROR_SEVERITY();
	END CATCH

	DECLARE @log_param VARCHAR(MAX);

	SET @log_param = '@pProject_id = ' + ISNULL(CAST(@pProject_id AS VARCHAR), 'NULL') + ', '
				   + '@pMember_ids = ' + ISNULL(@pMember_ids, 'NULL') + ', '
					+ '@pModifier_id = ' + ISNULL(@pModifier_id, 'NULL') + ', ';
				   

	INSERT INTO dbo.use_log (caller_id, severity, project_id, log_dt, log_message, proc_name, proc_param, result_cd, result_msg, created_at)
	VALUES(ISNULL(CAST(@pModifier_id AS VARCHAR(8)), 'UNKNOWN'), @vSeverity, ISNULL(@pProject_id, 0), CONVERT(CHAR(10), GETDATE(), 120), @pMember_ids + ' 프로젝트 멤버 변경', '[spUpdateProjectMembers]', @log_param, @result_cd, @result_msg, GETDATE());


	RETURN;
END


--- Procedure 59 ---
ProcedureName: spUpdateCodeMaster
ProcedureDefinition:
-- =============================================
-- Author:		jaykwon
-- Create date: 2025-06-22
-- Description:	코드마스터 업데이트 (detail_name 만 가능)
/*
DECLARE @result_cd INT, @result_msg VARCHAR(100);

EXEC [dbo].[spUpdateCodeMaster]
    @pGroup_cd     = '99999',
    @pDetail_cd    = '11',
    @pDetail_name  = NULL,
	@pIs_active_cd = '90',
    @pModifier_id  = 1,
    @result_cd     = @result_cd OUTPUT,
    @result_msg    = @result_msg OUTPUT;

SELECT @result_cd AS result_cd, @result_msg AS result_msg;
*/
-- =============================================
CREATE PROCEDURE [dbo].[spUpdateCodeMaster]
	@pGroup_cd			VARCHAR(8) = NULL,
	@pDetail_cd			VARCHAR(8) = NULL,
	@pDetail_name		VARCHAR(50) = NULL,
	@pIs_active_cd		VARCHAR(8) = NULL,
	@pModifier_id		VARCHAR(7) = NULL,
    @result_cd			INT				OUTPUT,
    @result_msg			VARCHAR(200)	OUTPUT
AS
BEGIN
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	-- 90000대 그룹코드는 시스템 코드로 사용자 제어 불가
	IF (@pGroup_cd >= '90000')
	BEGIN
		SET @result_cd = 1;
		SET @result_msg = '시스템 코드는 수정 할 수 없습니다.';
	END


    BEGIN TRY
		UPDATE CM SET
			CM.detail_name = ISNULL(@pDetail_name, CM.detail_cd),
			CM.is_active_cd = ISNULL(@pIs_active_cd, CM.is_active_cd),
			CM.modifier_id = @pModifier_id,
			CM.modified_at = GETDATE()
		FROM dbo.code_master AS CM WITH (NOLOCK)
		WHERE CM.group_cd = @pGroup_cd
		AND CM.detail_cd = @pDetail_cd;

		SET @result_cd = 0;
		SET @result_msg = '성공';
	END TRY
	BEGIN CATCH
		SET @result_cd = -1;
		SET @result_msg = ERROR_MESSAGE();
	END CATCH

END


--- Procedure 60 ---
ProcedureName: spUpdateProjectOwners
ProcedureDefinition:
-- =============================================
-- Author:		Jay Kwon
-- Create date: 2025-07-22
-- Description:	프로젝트 마케터를 변경한다.
/* 실행예제
DECLARE @result_cd INT, @result_msg VARCHAR(100);
EXEC [dbo].[spUpdateProjectOwners] @pProject_id = 25070103, @pMember_ids = '2400001, 2400002', @pModifier_id = 2400002,  @result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT;
SELECT @result_cd as result_cd, @result_msg as result_msg;
*/ 
-- =============================================
CREATE PROCEDURE [dbo].[spUpdateProjectOwners]
	@pProject_id		INT				= NULL,
	@pMember_ids		VARCHAR(MAX)	= NULL,	-- CSV 형태로 받음 '2400001,2400002,...'
	@pModifier_id		VARCHAR(7)		= NULL,
    @result_cd			INT				OUTPUT,
    @result_msg			VARCHAR(200)	OUTPUT
AS
BEGIN
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	DECLARE @vSeverity				INT = NULL;

    BEGIN TRY
		-- 프로젝트 유효성 체크
		IF NOT EXISTS (
			SELECT 1
			FROM dbo.project AS P WITH (NOLOCK)
			WHERE P.project_id = @pProject_id
		)
		BEGIN			
			RAISERROR('존재하지 않는 프로젝트 id 입니다', 16, 1);
		END

		-- 템플릿에는 할당 불가
		IF EXISTS(SELECT 1 FROM dbo.project AS P WITH (NOLOCK) WHERE P.project_id = @pProject_id AND P.project_type_cd = '90')
		BEGIN			
			RAISERROR('템플릿에는 할당 할 수 없습니다', 16, 1);
		END


		-- 문자열을 테이블로 변환
		DECLARE @member TABLE (member_id VARCHAR(7));

		INSERT INTO @member (member_id)
		SELECT DISTINCT TRIM(value)
		FROM STRING_SPLIT(@pMember_ids, ',')


		BEGIN TRAN;
			-- 마케터가 할당하는것이므로 이미 신청한 사람이 있다면 승인 상태로 바꿔주고, 나머지는 승인 상태로 인서트
			UPDATE PO SET
				PO.is_active_cd = '10',
				PO.modifier_id = @pModifier_id,
				PO.modified_at = GETDATE()
			FROM dbo.project_owner AS PO WITH (NOLOCK)
				INNER JOIN @member AS M
				ON PO.member_id = M.member_id
				AND PO.project_id = @pProject_id;

			INSERT INTO dbo.project_owner
			SELECT
				@pProject_id	AS project_id,
				M.member_id		AS member_id,
				'10'			AS is_active_cd,
				@pModifier_id	AS creator_id,
				GETDATE()		AS created_at,
				NULL			AS modifier_id,
				NULL			AS modified_at
			FROM @member AS M
				LEFT JOIN dbo.project_owner AS PO WITH (NOLOCK)
				ON M.member_id = PO.member_id
				AND PO.project_id = @pProject_id
			WHERE PO.member_id IS NULL;

			-- 던진 리스트에 없는 애들은 빼기
			UPDATE PO SET
				PO.is_active_cd = '90',
				PO.modifier_id = @pModifier_id,
				PO.modified_at = GETDATE()
			FROM dbo.project_owner AS PO WITH (NOLOCK)
				LEFT JOIN @member AS M
				ON PO.member_id = M.member_id				
			WHERE M.member_id IS NULL
			AND PO.project_id  = @pProject_id;

		COMMIT TRAN;

		SET @vSeverity = 0;
		SET @result_cd = 0;
		SET @result_msg = '성공';

	END TRY

	BEGIN CATCH
		IF @@TRANCOUNT > 0
			ROLLBACK TRAN;

		SET @result_cd = -1;
		SET @result_msg = ERROR_MESSAGE();
		SET @vSeverity = ERROR_SEVERITY();
	END CATCH

	DECLARE @log_param VARCHAR(MAX);

	SET @log_param = '@pProject_id = ' + ISNULL(CAST(@pProject_id AS VARCHAR), 'NULL') + ', '
				   + '@pMember_ids = ' + ISNULL(@pMember_ids, 'NULL') + ', '
					+ '@pModifier_id = ' + ISNULL(@pModifier_id, 'NULL') + ', ';
				   

	INSERT INTO dbo.use_log (caller_id, severity, project_id, log_dt, log_message, proc_name, proc_param, result_cd, result_msg, created_at)
	VALUES(ISNULL(CAST(@pModifier_id AS VARCHAR(7)), 'UNKNOWN'), @vSeverity, ISNULL(@pProject_id, 0), CONVERT(CHAR(10), GETDATE(), 120), @pMember_ids + ' 프로젝트 마케터 변경', '[spUpdateProjectOwners]', @log_param, @result_cd, @result_msg, GETDATE());


	RETURN;
END


--- Procedure 61 ---
ProcedureName: spUpdateForcedFinishForProject
ProcedureDefinition:
-- =============================================
-- Author:		jaykwon
-- Create date: 2025-06-22
-- Description:	프로젝트 강제 종료 처리
/*
-- 프로젝트 강제 종료 처리
DECLARE @result_cd INT, @result_msg VARCHAR(100);

EXEC [dbo].[spUpdateForcedFinishForProject]
    @pProject_id         = 2,    
    @pForced_end_reason  = '조기 종료 요청에 따라 강제 종료 처리',
    @pModifier_id        = 1,
    @result_cd           = @result_cd OUTPUT,
    @result_msg          = @result_msg OUTPUT;

SELECT @result_cd AS result_cd, @result_msg AS result_msg;

*/
-- =============================================
CREATE PROCEDURE [dbo].[spUpdateForcedFinishForProject]
	@pProject_id			INT = NULL,
	@pForced_end_reason		VARCHAR(200) = NULL,
	@pExclude_statistics	INT = NULL, -- 1로 던지면 통계 제외 처리
	@pModifier_id			VARCHAR(7) = NULL,
    @result_cd				INT OUTPUT,
    @result_msg				VARCHAR(200) OUTPUT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
	
	DECLARE @vProject_type_cd VARCHAR(8) = NULL;

    BEGIN TRY

		IF (ISNULL(@pExclude_statistics,'') = 1)
		BEGIN
			SET @vProject_type_cd = '20'	-- 20은 테스트 프로젝트로 통계 제외 된다.
		END

		UPDATE P SET
			P.forced_end_dt     = CONVERT(VARCHAR(10), GETDATE(), 120),  -- 오늘 날짜 'YYYY-MM-DD'
			P.forced_end_reason = @pForced_end_reason,		
			P.project_type_cd	= ISNULL(@vProject_type_cd, P.project_type_cd),
			P.modifier_id       = @pModifier_id,
			P.modified_at       = GETDATE()
		FROM dbo.project AS P WITH (NOLOCK)
		WHERE P.project_id = @pProject_id;

		SET @result_cd = 0;
		SET @result_msg = '성공';    
	END TRY
	BEGIN CATCH
	
		-- 실패 메시지
		SET @result_cd = -1;
		SET @result_msg = ERROR_MESSAGE();

	END CATCH
END


--- Procedure 62 ---
ProcedureName: spGetDelayedTaskList
ProcedureDefinition:
-- =============================================
-- Author:		Jay Kwon
-- Create date: 2025-07-24
-- Description:	태스크 지연 리스트
/* 실행예제
DECLARE @result_cd INT, @result_msg VARCHAR(100);
EXEC [dbo].[spGetDelayedTaskList] @pCreator_id = '2400001' , @result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT;
SELECT @result_cd as result_cd, @result_msg as result_msg;
*/
-- =============================================
CREATE PROCEDURE [dbo].[spGetDelayedTaskList]	
	@pCreator_id		VARCHAR(7)		= NULL,
    @result_cd			INT				OUTPUT,
    @result_msg			VARCHAR(200)	OUTPUT
AS
BEGIN
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	DECLARE @vSeverity				INT = NULL;
	DECLARE @vNow_dt				VARCHAR(10) = NULL;
	SET @vNow_dt = CONVERT(VARCHAR(10),GETDATE(),121);
	


    BEGIN TRY
		SELECT 
			P.project_id,
			P.project_name,
			T.task_id,
			T.task_name,
			TFP.start_dt	AS planed_start_dt,
			TFP.end_dt		AS planed_end_dt,
			TFA.start_dt	AS actual_start_dt,
			dbo.fnCalcWorkingDay(TFP.start_dt, CONVERT(VARCHAR(10), GETDATE(),121)) AS working_day_diff,
			TOWNM.task_owner_ids,
			TOWNM.task_owner_mails,
			PO1.project_owner_ids,
			PO1.project_owner_mails,
			LEADER.leader_ids,
			LEADER.leader_mails
		FROM dbo.project AS P WITH (NOLOCK)
			INNER JOIN dbo.task_finish_plan AS TFA WITH (NOLOCK)
			ON P.project_id = TFA.project_id
			INNER JOIN dbo.task AS T WITH (NOLOCK)
			ON TFA.task_id = T.task_id
			LEFT JOIN dbo.task_finish_plan AS TFP WITH (NOLOCK)
			ON TFA.task_id = TFP.task_id
			LEFT JOIN (
                        SELECT 
                            TOWN.task_id,
                            STRING_AGG(CAST(MI.EMP_ID AS VARCHAR), ', ') AS task_owner_ids,
							STRING_AGG(CAST(MI.MOIN_EMAIL AS VARCHAR), ', ') AS task_owner_mails
                        FROM dbo.task_owner AS TOWN WITH (NOLOCK)
                            INNER JOIN dbo.hr_master AS MI WITH (NOLOCK)
                            ON TOWN.member_id = MI.EMP_ID
                        WHERE TOWN.is_active_cd = '10'
                        GROUP BY TOWN.task_id) TOWNM
            ON TFA.task_id = TOWNM.task_id
            LEFT JOIN (
                        SELECT 
                            PO.project_id,
                            STRING_AGG(CAST(MI.EMP_ID AS VARCHAR), ', ') AS project_owner_ids,
							STRING_AGG(CAST(MI.MOIN_EMAIL AS VARCHAR), ', ') AS project_owner_mails
                        FROM dbo.project_owner AS PO WITH (NOLOCK)
                            INNER JOIN dbo.hr_master AS MI WITH (NOLOCK)
                            ON PO.member_id = MI.EMP_ID
                        WHERE PO.is_active_cd = '10'
                        GROUP BY PO.project_id) PO1 
            ON TFA.project_id = PO1.project_id
			LEFT JOIN (
						SELECT
							TOWN.task_id,
							STRING_AGG(CAST(HM2.EMP_ID AS VARCHAR), ', ') AS leader_ids,
							STRING_AGG(CAST(HM2.MOIN_EMAIL AS VARCHAR), ', ') AS leader_mails
						FROM dbo.task_owner AS TOWN WITH (NOLOCK)
							INNER JOIN dbo.hr_master AS HM1 WITH (NOLOCK)
							ON TOWN.member_id = HM1.EMP_ID
							LEFT JOIN dbo.hr_master AS HM2 WITH (NOLOCK)
							ON HM1.DEPT_CODE = HM2.DEPT_CODE
							AND HM2.JOB_DUTY IN ('1000', '1100')
						WHERE HM2.EMP_ID IS NOT NULL
						GROUP BY TOWN.task_id) LEADER
			ON TFA.task_id = LEADER.task_id
		WHERE P.project_type_cd = '10'
		AND P.kick_off_cd = '10'
		AND P.is_active = '10'
		AND P.forced_end_dt IS NULL
		AND TFA.plan_cd = '30'
		AND TFA.end_dt > CONVERT(VARCHAR(10),GETDATE(),121)
		AND TFP.plan_cd = '20';

		SET @vSeverity = 0;
		SET @result_cd = 0;
		SET @result_msg = '성공';

	END TRY

	BEGIN CATCH
		IF @@TRANCOUNT > 0
			ROLLBACK TRAN;

		SET @result_cd = -1;
		SET @result_msg = ERROR_MESSAGE();
		SET @vSeverity = ERROR_SEVERITY();
	END CATCH

	DECLARE @log_param VARCHAR(MAX);

	SET @log_param = '@pCreator_id = ' + ISNULL(@pCreator_id, 'NULL');
				   

	INSERT INTO dbo.use_log (caller_id, severity, project_id, log_dt, log_message, proc_name, proc_param, result_cd, result_msg, created_at)
	VALUES(ISNULL(@pCreator_id, 'UNKNOWN'), @vSeverity, ISNULL(NULL, 0), CONVERT(CHAR(10), GETDATE(), 120), '태스크 착수 지연 리스트', '[spGetDelayedTaskList]', @log_param, @result_cd, @result_msg, GETDATE());


	RETURN;
END


--- Procedure 63 ---
ProcedureName: spUpdateProjectApplicantsStatus
ProcedureDefinition:

-- =============================================
-- Author:		JayKwon
-- Create date: 2025-05-23
-- Description:	프로젝트에 참여 상태를 업데이트 한다
/* SAMPLE EXEC
DECLARE @result_cd INT, @result_msg VARCHAR(100);
EXEC [spUpdateProjectApplicantsStatus] @pProject_id = 25080009, @pMember_id = '2400001', @pStatus_cd = '10' , @result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT;
SELECT @result_cd as result_cd, @result_msg as result_msg;
*/
-- =============================================
CREATE PROCEDURE [dbo].[spUpdateProjectApplicantsStatus]
    @pProject_id		INT			= NULL,
	@pMember_id			VARCHAR(7)	= NULL,
	@pStatus_cd			VARCHAR(8),	-- master 10:승인, 20:신청, 90:반려
    @result_cd			INT OUTPUT,
    @result_msg			VARCHAR(200) OUTPUT
AS
BEGIN

	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
		
	-- 파라미터 유효성 체크
    IF NOT EXISTS(SELECT 1 FROM dbo.project AS P WITH (NOLOCK) WHERE P.project_id = @pProject_id)
    BEGIN		
		SET @result_cd = 1;
		SET @result_msg = '존재하지 않는 프로젝트 입니다.';
        RETURN;	
    END

	-- 파라미터 유효성 체크
    IF NOT EXISTS(SELECT 1 FROM dbo.hr_master AS MI WITH (NOLOCK) WHERE MI.EMP_ID = @pMember_id)
    BEGIN		

		-- 데이터 정합성을 위해 신청 목록에서 지워버린다.
		DELETE PM
		FROM dbo.project_member AS PM WITH (NOLOCK)
		WHERE PM.member_id = @pMember_id

		SET @result_cd = 1;
		SET @result_msg = '존재하지 않는 회원 입니다.';
        RETURN;	
    END

	BEGIN TRY
		UPDATE PM SET
			PM.status_cd = @pStatus_cd
		FROM project_member AS PM WITH (NOLOCK)
		WHERE PM.project_id = @pProject_id
		AND PM.member_id = @pMember_id;

		SET @result_cd = 0;
		SET @result_msg = '성공';
	END TRY
	BEGIN CATCH
		SET @result_cd = -1;
		SET @result_msg = ERROR_MESSAGE();
	END CATCH
END



--- Procedure 64 ---
ProcedureName: spGetDelayedStartTaskList
ProcedureDefinition:
-- =============================================
-- Author:		Jay Kwon
-- Create date: 2025-07-24
-- Description:	태스크 착수 지연 리스트
/* 실행예제
DECLARE @result_cd INT, @result_msg VARCHAR(100);
EXEC [dbo].[spGetDelayedStartTaskList] @pCreator_id = '2400001' , @result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT;
SELECT @result_cd as result_cd, @result_msg as result_msg;
*/
-- =============================================
CREATE PROCEDURE [dbo].[spGetDelayedStartTaskList]	
	@pCreator_id		VARCHAR(7)		= NULL,
    @result_cd			INT				OUTPUT,
    @result_msg			VARCHAR(200)	OUTPUT
AS
BEGIN
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	DECLARE @vSeverity				INT = NULL;
	DECLARE @vNow_dt				VARCHAR(10) = NULL;
	SET @vNow_dt = CONVERT(VARCHAR(10),GETDATE(),121);
	
    BEGIN TRY
		-- 착수가 안된것(대기상태) 중에 계획 시작일정이 오늘보다 작은것
		SELECT
			T.project_id,
			P.project_name,
			T.task_id,
			T.task_name,
			TFP.start_dt,
			TFP.end_dt,
			dbo.fnCalcWorkingDay(TFP.start_dt, CONVERT(VARCHAR(10), GETDATE(),121)) AS working_day_diff,
			TOWNM.task_owner_ids,
			TOWNM.task_owner_mails,
			PO1.project_owner_ids,
			PO1.project_owner_mails
		FROM dbo.task AS T WITH (NOLOCK)
			INNER JOIN dbo.project AS P WITH (NOLOCK)
			ON T.project_id = P.project_id
			INNER JOIN dbo.task_finish_plan AS TFP WITH (NOLOCK)
			ON T.task_id = TFP.task_id
            LEFT JOIN (
                        SELECT 
                            TOWN.task_id,
                            STRING_AGG(CAST(MI.EMP_ID AS VARCHAR), ', ') AS task_owner_ids,
							STRING_AGG(CAST(MI.MOIN_EMAIL AS VARCHAR), ', ') AS task_owner_mails
                        FROM dbo.task_owner AS TOWN WITH (NOLOCK)
                            INNER JOIN dbo.hr_master AS MI WITH (NOLOCK)
                            ON TOWN.member_id = MI.EMP_ID
                        WHERE TOWN.is_active_cd = '10'
                        GROUP BY TOWN.task_id) TOWNM
            ON T.task_id = TOWNM.task_id
            LEFT JOIN (
                        SELECT 
                            PO.project_id,
                            STRING_AGG(CAST(MI.EMP_ID AS VARCHAR), ', ') AS project_owner_ids,
							STRING_AGG(CAST(MI.MOIN_EMAIL AS VARCHAR), ', ') AS project_owner_mails
                        FROM dbo.project_owner AS PO WITH (NOLOCK)
                            INNER JOIN dbo.hr_master AS MI WITH (NOLOCK)
                            ON PO.member_id = MI.EMP_ID
                        WHERE PO.is_active_cd = '10'
                        GROUP BY PO.project_id) PO1 
            ON p.project_id = PO1.project_id
		WHERE TFP.plan_cd = '20'
		AND T.status_cd = '10'
		AND TFP.start_dt < @vNow_dt
		AND T.is_active_cd = '10'
		AND P.forced_end_dt IS NULL
		AND P.project_type_cd = '10'
		

		SET @vSeverity = 0;
		SET @result_cd = 0;
		SET @result_msg = '성공';

	END TRY

	BEGIN CATCH
		IF @@TRANCOUNT > 0
			ROLLBACK TRAN;

		SET @result_cd = -1;
		SET @result_msg = ERROR_MESSAGE();
		SET @vSeverity = ERROR_SEVERITY();
	END CATCH

	DECLARE @log_param VARCHAR(MAX);

	SET @log_param = '@pCreator_id = ' + ISNULL(@pCreator_id, 'NULL');
				   

	INSERT INTO dbo.use_log (caller_id, severity, project_id, log_dt, log_message, proc_name, proc_param, result_cd, result_msg, created_at)
	VALUES(ISNULL(@pCreator_id, 'UNKNOWN'), @vSeverity, ISNULL(NULL, 0), CONVERT(CHAR(10), GETDATE(), 120), '태스크 착수 지연 리스트', '[spGetDelayedStartTaskList]', @log_param, @result_cd, @result_msg, GETDATE());


	RETURN;
END


--- Procedure 65 ---
ProcedureName: spUpdateTask
ProcedureDefinition:

-- =============================================
-- Author:		jay kwon
-- Create date: 2025-06-22
-- Description:	태스크 업데이트
/*
select * from task_owner where task_id = 17
-- 태스크 삭제 처리
DECLARE @result_cd INT, @result_msg VARCHAR(100);

EXEC [dbo].[spUpdateTask]
    @pTask_id         = 17,
    @pTask_name       = NULL,
    @pStatus_cd       = NULL,
    @pIs_active_cd    = NULL,       -- 비활성 처리 예시
    @pIs_output_need  = NULL,
    @pStd_workding_day = NULL,
    @pMember_ids = '2400018,2400016',
    @pModifier_id     = '2400017',
    @result_cd        = @result_cd OUTPUT,
    @result_msg       = @result_msg OUTPUT;

SELECT @result_cd AS result_cd, @result_msg AS result_msg;

*/
-- =============================================
CREATE PROCEDURE [dbo].[spUpdateTask]
	@pTask_id			INT             = NULL,
	@pTask_name			VARCHAR(200)    = NULL,
	@pStatus_cd			VARCHAR(8)      = NULL,
	@pIs_output_need	VARCHAR(8)      = NULL,
    @pStd_workding_day  INT             = NULL,
	@pMember_ids		VARCHAR(MAX)	= NULL,	    -- 태스크 담당자를 업데이트 한다.
	@pModifier_id		VARCHAR(7)      = NULL,
    @result_cd			INT				OUTPUT,
    @result_msg			VARCHAR(200)	OUTPUT
AS
BEGIN

	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

    DECLARE @vProject_type_cd       VARCHAR(8) = NULL;
    DECLARE @vProject_id            INT = NULL;
    DECLARE @vKick_off_cd           VARCHAR(8) = NULL;
	DECLARE @vSeverity				INT = NULL;

	DECLARE @MemberList TABLE (member_id VARCHAR(7));

	-- CSV 문자열을 파싱해서 테이블에 삽입
	;WITH Split AS (
		SELECT LTRIM(RTRIM(value)) AS member_id
		FROM STRING_SPLIT(@pMember_ids, ',')
	)
	INSERT INTO @MemberList(member_id)
	SELECT member_id FROM Split WHERE member_id IS NOT NULL;
    
    
    SELECT
        @vProject_type_cd = P.project_type_cd,
        @vProject_id = P.project_id,
        @vKick_off_cd = P.kick_off_cd
    FROM dbo.task AS T WITH (NOLOCK)
        INNER JOIN dbo.project AS P WITH (NOLOCK)
        ON T.project_id = P.project_id
    WHERE T.task_id = @pTask_id

    BEGIN TRY   
        
        -- 담당자 업데이트 시 회원 데이터 검증
        IF (@pMember_ids IS NOT NULL)
        BEGIN
            IF EXISTS(  SELECT 1
                        FROM @MemberList AS ML
                            LEFT JOIN dbo.hr_master AS HRM WITH (NOLOCK)
                            ON ML.member_id = HRM.EMP_ID
                        WHERE HRM.EMP_ID IS NULL)
            BEGIN
			    RAISERROR('존재하지 않는 회원 입니다.', 16, 1);
            END
        END

        IF (@vProject_type_cd != '90' AND @pStd_workding_day IS NOT NULL)
        BEGIN
            RAISERROR('템플릿인 경우만 워킹데이가 수정 가능하며, 그 외에는 일정에 의해 자동 계산 됩니다.', 16, 1);
        END

        IF @pTask_id IS NULL
        BEGIN
            RAISERROR('task_id는 필수 값 입니다.', 16, 1);
        END

        -- 완료 된 태스크는 수정 불가
        IF EXISTS(SELECT 1 FROM dbo.task AS T WITH (NOLOCK) WHERE T.task_id = @pTask_id AND T.status_cd = '90')
        BEGIN
            RAISERROR('완료 된 태스크는 수정 불가 합니다.', 16, 1);
        END

        BEGIN TRAN

            IF (@vProject_type_cd = '90' AND @pStd_workding_day IS NOT NULL)
            BEGIN
                UPDATE TFP SET
                    TFP.working_day = @pStd_workding_day
                FROM dbo.task_finish_plan AS TFP WITH (NOLOCK)
                WHERE TFP.task_id = @pTask_id
                AND TFP.plan_cd = '10';
            END
            
            UPDATE T SET
                task_name       = ISNULL(@pTask_name,       T.task_name),
                status_cd       = ISNULL(@pStatus_cd,       T.status_cd),
                is_output_need  = ISNULL(@pIs_output_need,  T.is_output_need),
                modifier_id     = ISNULL(@pModifier_id,     T.modifier_id),
                modified_at     = GETDATE()
            FROM dbo.task AS T WITH (NOLOCK)
            WHERE task_id = @pTask_id;

            -- 태스크 담당자 업데이트
            IF EXISTS(SELECT 1 FROM @MemberList)
            BEGIN
                -- 신규 인원 인서트
                INSERT INTO dbo.task_owner
                SELECT
                    @pTask_id           AS task_id,
                    ML.member_id        AS member_id,
                    '10'                AS is_active_cd,
                    @pModifier_id       AS creator_id,
                    GETDATE()           AS created_at,
                    NULL                AS modifier_id,
                    NULL                AS modified_at
                FROM @MemberList AS ML
                    LEFT JOIN dbo.task_owner AS TOWN WITH (NOLOCK)
                    ON ML.member_id = TOWN.member_id
                    AND TOWN.task_id = @pTask_id
                WHERE TOWN.member_id IS NULL

                -- 교집합 10으로 업데이트
                UPDATE TOWN SET
                    TOWN.is_active_cd = '10',
                    TOWN.modifier_id = @pModifier_id,
                    TOWN.modified_at = GETDATE()
                FROM dbo.task_owner AS TOWN WITH (NOLOCK)
                    INNER JOIN @MemberList AS ML
                    ON TOWN.member_id = ML.member_id
                    AND TOWN.task_id = @pTask_id

                -- 차집합 90으로 업데이트
                UPDATE TOWN SET
                    TOWN.is_active_cd = '90',
                    TOWN.modifier_id = @pModifier_id,
                    TOWN.modified_at = GETDATE()
                FROM dbo.task_owner AS TOWN WITH (NOLOCK)
                    LEFT JOIN @MemberList AS ML
                    ON TOWN.member_id = ML.member_id
                    AND TOWN.task_id = @pTask_id
                WHERE ML.member_id IS NULL
                AND TOWN.task_id = @pTask_id
            END

        COMMIT TRAN;

	    -- 성공 메시지
        SET @vSeverity = 0;
	    SET @result_cd = 0;
	    SET @result_msg = '성공';
        
	END TRY

	BEGIN CATCH
		IF @@TRANCOUNT > 0
			ROLLBACK TRAN;
		
		-- 실패 메시지
		SET @result_cd = -1;
		SET @result_msg = ERROR_MESSAGE();
        SET @vSeverity = ERROR_SEVERITY();
        
    END CATCH

	-- 로깅	
    DECLARE @log_param      VARCHAR(MAX)  = NULL;
    DECLARE @log_message    VARCHAR(500) = NULL;

    SET @log_param = 
          '@pTask_id = '         + ISNULL(CAST(@pTask_id AS VARCHAR), 'NULL') + ', '
        + '@pTask_name = '''     + ISNULL(@pTask_name, 'NULL') + ''', '
        + '@pStatus_cd = '''     + ISNULL(@pStatus_cd, 'NULL') + ''', '
        --+ '@pIs_active_cd = '''  + ISNULL(@pIs_active_cd, 'NULL') + ''', '
        + '@pIs_output_need = '''+ ISNULL(@pIs_output_need, 'NULL') + ''', '
        + '@pStd_workding_day = '+ ISNULL(CAST(@pStd_workding_day AS VARCHAR), 'NULL') + ', '
        + '@pModifier_id = '''   + ISNULL(@pModifier_id, 'NULL') + '''';

    SET @log_message = 
        CASE WHEN @pTask_name IS NOT NULL THEN '태스크명 수정 [' + ISNULL(@pTask_name, '') + '], ' ELSE '' END +
        CASE WHEN @pStatus_cd IS NOT NULL THEN '상태 변경 [' + dbo.fnGetDetailNameByDetailCode('90300', ISNULL(@pStatus_cd,'')) + '], ' ELSE '' END +
        CASE WHEN @pIs_output_need IS NOT NULL THEN '산출물 필요 여부 변경 [' + CAST(ISNULL(@pIs_output_need,'') AS VARCHAR) + '], ' ELSE '' END +
        CASE WHEN @pStd_workding_day IS NOT NULL THEN '워킹데이 변경 [' + CAST(ISNULL(@pStd_workding_day,'') AS VARCHAR) + ']' ELSE '' END;
        

	INSERT INTO dbo.use_log (caller_id, severity, project_id, log_dt, log_message, proc_name, proc_param, result_cd, result_msg, created_at)
	VALUES(ISNULL(CAST(@pModifier_id AS VARCHAR(8)), 'UNKNOWN'), @vSeverity, ISNULL(@vProject_id, 0), CONVERT(CHAR(10), GETDATE(), 120), @log_message , '[spUpdateTask]', @log_param, @result_cd, @result_msg, GETDATE());

	RETURN;
END


--- Procedure 66 ---
ProcedureName: spUpdateTaskPlanDate
ProcedureDefinition:
-- =============================================
-- Author:		JayKwon
-- Create date: 2025-05-23
-- Description: 태스크의 계획/실제 시작 또는 종료일 업데이트
-- SAMPLE EXEC
/* 90201 10:표준, 20:계획, 30:실제 40:지연

DECLARE @result_cd INT, @result_msg VARCHAR(100);
EXEC [spUpdateTaskPlanDate] @pPlan_cd = '20', @pProject_id = 25080080, @pTask_id = 1445, @pStart_dt = '2025-08-12', @pEnd_dt = '2025-08-14', @pDelay_reason_cd = null, @pDelay_reason = null, @pModifier_id = 2,　@result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT;
SELECT @result_cd as result_cd, @result_msg as result_msg;
*/
-- =============================================
CREATE PROCEDURE [dbo].[spUpdateTaskPlanDate]
	@pPlan_cd			VARCHAR(8),
	@pProject_id		INT = NULL,
    @pTask_id			INT = NULL,
	@pStart_dt			VARCHAR(10) = NULL,
	@pEnd_dt			VARCHAR(10) = NULL,
	@pDelay_reason_cd	VARCHAR(8) = NULL,
	@pDelay_reason		VARCHAR(200) = NULL,
	@pModifier_id		VARCHAR(7) = NULL,
    @result_cd			INT				OUTPUT,
    @result_msg			VARCHAR(200)	OUTPUT
AS
BEGIN
	
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
	
	DECLARE @vSeverity				INT = NULL;

	BEGIN TRY
		-- 파라미터 유효성 체크
		IF (@pProject_id IS NULL OR @pTask_id IS NULL OR @pModifier_id IS NULL)
		BEGIN
			RAISERROR('파라미터가 누락되었습니다.', 16, 1);
		END
	
		-- 파라미터 유효성 체크
		IF NOT EXISTS(SELECT 1 FROM dbo.project AS P WITH (NOLOCK) WHERE P.project_id = @pProject_id)
		BEGIN	
			RAISERROR('존재하지 않는 프로젝트 입니다.', 16, 1);
		END

		-- 파라미터 유효성 체크
		IF NOT EXISTS(SELECT 1 FROM dbo.task AS T WITH (NOLOCK) WHERE T.task_id = @pTask_id)
		BEGIN		
			RAISERROR('존재하지 않는 태스크 입니다.', 16, 1);
		END

		-- 파라미터 유효성 체크
		IF (@pStart_dt IS NULL AND @pEnd_dt IS NULL)
		BEGIN
			RAISERROR('시작 또는 종료일은 반드시 필요합니다.', 16, 1);
		END
	
		-- 90201 10:표준, 20:계획, 30:실제 40:지연
		-- 지연 등록일 때, 시작일자는 실제 시작일로 등록 한다.
		DECLARE @vActual_start_dt	AS VARCHAR(10) = NULL;
		DECLARE @vActual_end_dt		AS VARCHAR(10) = NULL;

		SELECT
			@vActual_start_dt = TFP.start_dt,
			@vActual_end_dt = TFP.end_dt
		FROM dbo.task_finish_plan AS TFP WITH (NOLOCK)
		WHERE TFP.task_id = @pTask_id
		AND TFP.plan_cd = '30';


		IF (@vActual_start_dt > @pEnd_dt)
		BEGIN	
			RAISERROR('종료일이 시작일보다 빠를 수 없습니다.', 16, 1);
		END

		-- n차 지연 종료일 입력시 이전 지연 종료일보다 작거나 같을 수 없다.
		DECLARE @vLastest_delayed_dt AS VARCHAR(10) = NULL;
		SELECT
			@vLastest_delayed_dt = MAX(TFP.end_dt)
		FROM dbo.task_finish_plan AS TFP WITH (NOLOCK)
		WHERE TFP.plan_cd = '40'
		AND TFP.task_id = @pTask_id

		IF (@pPlan_cd = '40')
		BEGIN
			IF(@pEnd_dt <= ISNULL(@vLastest_delayed_dt, @vActual_end_dt))
			BEGIN
				RAISERROR('N차 종료일은 N-1차 종료일 보다 작을 수 없습니다.', 16, 1);
			END
		END
		

		-- 지연인데 착수 안한 태스크라면 오류
		IF (@pPlan_cd = '40' AND EXISTS(SELECT 1 FROM dbo.task AS T WITH (NOLOCK) WHERE T.task_id = @pTask_id AND T.status_cd != '20'))
		BEGIN		
			RAISERROR('착수 한 태스크에 대해서만 지연 등록 가능 합니다.', 16, 1);
		END
		

		BEGIN TRAN
		IF (@pPlan_cd = '40') -- 일정타입이 지연이면 그냥 넣어준다.
		BEGIN			
			INSERT INTO task_finish_plan (			
				project_id,
				task_id,
				plan_cd,
				start_dt,
				end_dt,
				working_day,
				delay_reason_cd,
				delay_reason,
				creator_id,
				created_at,
				modifier_id,
				modified_at)
			VALUES (
				@pProject_id,
				@pTask_id,
				@pPlan_cd,
				@vActual_start_dt,
				@pEnd_dt,
				dbo.fnCalcWorkingDay(@pStart_dt, @pEnd_dt),
				@pDelay_reason_cd,
				@pDelay_reason,
				@pModifier_id,
				GETDATE(),
				null,
				null
			)
			-- 지연일을 넣어주고 넣어준 일정으로 실제 종료일을 다시 업데이트 해준다.
			UPDATE TFP SET
				TFP.end_dt = @pEnd_dt
			FROM dbo.task_finish_plan AS TFP WITH (NOLOCK)
			WHERE TFP.task_id = @pTask_id
			AND TFP.plan_cd = '30'

			
			-- 원래 일정보다 빨리 종료 시키면 상관 없지만 원래 일정보다 늦게 종료 처리 된 경우 부모 태스크 일정을 점검
			-- 만약 부모 태스크가 있다면
			DECLARE @vParent_end_dt VARCHAR(10) = NULL, @vChild_end_dt VARCHAR(10) = NULL;
			DECLARE @vParent_task_id INT = NULL;

			IF EXISTS(SELECT 1 FROM dbo.task_dependency AS TD WITH (NOLOCK) WHERE TD.task_id = @pTask_id AND TD.dependency_cd = '10')
			BEGIN
				-- 만약 부모 태스크의 종료일이 자식 태스크의 종료일보다 작다면 자식 태스크의 종료일로 맞춰 준다.
				-- 부모 종료일 획득
				SELECT
					@vParent_end_dt = TFP.end_dt,
					@vParent_task_id = TFP.task_id
				FROM dbo.task_dependency AS TD WITH (NOLOCK)
					INNER JOIN dbo.task_finish_plan AS TFP WITH (NOLOCK)
					ON TD.dependency_id = TFP.task_id
				WHERE TD.task_id = @pTask_id
				AND TD.dependency_cd = '10'
				AND TFP.plan_cd = '30'

				-- 자식 종료일 획득
				SELECT
					@vChild_end_dt = TFP.end_dt
				FROM dbo.task_finish_plan AS TFP WITH (NOLOCK)
				WHERE TFP.task_id = @pTask_id
				AND TFP.plan_cd = '30';

				-- 비교 후 작으면 자식 기준으로 확장
				IF (@vParent_end_dt < @vChild_end_dt)
				BEGIN
					UPDATE TFP SET
						TFP.end_dt = @vChild_end_dt
					FROM dbo.task_finish_plan AS TFP WITH (NOLOCK)
					WHERE TFP.task_id = @vParent_task_id
					AND TFP.plan_cd = '30'
				END
			END

		END
		ELSE
		BEGIN
			-- 지연이 아닌 일반적인 일정 넣어주기
			IF NOT EXISTS (SELECT 1 FROM task_finish_plan AS TFP WITH (NOLOCK) WHERE TFP.project_id = @pProject_id AND TFP.plan_cd = @pPlan_cd AND TFP.task_id = @pTask_id)
			BEGIN			
				INSERT INTO dbo.task_finish_plan (						
								project_id,
								task_id,
								plan_cd,
								start_dt,
								end_dt,
								working_day,
								delay_reason_cd,
								delay_reason,
								creator_id,
								created_at,
								modifier_id,
								modified_at)
				VALUES(
								@pProject_id,
								@pTask_id,
								@pPlan_cd,
								@pStart_dt,
								@pEnd_dt,
								dbo.fnCalcWorkingDay(@pStart_dt, @pEnd_dt),
								null,
								null,
								@pModifier_id,
								GETDATE(),
								null,
								null
				)
			END
			-- 이미 등록된 일정의 수정
			ELSE
			BEGIN
				-- 조건1. 완료된 태스크의 일정은 변경 할 수 없다.
				IF EXISTS(	SELECT 1
							FROM dbo.task AS T WITH (NOLOCK)
							WHERE T.task_id = @pTask_id
							AND T.status_cd = '90')
				BEGIN
					RAISERROR('완료한 태스크는 수정 할 수 없습니다.', 16, 1);
				END
				
				-- 조건2. 변경 하려는 일정이 상위 일정일때, 하위 일정의 최소 시작일, 최대 완료일 범위를 벗어날 수 없다.
				DECLARE @vMax_start_dt		VARCHAR(10) = NULL;
				DECLARE @vMax_end_dt		VARCHAR(10) = NULL;
				DECLARE @vIsParent			INT = NULL;

				SELECT
					@vMax_start_dt = MAX(TFP.start_dt),
					@vMax_end_dt = MAX(TFP.end_dt),
					@vIsParent = CASE WHEN (MAX(TFP.start_dt) IS NOT NULL AND MAX(TFP.end_dt) IS NOT NULL) THEN 1
									  ELSE NULL
								 END
				FROM dbo.task_dependency AS TD WITH (NOLOCK)
					INNER JOIN dbo.task_finish_plan AS TFP WITH (NOLOCK)
					ON TD.task_id = TFP.task_id					
				WHERE TD.dependency_id = @pTask_id
				AND TD.dependency_cd = '10'
				AND TFP.plan_cd = @pPlan_cd;
				
				IF (@vMax_start_dt IS NOT NULL AND @vMax_end_dt IS NOT NULL)
				BEGIN
					IF (@pStart_dt > @vMax_start_dt OR @pEnd_dt < @vMax_end_dt)
					BEGIN
						RAISERROR('변경하려는 태스크는 하위 태스크의 기간을 벗어날 수 없습니다.', 16, 1);
					END
				END

				-- 조건3. 변경 하려는 일정이 하위 일정일때, 상위 일정의 최소 시작일, 최대 완료일 범위를 벗어날 수 없다.
				SET @vMax_start_dt		 = NULL;
				SET @vMax_end_dt		 = NULL;

				SELECT
					@vMax_start_dt = MAX(TFP.start_dt),
					@vMax_end_dt = MAX(TFP.end_dt)
				FROM dbo.task_dependency AS TD WITH (NOLOCK)
					INNER JOIN dbo.task_finish_plan AS TFP WITH (NOLOCK)
					ON TD.dependency_id = TFP.task_id					
				WHERE TD.task_id = @pTask_id
				AND TD.dependency_cd = '10'
				AND TFP.plan_cd = @pPlan_cd;
				
				IF (@vMax_start_dt IS NOT NULL AND @vMax_end_dt IS NOT NULL)
				BEGIN
					IF (@pStart_dt < @vMax_start_dt OR @pEnd_dt > @vMax_end_dt)
					BEGIN
						RAISERROR('변경하려는 태스크는 상위 태스크의 기간을 벗어날 수 없습니다.', 16, 1);
					END
				END


				UPDATE TFP SET
					TFP.start_dt = @pStart_dt,
					TFP.end_dt = @pEnd_dt,
					TFP.working_day = dbo.fnCalcWorkingDay(@pStart_dt, @pEnd_dt),
					TFP.modifier_id = @pModifier_id,
					TFP.modified_at = GETDATE()
				FROM task_finish_plan AS TFP WITH (NOLOCK)
					INNER JOIN project AS P WITH (NOLOCK)
					ON TFP.project_id = P.project_id
					INNER JOIN task AS T WITH (NOLOCK)
					ON TFP.task_id = T.task_id
				WHERE TFP.task_id = @pTask_id
				AND TFP.plan_cd = @pPlan_cd; -- 90201 10:표준, 20:계획, 30:실제 40:지연

				-- 상위 일정 변경 시 하위 일정을 모두 동일하게 변경 시켜 버린다. (완료 제외)
				IF (@vIsParent = 1)
				BEGIN

					UPDATE TFP SET
						TFP.start_dt = @pStart_dt,
						TFP.end_dt = @pEnd_dt,
						TFP.working_day = dbo.fnCalcWorkingDay(@pStart_dt, @pEnd_dt)
					FROM dbo.task_dependency AS TD WITH (NOLOCK)
						INNER JOIN dbo.task AS T WITH (NOLOCK)
						ON TD.task_id = T.task_id
						INNER JOIN dbo.task_finish_plan AS TFP WITH (NOLOCK)
						ON TD.task_id = TFP.task_id					
					WHERE TD.dependency_id = @pTask_id
					AND TD.dependency_cd = '10'
					AND TFP.plan_cd = @pPlan_cd
					AND T.status_cd != '90';

				END
			END
		END

		-- 일정 처리 후 디펜던시 태스크들에 대한 재계산 (일자 쉬프팅)
		-- 일정이 바뀐 태스크 아이디, 늘어난 워킹 데이 던져서 디펜던시 관계의 태스크 모두 조정
		-- 1. 개별 일정이 업데이트면 전체 조정 불필요		

		COMMIT TRAN

		-- 개별이나 2뎁스의 일정 조정이면 쉬프팅 필요없다.
		DECLARE @vIs_indivisual_task	INT = 0;
		IF NOT EXISTS(	SELECT 1
						FROM dbo.task AS T WITH (NOLOCK)
							INNER JOIN dbo.task_dependency AS TD WITH (NOLOCK)
							ON T.task_id = TD.task_id
						WHERE T.task_id  = @pTask_id
						AND T.is_active_cd = '10')
		BEGIN
			SET @vIs_indivisual_task = 1;	-- 디펜던시가 없으면 개별
		END

		DECLARE @vIs_2Depth_task		INT = 0;
		IF EXISTS(	SELECT 1
					FROM dbo.task AS T WITH (NOLOCK)
						INNER JOIN dbo.task_dependency AS TD WITH (NOLOCK)
						ON T.task_id = TD.task_id			
					WHERE T.is_active_cd = '10'
					AND T.task_id = @pTask_id
					AND TD.dependency_cd = '10')
		BEGIN
			SET @vIs_2Depth_task = 1;
		END

		IF (@vIs_indivisual_task = 0 AND @vIs_2Depth_task = 0)
		BEGIN
			DECLARE @vResult_cd INT, @vResult_msg VARCHAR(100);
			EXEC [dbo].[spUpdateDateByShifting] @pProject_id = @pProject_id, @pTask_id = @pTask_id,  @pPlan_cd = '20' , @result_cd = @vResult_cd OUTPUT, @result_msg = @vResult_msg OUTPUT;

			IF (@vResult_cd = -1)
			BEGIN
				--CATCH로 이동
				RAISERROR('태스크 (계획)일정 쉬프팅 오류 발생 [spUpdateTaskPlanDate]', 16, 1);
			END

			-- 만약 착수 한 상태라면 실제 일정쪽도 (보정)업데이트 해준다.
			IF EXISTS(	SELECT 1
						FROM dbo.project AS P WITH (NOLOCK)
						WHERE P.project_id = @pProject_id
						AND P.kick_off_cd = '10')
			BEGIN
				EXEC [dbo].[spUpdateDateByShifting] @pProject_id = @pProject_id, @pTask_id = @pTask_id, @pPlan_cd = '30' , @result_cd = @vResult_cd OUTPUT, @result_msg = @vResult_msg OUTPUT;

				IF (@vResult_cd = -1)
				BEGIN
					--CATCH로 이동
					RAISERROR('태스크 (실제)일정 쉬프팅 오류 발생 [spUpdateTaskPlanDate]', 16, 1);
				END
			END
		END
		
		SET @vSeverity = 0;
		SET @result_cd = 0;
		SET @result_msg = '성공';   
	END TRY
	BEGIN CATCH
		IF @@TRANCOUNT > 0
			ROLLBACK TRAN;

		-- 실패 메시지
		SET @result_cd = -1;
		SET @result_msg = ERROR_MESSAGE();
		SET @vSeverity = ERROR_SEVERITY();
	END CATCH

	DECLARE @log_param		VARCHAR(MAX) = NULL;
	DECLARE @vTask_name		VARCHAR(200) = NULL;

	SELECT
		@vTask_name = T.task_name
	FROM dbo.task AS T WITH (NOLOCK)
	WHERE T.task_id = @pTask_id;

	SET @log_param = 
		'@pPlan_cd = ' + ISNULL(@pPlan_cd, 'NULL') + ', ' +
		'@pProject_id = ' + ISNULL(CAST(@pProject_id AS VARCHAR), 'NULL') + ', ' +
		'@pTask_id = ' + ISNULL(CAST(@pTask_id AS VARCHAR), 'NULL') + ', ' +
		'@pStart_dt = ' + ISNULL(@pStart_dt, 'NULL') + ', ' +
		'@pEnd_dt = ' + ISNULL(@pEnd_dt, 'NULL') + ', ' +
		'@pDelay_reason_cd = ' + ISNULL(@pDelay_reason_cd, 'NULL') + ', ' +
		'@pDelay_reason = ' + ISNULL(@pDelay_reason, 'NULL') + ', ' +
		'@pModifier_id = ' + ISNULL(@pModifier_id, 'NULL');

	INSERT INTO dbo.use_log (caller_id, severity, project_id, log_dt, log_message, proc_name, proc_param, result_cd, result_msg, created_at)
	VALUES(ISNULL(CAST(@pModifier_id AS VARCHAR(8)), 'UNKNOWN'), @vSeverity, ISNULL(@pProject_id, 0), CONVERT(CHAR(10), GETDATE(), 120), 
	ISNULL(@vTask_name, 'UNKOWN') + ' 태스크의 ' + dbo.fnGetDetailNameByDetailCode('90201', @pPlan_cd) + ' 일정이 업데이트 되었습니다. [시작 : ' + @pStart_dt + ', 종료 : ' + @pEnd_dt + ']',
	'[spUpdateTaskPlanDate]', @log_param, @result_cd, @result_msg, GETDATE());

	RETURN;
    
END


--- Procedure 67 ---
ProcedureName: spUpdateTaskState
ProcedureDefinition:
-- =============================================
-- Author:		jaykwon
-- Create date: 2025-06-22
-- Description:	태스크 착수 또는 종료 
/* mst (90300,태스크상태) 10 대기, 20 착수, 90 완료

DECLARE @result_cd INT, @result_msg VARCHAR(100);
EXEC [dbo].[spUpdateTaskState] @pTask_id = 28, @pState_cd = '90',　@result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT;
SELECT @result_cd as result_cd, @result_msg as result_msg;
*/
-- =============================================
CREATE PROCEDURE [dbo].[spUpdateTaskState]
	@pTask_id				INT = NULL,
	@pState_cd				VARCHAR(8) = NULL,
	@pModifier_id			VARCHAR(7) = NULL,
    @result_cd				INT OUTPUT,
    @result_msg				VARCHAR(200) OUTPUT
AS
BEGIN	
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	DECLARE @vParent_end_dt		VARCHAR(10) = NULL;
	DECLARE @vChild_end_dt		VARCHAR(10) = NULL;
	DECLARE @vParent_task_id	INT = NULL;
	DECLARE @vProject_id		INT = NULL;

	-- 프로젝트 아이디 획득
	SELECT
		@vProject_id = MAX(T.project_id)
	FROM dbo.task AS T WITH (NOLOCK)
	WHERE T.task_id = @pTask_id
	GROUP BY T.project_id


	-- 파라미터 코드 검증
	IF NOT EXISTS(	SELECT 1
					FROM dbo.code_master AS CM WITH (NOLOCK)
					WHERE CM.group_cd = '90300'
					AND CM.detail_cd = @pState_cd)
	BEGIN
		SET @result_cd = 1;
		SET @result_msg = '존재하지 않는 상태 코드 입니다.';
        RETURN;
	END

	-- 완료 처리 하려는데 디펜던시 관계의 오류
	IF (@pState_cd = '90')
	BEGIN
		-- 완료 하려는 태스크 하위에 태스크들이 있고, 그 하위 태스크들이 완료상태가 아니면 상위 태스크를 완료 할 수 없음.
		IF EXISTS(		SELECT 1
						FROM dbo.task_dependency AS TD WITH (NOLOCK)
							INNER JOIN dbo.task AS T WITH (NOLOCK)
							ON TD.task_id = T.task_id
						WHERE TD.dependency_id = @pTask_id
						AND TD.dependency_cd = '10'
						AND T.status_cd != '90')
		BEGIN
			SET @result_cd = 1;
			SET @result_msg = '하위 태스크가 모두 완료 처리 되어야 상위 태스크를 완료 할 수 있습니다.';
			RETURN;
		END

		-- 선행 태스크가 있다면 완료가 되어야 후행을 완료 할 수 있음
		IF EXISTS(		SELECT *
						FROM dbo.task_dependency AS TD WITH (NOLOCK)
							INNER JOIN dbo.task AS T WITH (NOLOCK)
							ON TD.dependency_id = T.task_id
						WHERE TD.task_id = @pTask_id
						AND TD.dependency_cd = '20'
						AND T.status_cd != '90')
		BEGIN
			SET @result_cd = 1;
			SET @result_msg = '선행 태스크가 완료 되어야 후행 태스크를 완료 처리 할 수 있습니다.';
			RETURN;
		END

	END


	BEGIN TRY
		BEGIN TRAN
		-- 착수일때
		IF (@pState_cd = '20')
		BEGIN
			DECLARE @vToday		VARCHAR(10) = NULL;
			SET @vToday = CONVERT(VARCHAR(10), GETDATE(), 120);

			IF EXISTS (SELECT 1 FROM dbo.task AS T WITH (NOLOCK) WHERE T.task_id = @pTask_id AND T.status_cd = '90')
			BEGIN
				ROLLBACK TRAN;
				SET @result_cd = 1;
				SET @result_msg = '이미 완료 한 태스크 입니다. 착수 상태로 변경할 수 없습니다.';
				RETURN;
			END
			
			-- task_finish_plan에 실제 시작 일자(30)을 오늘 날짜로 업데이트
			UPDATE TFP SET
				TFP.start_dt = @vToday,
				TFP.end_dt = dbo.fnGetWorkingDateAdd(@vToday, TFP.working_day),
				--TFP.working_day = dbo.fnCalcWorkingDay(@vToday, TFP.end_dt), -- 워킹데이 재계산
				TFP.modifier_id = @pModifier_id,
				TFP.modified_at = GETDATE()
			FROM dbo.task_finish_plan AS TFP WITH (NOLOCK)
			WHERE TFP.task_id = @pTask_id
			AND TFP.plan_cd = '30';


			-- task의 상태를 착수로 업데이트 (20)
			UPDATE T SET
				T.status_cd = '20',
				T.modifier_id = @pModifier_id,
				T.modified_at = GETDATE()
			FROM dbo.task AS T WITH (NOLOCK)
			WHERE T.task_id = @pTask_id;
		END
		-- 완료 일때
		ELSE IF (@pState_cd = '90')
		BEGIN
			-- task_finish_plan에 실제 완료 일자(30)을 오늘 날짜로 업데이트
			UPDATE TFP SET
				TFP.end_dt = CONVERT(VARCHAR(10), GETDATE(), 120),
				TFP.working_day = dbo.fnCalcWorkingDay(TFP.start_dt, CONVERT(VARCHAR(10), GETDATE(), 120)), -- 워킹데이 재계산
				TFP.modifier_id = @pModifier_id,
				TFP.modified_at = GETDATE()
			FROM dbo.task_finish_plan AS TFP WITH (NOLOCK)
			WHERE TFP.task_id = @pTask_id
			AND TFP.plan_cd = '30';

			-- task의 상태를 완료로 업데이트 (90)	
			UPDATE T SET
				T.status_cd = '90',
				T.modifier_id = @pModifier_id,
				T.modified_at = GETDATE()
			FROM dbo.task AS T WITH (NOLOCK)
			WHERE T.task_id = @pTask_id;

			-- 원래 일정보다 빨리 종료 시키면 상관 없지만 원래 일정보다 늦게 종료 처리 된 경우 부모 태스크 일정을 점검
			-- 만약 부모 태스크가 있다면
			IF EXISTS(SELECT 1 FROM dbo.task_dependency AS TD WITH (NOLOCK) WHERE TD.task_id = @pTask_id AND TD.dependency_cd = '10')
			BEGIN
				-- 만약 부모 태스크의 종료일이 자식 태스크의 종료일보다 작다면 자식 태스크의 종료일로 맞춰 준다.
				-- 부모 종료일 획득
				SELECT
					@vParent_end_dt = TFP.end_dt,
					@vParent_task_id = TFP.task_id
				FROM dbo.task_dependency AS TD WITH (NOLOCK)
					INNER JOIN dbo.task_finish_plan AS TFP WITH (NOLOCK)
					ON TD.dependency_id = TFP.task_id
				WHERE TD.task_id = @pTask_id
				AND TD.dependency_cd = '10'
				AND TFP.plan_cd = '30'

				-- 자식 종료일 획득
				SELECT
					@vChild_end_dt = TFP.end_dt
				FROM dbo.task_finish_plan AS TFP WITH (NOLOCK)
				WHERE TFP.task_id = @pTask_id
				AND TFP.plan_cd = '30';

				-- 비교 후 작으면 자식 기준으로 확장
				IF (@vParent_end_dt < @vChild_end_dt)
				BEGIN
					UPDATE TFP SET
						TFP.end_dt = @vChild_end_dt
					FROM dbo.task_finish_plan AS TFP WITH (NOLOCK)
					WHERE TFP.task_id = @vParent_task_id
					AND TFP.plan_cd = '30'
				END
			END
		END
		ELSE
		BEGIN
			ROLLBACK TRAN;
			SET @result_cd = 1;
			SET @result_msg = '처리할 수 없는 상태 코드.';
			RETURN;
		END

		COMMIT TRAN


		DECLARE @vResult_cd INT, @vResult_msg VARCHAR(100);
		EXEC [dbo].[spUpdateDateByShifting] @pProject_id = @vProject_id, @pTask_id = @pTask_id, @pPlan_cd = '30' , @result_cd = @vResult_cd OUTPUT, @result_msg = @vResult_msg OUTPUT;

		IF (@vResult_cd = -1)
		BEGIN
			--CATCH로 이동
			RAISERROR('태스크 (계획)일정 쉬프팅 오류 발생 [spUpdateTaskPlanDate]', 16, 1);
		END

		--DECLARE @vResult_cd INT, @vResult_msg VARCHAR(100);			
		--EXEC [dbo].[spUpdateTaskActualDate] @pProject_id = @vProject_id, @result_cd = @vResult_cd OUTPUT, @result_msg = @vResult_msg OUTPUT;


		--IF (@vResult_cd = -1)
		--BEGIN
		--	--CATCH로 이동
		--	RAISERROR('태스크 일정 쉬프팅 오류 발생 [spUpdateTaskState]', 16, 1);
		--END

		SET @result_cd = 0;
		SET @result_msg = '성공';   
	END TRY
	BEGIN CATCH
		ROLLBACK TRAN
		-- 실패 메시지
		SET @result_cd = -1;
		SET @result_msg = ERROR_MESSAGE();
	END CATCH

END


--- Procedure 68 ---
ProcedureName: spUpdateProjectKickOff
ProcedureDefinition:
-- =============================================
-- Author:		jay kwon
-- Create date: 2025-06-16
-- Description:	프로젝트 킥오프
/* 실행예제
DECLARE @result_cd INT, @result_msg VARCHAR(100);
EXEC [dbo].[spUpdateProjectKickOff] @pProject_id = 16, @pProject_owner_id = '2400000', @result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT;
SELECT @result_cd as result_cd, @result_msg as result_msg;
*/
-- =============================================
CREATE PROCEDURE [dbo].[spUpdateProjectKickOff]
	@pProject_id			INT,
	@pProject_owner_id		VARCHAR(7),
    @result_cd				INT OUTPUT,
    @result_msg				VARCHAR(200) OUTPUT
AS
BEGIN
	
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

    IF NOT EXISTS (
        SELECT 1
		FROM dbo.project_owner AS PO WITH (NOLOCK)
		WHERE PO.member_id = @pProject_owner_id
		AND PO.project_id = @pProject_id
    )
    BEGIN
		SET @result_cd = 1;
		SET @result_msg = '프로젝트 오너가 아닙니다. 프로젝트 오너 그룹에 속한 사람만 킥오프 가능 합니다.';        
        RETURN;
    END

	DECLARE @vCheckKickOff INT = 0;
	SET @vCheckKickOff = dbo.fnGetStateForKickOff(@pProject_id);
    IF (@vCheckKickOff != 10)
    BEGIN		
		SET @result_cd = 1;
		SET @result_msg = '킥오프 가능한 조건이 아닙니다. [' + dbo.fnGetDetailNameByDetailCode('90105', (CAST(@vCheckKickOff AS VARCHAR(8)))) + ']';        
        RETURN;
    END

	BEGIN TRY
		BEGIN TRAN
		-- 계획 일자를 실제 일자로 밀어 넣어준다.
		INSERT INTO dbo.task_finish_plan
		SELECT 			
			@pProject_id	AS project_id,
			TFP.task_id		AS task_id,
			'30'			AS plan_cd,
			TFP.start_dt	AS start_dt,
			TFP.end_dt		AS end_dt,
			TFP.working_day	AS working_day,
			NULL			AS delay_reason_cd,
			NULL			AS delay_reason,
			TFP.creator_id	AS creator_id,
			GETDATE()		AS created_at,
			NULL			AS modifier_id,
			NULL			AS modified_at
		FROM dbo.task_finish_plan AS TFP WITH (NOLOCK)
		WHERE TFP.project_id = @pProject_id
		AND TFP.plan_cd = '20'	--mst(90201, 태스크 일정 타입) : 10 표준, 20 계획, 30 실제, 40 지연

		-- 가장 큰 계획 일자 조회
		DECLARE @max_planed_end_dt		VARCHAR(10) = NULL;
		SELECT
			@max_planed_end_dt = MAX(TFP.end_dt)
		FROM dbo.task_finish_plan AS TFP WITH (NOLOCK)
		WHERE TFP.project_id = @pProject_id
		AND TFP.plan_cd = '20'
		GROUP BY TFP.project_id

		-- 프로젝트 
		UPDATE P SET
			P.kick_off_cd = '10',	-- mst(90104,킥오프여부): 10 착수, 20 착수 가능, 90 미착수, 99 착수불가
			P.planed_end_dt = @max_planed_end_dt,
			-- P.planed_working_day = dbo.fnCalcWorkingDay(P.planed_start_dt, @max_planed_end_dt),
			P.planed_working_day = dbo.fnGetProjectWorkingDayByType(P.project_id, '20'),
			P.modifier_id = @pProject_owner_id,
			P.modified_at = GETDATE()
		FROM dbo.project AS P WITH (NOLOCK)
		WHERE P.project_id = @pProject_id
		
					
		COMMIT TRAN
		
		SET @result_cd = 0;
		SET @result_msg = '성공';

	END TRY

	BEGIN CATCH
		ROLLBACK TRAN
		-- 실패 메시지
		SET @result_cd = -1;
		SET @result_msg = ERROR_MESSAGE();

	END CATCH

END


--- Procedure 69 ---
ProcedureName: spUpdateTaskActualDate
ProcedureDefinition:
-- =============================================
-- Author:		jaykwon
-- Create date: 2025-06-24
-- Description:	전체 1뎁스의 실제 일정 재계산
/*
DECLARE @result_cd INT, @result_msg VARCHAR(100);
EXEC [dbo].[spUpdateTaskActualDate] @pProject_id = 6,@result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT;
SELECT @result_cd as result_cd, @result_msg as result_msg;
*/
-- =============================================
CREATE PROCEDURE [dbo].[spUpdateTaskActualDate]
	@pProject_id		INT				= NULL,
	@result_cd			INT				OUTPUT,
    @result_msg			VARCHAR(200)	OUTPUT
AS
BEGIN
	
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	BEGIN TRY
		BEGIN TRAN

		-- 워킹데이 보정 (시작전)
		UPDATE TFP SET
			TFP.working_day = dbo.fnCalcWorkingDay(TFP.start_dt, TFP.end_dt)
		FROM dbo.task_finish_plan AS TFP WITH (NOLOCK)
		WHERE TFP.project_id = @pProject_id
		AND TFP.plan_cd = '30'


		DECLARE @vRootTask TABLE (
			task_id		INT,
			end_dt		VARCHAR(10),
			processed	INT
		);

		-- 루트 태스크 삽입
		INSERT INTO @vRootTask
		SELECT
			TD1.dependency_id AS task_id,
			TFP.end_dt,
			0 AS processed
		FROM task_dependency AS TD1
			LEFT JOIN task_dependency AS TD2
				ON TD1.dependency_id = TD2.task_id
				AND TD2.dependency_cd = '20'
			INNER JOIN dbo.task_finish_plan AS TFP
				ON TD1.task_id = TFP.task_id
				AND TFP.plan_cd = '30'
		WHERE TD1.project_id = @pProject_id
		  AND TD1.dependency_cd = '20'
		  AND TD2.task_id IS NULL;

		-- 루프 시작
		DECLARE @vOuterTaskID INT = NULL;

		SELECT
			@vOuterTaskID = T.task_id
		FROM @vRootTask AS T
		WHERE T.processed = 0;

		WHILE (@vOuterTaskID IS NOT NULL)
		BEGIN
			-- 재귀 CTE
			WITH DependencyChain AS (
				-- 시작점
				SELECT
					TD.task_id,
					TD.dependency_id,
					TD.dependency_cd,
					dbo.fnGetWorkingDateAdd(TFP1.end_dt, 1) AS new_start_dt,
					dbo.fnGetWorkingDateAdd(
						TFP1.end_dt, 
						TFP2.working_day
					) AS new_end_dt,
					1 AS level
				FROM dbo.task_dependency AS TD WITH (NOLOCK)
					INNER JOIN dbo.task_finish_plan AS TFP1 WITH (NOLOCK)
						ON TD.dependency_id = TFP1.task_id
						AND TFP1.plan_cd = '30'
					INNER JOIN dbo.task_finish_plan AS TFP2 WITH (NOLOCK)
						ON TD.task_id = TFP2.task_id
						AND TFP2.plan_cd = '30'
				WHERE TD.dependency_cd = '20'
				  AND TD.dependency_id = @vOuterTaskID

				UNION ALL

				-- 재귀 부분
				SELECT
					TDNext.task_id,
					TDNext.dependency_id,
					TDNext.dependency_cd,
					dbo.fnGetWorkingDateAdd(DC.new_end_dt, 1) AS new_start_dt,
					dbo.fnGetWorkingDateAdd(
						DC.new_end_dt, 
						TFP2.working_day
					) AS new_end_dt,
					DC.level + 1
				FROM dbo.task_dependency TDNext
					INNER JOIN DependencyChain DC
						ON TDNext.dependency_id = DC.task_id
					INNER JOIN dbo.task_finish_plan AS TFP2 WITH (NOLOCK)
						ON TDNext.task_id = TFP2.task_id
						AND TFP2.plan_cd = '30'
				WHERE TDNext.dependency_cd = '20'
			)	
			UPDATE TFP SET
				TFP.start_dt = DC.new_start_dt,
				TFP.end_dt = DC.new_end_dt
			FROM dbo.task_finish_plan AS TFP WITH (NOLOCK)
				INNER JOIN DependencyChain AS DC
				ON TFP.task_id = DC.task_id
				AND TFP.plan_cd = '30'



			-- 루트 처리 완료
			UPDATE T
			SET T.processed = 1
			FROM @vRootTask AS T
			WHERE T.task_id = @vOuterTaskID;

			-- 다음 루트 task_id 가져오기
			SET @vOuterTaskID = NULL;

			SELECT
				@vOuterTaskID = T.task_id
			FROM @vRootTask AS T
			WHERE T.processed = 0;
		END

		-- 워킹데이 보정 (완료후)
		UPDATE TFP SET
			TFP.working_day = dbo.fnCalcWorkingDay(TFP.start_dt, TFP.end_dt)
		FROM dbo.task_finish_plan AS TFP WITH (NOLOCK)
		WHERE TFP.project_id = @pProject_id
		AND TFP.plan_cd = '30';

		COMMIT TRAN
		SET @result_cd = 0;
		SET @result_msg = '성공';   
	END TRY
	BEGIN CATCH
		ROLLBACK TRAN
		-- 실패 메시지
		SET @result_cd = -1;
		SET @result_msg = ERROR_MESSAGE();
	END CATCH
END


--- Procedure 70 ---
ProcedureName: spGetCodeMasterForBrand
ProcedureDefinition:
-- =============================================
-- Author:		jaykwon
-- Create date: 2025-06-25
-- Description:	SAP 기준의 일반 또는 패밀리 브랜드 코드를 가져온다.
/*
-- 일반('NB') 브랜드
DECLARE  @result_cd INT, @result_msg VARCHAR(100);
EXEC  [dbo].[spGetCodeMasterForBrand] @pBrand_type = 'NB', @result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT;
SELECT @result_cd as result_cd, @result_msg as result_msg;

-- 패밀리('FB') 브랜드
DECLARE  @result_cd INT, @result_msg VARCHAR(100);
EXEC  [dbo].[spGetCodeMasterForBrand] @pBrand_type = 'FB', @result_cd = @result_cd OUTPUT, @result_msg = @result_msg OUTPUT;
SELECT @result_cd as result_cd, @result_msg as result_msg;
*/
-- =============================================
CREATE PROCEDURE [dbo].[spGetCodeMasterForBrand]
	@pBrand_type		VARCHAR(8) = NULL,
    @result_cd			INT OUTPUT,
    @result_msg			VARCHAR(200) OUTPUT
AS
BEGIN
	
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;



	BEGIN TRY
		IF (@pBrand_type = 'NB')
			BEGIN
				SELECT
					NB.BRANDCODE	AS brand_cd,
					NB.BRANDNAME	AS brand_name
				FROM dbo.IF_SAP_NPD_BRAND AS NB WITH (NOLOCK)
				WHERE NB.BRANDTYPE = '200'
				ORDER BY NB.BRANDNAME ASC;

				SET @result_cd = 0
				SET @result_msg = '성공'				

				RETURN;
			END
		ELSE IF(@pBrand_type = 'FB')
			BEGIN
				SELECT
					FB.BRANDCODE	AS brand_cd,
					FB.BRANDNAME	AS brand_name
				FROM dbo.IF_SAP_NPD_BRAND AS FB WITH (NOLOCK)
				WHERE FB.BRANDTYPE = '100'
				ORDER BY FB.BRANDNAME ASC;

				SET @result_cd = 0
				SET @result_msg = '성공'				

				RETURN;
			END
		ELSE
			BEGIN
				SET @result_cd = 1
				SET @result_msg = '정의되지 않은 브랜드 타입'				

				RETURN;
			END

		SET @result_cd = 0
		SET @result_msg = '성공'

	END TRY
	BEGIN CATCH
		SET @result_cd = -1
		SET @result_msg = ERROR_MESSAGE()
	END CATCH

END

